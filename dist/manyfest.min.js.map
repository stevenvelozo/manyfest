{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/decimal.js/decimal.js","manyfest.min.js","node_modules/elucidator/source/Elucidator-InstructionSet.js","node_modules/elucidator/source/Elucidator-LogToConsole.js","node_modules/elucidator/source/InstructionSets/Geometry.js","node_modules/elucidator/source/InstructionSets/Logic.js","node_modules/elucidator/source/InstructionSets/Math-Javascript.js","node_modules/elucidator/source/InstructionSets/Operations/Geometry-RectangleArea.json","node_modules/elucidator/source/InstructionSets/Operations/Logic-Execute.json","node_modules/elucidator/source/InstructionSets/Operations/Logic-If.json","node_modules/elucidator/source/InstructionSets/Operations/Math-Add.json","node_modules/elucidator/source/InstructionSets/Operations/Math-Aggregate.json","node_modules/elucidator/source/InstructionSets/Operations/Math-Divide.json","node_modules/elucidator/source/InstructionSets/Operations/Math-Multiply.json","node_modules/elucidator/source/InstructionSets/Operations/Math-Subtract.json","node_modules/elucidator/source/InstructionSets/Operations/PreciseMath-Add.json","node_modules/elucidator/source/InstructionSets/Operations/PreciseMath-Aggregate.json","node_modules/elucidator/source/InstructionSets/Operations/PreciseMath-Divide.json","node_modules/elucidator/source/InstructionSets/Operations/PreciseMath-Multiply.json","node_modules/elucidator/source/InstructionSets/Operations/PreciseMath-Subtract.json","node_modules/elucidator/source/InstructionSets/Operations/String-Replace.json","node_modules/elucidator/source/InstructionSets/Operations/String-Substring.json","node_modules/elucidator/source/InstructionSets/Operations/String-Trim.json","node_modules/elucidator/source/InstructionSets/PreciseMath-Decimal.js","node_modules/elucidator/source/InstructionSets/String.js","node_modules/elucidator/source/elucidator.js","node_modules/manyfest/source/Manyfest-HashTranslation.js","node_modules/manyfest/source/Manyfest-LogToConsole.js","node_modules/manyfest/source/Manyfest-ObjectAddressGeneration.js","node_modules/manyfest/source/Manyfest-ObjectAddressResolver.js","node_modules/manyfest/source/Manyfest-SchemaManipulation.js","node_modules/manyfest/source/Manyfest.js","node_modules/precedent/source/Precedent.js","node_modules/precedent/source/StringParser.js","node_modules/precedent/source/WordTree.js","source/Manyfest-Browser-Shim.js","source/Manyfest-ObjectAddressResolver.js","source/Manyfest.js"],"names":["f","exports","module","define","amd","window","global","self","this","Fable","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","globalScope","Decimal","inexact","noConflict","quadrant","EXP_LIMIT","MAX_DIGITS","NUMERALS","LN10","PI","DEFAULTS","precision","rounding","modulo","toExpNeg","toExpPos","minE","maxE","crypto","external","decimalError","invalidArgument","precisionLimitExceeded","cryptoUnavailable","tag","mathfloor","Math","floor","mathpow","pow","isBinary","isHex","isOctal","isDecimal","BASE","LN10_PRECISION","PI_PRECISION","P","toStringTag","digitsToString","d","k","ws","indexOfLastWord","str","w","getZeroString","checkInt32","min","max","checkRoundingDigits","rm","repeating","di","rd","ceil","convertBase","baseIn","baseOut","j","arrL","arr","strL","indexOf","charAt","reverse","absoluteValue","abs","x","constructor","s","finalise","clampedTo","clamp","Ctor","NaN","gt","cmp","comparedTo","y","xdL","ydL","xd","yd","xs","ys","cosine","cos","pr","sd","len","isZero","tinyPow","toString","taylorSeries","times","cos2x","minus","plus","toLessThanHalfPi","neg","cubeRoot","cbrt","m","rep","t3","t3plusx","isFinite","toExponential","slice","divide","eq","decimalPlaces","dp","dividedBy","div","dividedToIntegerBy","divToInt","equals","greaterThan","greaterThanOrEqualTo","gte","hyperbolicCosine","cosh","one","cosh2_x","d8","hyperbolicSine","sinh","sqrt","sinh2_x","d5","d16","d20","hyperbolicTangent","tanh","inverseCosine","acos","halfPi","isNeg","getPi","asin","inverseHyperbolicCosine","acosh","lte","ln","inverseHyperbolicSine","asinh","inverseHyperbolicTangent","atanh","wpr","xsd","inverseSine","atan","inverseTangent","px","x2","isInteger","isInt","isNaN","isNegative","isPositive","isPos","lessThan","lt","lessThanOrEqualTo","logarithm","log","base","isBase10","denominator","inf","num","arg","naturalLogarithm","getLn10","sub","xe","xLTy","push","pop","shift","getBase10Exponent","mod","q","naturalExponential","exp","negated","add","carry","unshift","z","getPrecision","round","sine","sin","sin2_x","squareRoot","tangent","tan","mul","rL","toBinary","toStringBinary","toDecimalPlaces","toDP","finiteToString","toFixed","toFraction","maxD","d0","d1","d2","n0","n1","toHexadecimal","toHex","toNearest","toNumber","toOctal","toPower","yn","intPow","toPrecision","toSignificantDigits","toSD","truncated","trunc","valueOf","toJSON","multiplyInteger","temp","compare","b","aL","bL","subtract","logBase","more","prod","prodL","qd","rem","remL","rem0","xi","xL","yd0","yL","yz","sign","isTruncated","digits","roundUp","xdi","out","isExp","nonFiniteToString","zs","truncate","isOdd","maxOrMin","args","ltgt","guard","sum","c0","numerator","x1","String","parseDecimal","replace","search","substring","charCodeAt","parseOther","divisor","isFloat","test","toLowerCase","isHyperbolic","pi","atan2","config","obj","v","useDefaults","defaults","ps","getRandomValues","randomBytes","hypot","arguments","isDecimalInstance","log2","log10","random","Uint32Array","copy","clone","prototype","ROUND_UP","ROUND_DOWN","ROUND_CEIL","ROUND_FLOOR","ROUND_HALF_UP","ROUND_HALF_DOWN","ROUND_HALF_EVEN","ROUND_HALF_CEIL","ROUND_HALF_FLOOR","EUCLID","set","hasOwnProperty","Symbol","iterator","pElucidator","elucidator","namespace","initializeNamespace","pNamespace","instructionSets","operationSets","addInstruction","pInstructionHash","fInstructionFunction","logError","initializeInstructions","pOperation","logInfo","addOperation","pOperationHash","Description","Hash","Operation","Namespace","Summary","Inputs","Outputs","Steps","Array","isArray","initializeOperations","logToConsole","pLogLine","pLogObject","pLogLevel","tmpLogLine","tmpLogLevel","console","JSON","stringify","info","warning","error","libElucidatorInstructionSet","super","ifInstruction","tmpLeftValue","InputManyfest","getValueByHash","InputObject","tmpRightValue","tmpComparator","tmpComparisonOperator","tmpComparisonOperatorMapping","equal","noteq","notequal","id","identity","greaterthan","greaterthanorequal","lessthan","lessthanorequal","tmpTrueNamespace","tmpTrueOperation","tmpFalseNamespace","tmpFalseOperation","tmpTruthiness","OutputManyfest","setValueByHash","OutputObject","Elucidator","solveInternalOperation","DescriptionManyfest","SolutionContext","InputHashMapping","OutputHashMapping","executeOperation","tmpNamespace","tmpOperation","tmpA","tmpB","multiply","aggregate","tmpAggregationValue","tmpValue","parseInt","tmpObjectKeys","Object","keys","Synopsis","Width","Type","Height","Area","Name","Ratio","Log","PreOperation","PostOperation","Instruction","InputHashAddressMap","OutputHashAddressMap","Default","operation","leftValue","rightValue","comparator","trueNamespace","trueOperation","falseNamespace","falseOperation","truthinessResult","inputString","searchFor","replaceWith","outputString","indexStart","indexEnd","libDecimal","tmpObjectType","trim","tmpInputString","tmpSearchFor","tmpReplaceWith","libSimpleLog","libManyfest","libPrecedent","pOperations","fInfoLog","fErrorLog","logWarning","fWarningLog","UUID","loadDefaultInstructionSets","tmpSolverHashes","loadInstructionSet","cInstructionSet","tmpInstructionSet","operationExists","tmpOperationInjector","pInputObject","pOutputObject","pDescriptionManyfest","pInputAddressMapping","pOutputAddressMapping","pSolutionContext","solveOperation","pOperationObject","parse","tmpInputObject","tmpOutputObject","tmpSolutionContext","SolutionGUID","SolutionBaseNamespace","SolutionBaseOperation","SolutionLog","InputHashTranslationTable","OutputHashTranslationTable","tmpDescriptionManyfest","schemaManipulations","mergeAddressMappings","resolveAddressMappings","hashTranslations","addTranslation","Synopsys","tmpPrecedent","addPattern","pHash","tmpHash","tmpDescriptor","getDescriptorByHash","parseString","tmpStep","tmpInputSchema","Scope","Descriptors","tmpInputManyfest","tmpOutputSchema","tmpOutputManyfest","tmpInstructionState","pMessage","fInstruction","manyfest","precedent","pInfoLog","pErrorLog","translationTable","translationCount","pTranslation","forEach","pTranslationSource","removeTranslationHash","pTranslationHash","removeTranslation","clearTranslations","translate","generateAddressses","pObject","pBaseAddress","pSchema","tmpBaseAddress","tmpSchema","tmpSchemaObjectEntry","Address","InSchema","DataType","tmpObjectProperties","cleanWrapCharacters","pCharacter","pString","startsWith","endsWith","checkAddressExists","pAddress","tmpSeparatorIndex","tmpBracketStartIndex","tmpBracketStopIndex","tmpBoxedPropertyName","tmpBoxedPropertyReference","tmpBoxedPropertyNumber","tmpSubObjectName","tmpNewAddress","getValueAtAddress","pParentAddress","tmpParentAddress","tmpObjectTypeMarkerIndex","tmpObjectPropertyName","tmpArrayProperty","tmpContainerObject","tmpPropertyParentAddress","tmpObjectProperty","tmpObjectPropertyKeys","setValueAtAddress","pValue","pManyfestSchemaDescriptors","pAddressMapping","tmpManyfestAddresses","tmpHashMapping","pInputAddress","tmpNewDescriptorAddress","tmpOldDescriptorAddress","safeResolveAddressMappings","tmpManyfestSchemaDescriptors","pManyfestSchemaDescriptorsDestination","pManyfestSchemaDescriptorsSource","tmpSource","tmpNewManyfestSchemaDescriptors","pDescriptorAddress","libHashTranslation","libObjectAddressResolver","libObjectAddressGeneration","libSchemaManipulation","Manyfest","pManifest","pOptions","objectAddressResolver","options","strict","defaultValues","Number","Float","Integer","Boolean","Binary","DateTime","Null","scope","undefined","elementAddresses","elementHashes","elementDescriptors","reset","loadManifest","objectAddressGeneration","tmpNewOptions","tmpNewManyfest","getManifest","deserialize","pManifestString","tmpDescriptionAddresses","addDescriptor","serialize","pDescriptor","getDescriptor","resolveHashAddress","checkAddressExistsByHash","tmpAddress","tmpInElementHashTable","tmpInTranslationTable","getDefaultValue","validate","tmpValidationData","Errors","MissingElements","addValidationError","pErrorMessage","tmpValueExists","Required","tmpElementType","Date","tmpDataType","populateDefaults","pOverwriteProperties","populateObject","fFilter","tmpObject","tmpOverwriteProperties","tmpFilterFunction","libWordTree","libStringParser","WordTree","StringParser","ParseTree","pPatternStart","pPatternEnd","pParser","newParserState","pParseTree","Output","OutputBuffer","Pattern","PatternMatch","PatternMatchOutputBuffer","assignNode","pNode","pParserState","appendOutputBuffer","flushOutputBuffer","checkPatternEnd","PatternEnd","PatternStart","substr","Parse","parseCharacter","tmpParserState","addChild","pTree","pPattern","pIndex","tmpLeaf","pData","apply","dup","elucidatorSolver","elucidatorSolverState","checkFilters","pRecord","libElucidator","tmpFilterState","Record","keepRecord","SolutionState","pMagicSearchExpression","tmpMagicComparisonPatternSet","split","tmpSearchAddress","tmpSearchComparator","tmpSearchValue","ComparisonState","SearchAddress","Comparator","SearchTerm","tmpInputArray","tmpOutputArray","dataSolvers","dataSolverState","Solvers","tmpSolverKeys","eachDescriptor","fAction","tmpDescriptorAddresses"],"mappings":"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","file":"manyfest.min.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()",";(function (globalScope) {\r\n  'use strict';\r\n\r\n\r\n  /*!\r\n   *  decimal.js v10.4.2\r\n   *  An arbitrary-precision Decimal type for JavaScript.\r\n   *  https://github.com/MikeMcl/decimal.js\r\n   *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>\r\n   *  MIT Licence\r\n   */\r\n\r\n\r\n  // -----------------------------------  EDITABLE DEFAULTS  ------------------------------------ //\r\n\r\n\r\n    // The maximum exponent magnitude.\r\n    // The limit on the value of `toExpNeg`, `toExpPos`, `minE` and `maxE`.\r\n  var EXP_LIMIT = 9e15,                      // 0 to 9e15\r\n\r\n    // The limit on the value of `precision`, and on the value of the first argument to\r\n    // `toDecimalPlaces`, `toExponential`, `toFixed`, `toPrecision` and `toSignificantDigits`.\r\n    MAX_DIGITS = 1e9,                        // 0 to 1e9\r\n\r\n    // Base conversion alphabet.\r\n    NUMERALS = '0123456789abcdef',\r\n\r\n    // The natural logarithm of 10 (1025 digits).\r\n    LN10 = '2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058',\r\n\r\n    // Pi (1025 digits).\r\n    PI = '3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789',\r\n\r\n\r\n    // The initial configuration properties of the Decimal constructor.\r\n    DEFAULTS = {\r\n\r\n      // These values must be integers within the stated ranges (inclusive).\r\n      // Most of these values can be changed at run-time using the `Decimal.config` method.\r\n\r\n      // The maximum number of significant digits of the result of a calculation or base conversion.\r\n      // E.g. `Decimal.config({ precision: 20 });`\r\n      precision: 20,                         // 1 to MAX_DIGITS\r\n\r\n      // The rounding mode used when rounding to `precision`.\r\n      //\r\n      // ROUND_UP         0 Away from zero.\r\n      // ROUND_DOWN       1 Towards zero.\r\n      // ROUND_CEIL       2 Towards +Infinity.\r\n      // ROUND_FLOOR      3 Towards -Infinity.\r\n      // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.\r\n      // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\r\n      // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\r\n      // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\r\n      // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\r\n      //\r\n      // E.g.\r\n      // `Decimal.rounding = 4;`\r\n      // `Decimal.rounding = Decimal.ROUND_HALF_UP;`\r\n      rounding: 4,                           // 0 to 8\r\n\r\n      // The modulo mode used when calculating the modulus: a mod n.\r\n      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\r\n      // The remainder (r) is calculated as: r = a - n * q.\r\n      //\r\n      // UP         0 The remainder is positive if the dividend is negative, else is negative.\r\n      // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).\r\n      // FLOOR      3 The remainder has the same sign as the divisor (Python %).\r\n      // HALF_EVEN  6 The IEEE 754 remainder function.\r\n      // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.\r\n      //\r\n      // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian\r\n      // division (9) are commonly used for the modulus operation. The other rounding modes can also\r\n      // be used, but they may not give useful results.\r\n      modulo: 1,                             // 0 to 9\r\n\r\n      // The exponent value at and beneath which `toString` returns exponential notation.\r\n      // JavaScript numbers: -7\r\n      toExpNeg: -7,                          // 0 to -EXP_LIMIT\r\n\r\n      // The exponent value at and above which `toString` returns exponential notation.\r\n      // JavaScript numbers: 21\r\n      toExpPos:  21,                         // 0 to EXP_LIMIT\r\n\r\n      // The minimum exponent value, beneath which underflow to zero occurs.\r\n      // JavaScript numbers: -324  (5e-324)\r\n      minE: -EXP_LIMIT,                      // -1 to -EXP_LIMIT\r\n\r\n      // The maximum exponent value, above which overflow to Infinity occurs.\r\n      // JavaScript numbers: 308  (1.7976931348623157e+308)\r\n      maxE: EXP_LIMIT,                       // 1 to EXP_LIMIT\r\n\r\n      // Whether to use cryptographically-secure random number generation, if available.\r\n      crypto: false                          // true/false\r\n    },\r\n\r\n\r\n  // ----------------------------------- END OF EDITABLE DEFAULTS ------------------------------- //\r\n\r\n\r\n    Decimal, inexact, noConflict, quadrant,\r\n    external = true,\r\n\r\n    decimalError = '[DecimalError] ',\r\n    invalidArgument = decimalError + 'Invalid argument: ',\r\n    precisionLimitExceeded = decimalError + 'Precision limit exceeded',\r\n    cryptoUnavailable = decimalError + 'crypto unavailable',\r\n    tag = '[object Decimal]',\r\n\r\n    mathfloor = Math.floor,\r\n    mathpow = Math.pow,\r\n\r\n    isBinary = /^0b([01]+(\\.[01]*)?|\\.[01]+)(p[+-]?\\d+)?$/i,\r\n    isHex = /^0x([0-9a-f]+(\\.[0-9a-f]*)?|\\.[0-9a-f]+)(p[+-]?\\d+)?$/i,\r\n    isOctal = /^0o([0-7]+(\\.[0-7]*)?|\\.[0-7]+)(p[+-]?\\d+)?$/i,\r\n    isDecimal = /^(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i,\r\n\r\n    BASE = 1e7,\r\n    LOG_BASE = 7,\r\n    MAX_SAFE_INTEGER = 9007199254740991,\r\n\r\n    LN10_PRECISION = LN10.length - 1,\r\n    PI_PRECISION = PI.length - 1,\r\n\r\n    // Decimal.prototype object\r\n    P = { toStringTag: tag };\r\n\r\n\r\n  // Decimal prototype methods\r\n\r\n\r\n  /*\r\n   *  absoluteValue             abs\r\n   *  ceil\r\n   *  clampedTo                 clamp\r\n   *  comparedTo                cmp\r\n   *  cosine                    cos\r\n   *  cubeRoot                  cbrt\r\n   *  decimalPlaces             dp\r\n   *  dividedBy                 div\r\n   *  dividedToIntegerBy        divToInt\r\n   *  equals                    eq\r\n   *  floor\r\n   *  greaterThan               gt\r\n   *  greaterThanOrEqualTo      gte\r\n   *  hyperbolicCosine          cosh\r\n   *  hyperbolicSine            sinh\r\n   *  hyperbolicTangent         tanh\r\n   *  inverseCosine             acos\r\n   *  inverseHyperbolicCosine   acosh\r\n   *  inverseHyperbolicSine     asinh\r\n   *  inverseHyperbolicTangent  atanh\r\n   *  inverseSine               asin\r\n   *  inverseTangent            atan\r\n   *  isFinite\r\n   *  isInteger                 isInt\r\n   *  isNaN\r\n   *  isNegative                isNeg\r\n   *  isPositive                isPos\r\n   *  isZero\r\n   *  lessThan                  lt\r\n   *  lessThanOrEqualTo         lte\r\n   *  logarithm                 log\r\n   *  [maximum]                 [max]\r\n   *  [minimum]                 [min]\r\n   *  minus                     sub\r\n   *  modulo                    mod\r\n   *  naturalExponential        exp\r\n   *  naturalLogarithm          ln\r\n   *  negated                   neg\r\n   *  plus                      add\r\n   *  precision                 sd\r\n   *  round\r\n   *  sine                      sin\r\n   *  squareRoot                sqrt\r\n   *  tangent                   tan\r\n   *  times                     mul\r\n   *  toBinary\r\n   *  toDecimalPlaces           toDP\r\n   *  toExponential\r\n   *  toFixed\r\n   *  toFraction\r\n   *  toHexadecimal             toHex\r\n   *  toNearest\r\n   *  toNumber\r\n   *  toOctal\r\n   *  toPower                   pow\r\n   *  toPrecision\r\n   *  toSignificantDigits       toSD\r\n   *  toString\r\n   *  truncated                 trunc\r\n   *  valueOf                   toJSON\r\n   */\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the absolute value of this Decimal.\r\n   *\r\n   */\r\n  P.absoluteValue = P.abs = function () {\r\n    var x = new this.constructor(this);\r\n    if (x.s < 0) x.s = 1;\r\n    return finalise(x);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the\r\n   * direction of positive Infinity.\r\n   *\r\n   */\r\n  P.ceil = function () {\r\n    return finalise(new this.constructor(this), this.e + 1, 2);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal clamped to the range\r\n   * delineated by `min` and `max`.\r\n   *\r\n   * min {number|string|Decimal}\r\n   * max {number|string|Decimal}\r\n   *\r\n   */\r\n  P.clampedTo = P.clamp = function (min, max) {\r\n    var k,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n    min = new Ctor(min);\r\n    max = new Ctor(max);\r\n    if (!min.s || !max.s) return new Ctor(NaN);\r\n    if (min.gt(max)) throw Error(invalidArgument + max);\r\n    k = x.cmp(min);\r\n    return k < 0 ? min : x.cmp(max) > 0 ? max : new Ctor(x);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return\r\n   *   1    if the value of this Decimal is greater than the value of `y`,\r\n   *  -1    if the value of this Decimal is less than the value of `y`,\r\n   *   0    if they have the same value,\r\n   *   NaN  if the value of either Decimal is NaN.\r\n   *\r\n   */\r\n  P.comparedTo = P.cmp = function (y) {\r\n    var i, j, xdL, ydL,\r\n      x = this,\r\n      xd = x.d,\r\n      yd = (y = new x.constructor(y)).d,\r\n      xs = x.s,\r\n      ys = y.s;\r\n\r\n    // Either NaN or Infinity?\r\n    if (!xd || !yd) {\r\n      return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;\r\n    }\r\n\r\n    // Either zero?\r\n    if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;\r\n\r\n    // Signs differ?\r\n    if (xs !== ys) return xs;\r\n\r\n    // Compare exponents.\r\n    if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;\r\n\r\n    xdL = xd.length;\r\n    ydL = yd.length;\r\n\r\n    // Compare digit by digit.\r\n    for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {\r\n      if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;\r\n    }\r\n\r\n    // Compare lengths.\r\n    return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the cosine of the value in radians of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-1, 1]\r\n   *\r\n   * cos(0)         = 1\r\n   * cos(-0)        = 1\r\n   * cos(Infinity)  = NaN\r\n   * cos(-Infinity) = NaN\r\n   * cos(NaN)       = NaN\r\n   *\r\n   */\r\n  P.cosine = P.cos = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.d) return new Ctor(NaN);\r\n\r\n    // cos(0) = cos(-0) = 1\r\n    if (!x.d[0]) return new Ctor(1);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\r\n    Ctor.rounding = 1;\r\n\r\n    x = cosine(Ctor, toLessThanHalfPi(Ctor, x));\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   *\r\n   * Return a new Decimal whose value is the cube root of the value of this Decimal, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   *  cbrt(0)  =  0\r\n   *  cbrt(-0) = -0\r\n   *  cbrt(1)  =  1\r\n   *  cbrt(-1) = -1\r\n   *  cbrt(N)  =  N\r\n   *  cbrt(-I) = -I\r\n   *  cbrt(I)  =  I\r\n   *\r\n   * Math.cbrt(x) = (x < 0 ? -Math.pow(-x, 1/3) : Math.pow(x, 1/3))\r\n   *\r\n   */\r\n  P.cubeRoot = P.cbrt = function () {\r\n    var e, m, n, r, rep, s, sd, t, t3, t3plusx,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite() || x.isZero()) return new Ctor(x);\r\n    external = false;\r\n\r\n    // Initial estimate.\r\n    s = x.s * mathpow(x.s * x, 1 / 3);\r\n\r\n     // Math.cbrt underflow/overflow?\r\n     // Pass x to Math.pow as integer, then adjust the exponent of the result.\r\n    if (!s || Math.abs(s) == 1 / 0) {\r\n      n = digitsToString(x.d);\r\n      e = x.e;\r\n\r\n      // Adjust n exponent so it is a multiple of 3 away from x exponent.\r\n      if (s = (e - n.length + 1) % 3) n += (s == 1 || s == -2 ? '0' : '00');\r\n      s = mathpow(n, 1 / 3);\r\n\r\n      // Rarely, e may be one less than the result exponent value.\r\n      e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));\r\n\r\n      if (s == 1 / 0) {\r\n        n = '5e' + e;\r\n      } else {\r\n        n = s.toExponential();\r\n        n = n.slice(0, n.indexOf('e') + 1) + e;\r\n      }\r\n\r\n      r = new Ctor(n);\r\n      r.s = x.s;\r\n    } else {\r\n      r = new Ctor(s.toString());\r\n    }\r\n\r\n    sd = (e = Ctor.precision) + 3;\r\n\r\n    // Halley's method.\r\n    // TODO? Compare Newton's method.\r\n    for (;;) {\r\n      t = r;\r\n      t3 = t.times(t).times(t);\r\n      t3plusx = t3.plus(x);\r\n      r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);\r\n\r\n      // TODO? Replace with for-loop and checkRoundingDigits.\r\n      if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\r\n        n = n.slice(sd - 3, sd + 1);\r\n\r\n        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or 4999\r\n        // , i.e. approaching a rounding boundary, continue the iteration.\r\n        if (n == '9999' || !rep && n == '4999') {\r\n\r\n          // On the first iteration only, check to see if rounding up gives the exact result as the\r\n          // nines may infinitely repeat.\r\n          if (!rep) {\r\n            finalise(t, e + 1, 0);\r\n\r\n            if (t.times(t).times(t).eq(x)) {\r\n              r = t;\r\n              break;\r\n            }\r\n          }\r\n\r\n          sd += 4;\r\n          rep = 1;\r\n        } else {\r\n\r\n          // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.\r\n          // If not, then there are further digits and m will be truthy.\r\n          if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n            // Truncate to the first rounding digit.\r\n            finalise(r, e + 1, 1);\r\n            m = !r.times(r).times(r).eq(x);\r\n          }\r\n\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    external = true;\r\n\r\n    return finalise(r, e, Ctor.rounding, m);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the number of decimal places of the value of this Decimal.\r\n   *\r\n   */\r\n  P.decimalPlaces = P.dp = function () {\r\n    var w,\r\n      d = this.d,\r\n      n = NaN;\r\n\r\n    if (d) {\r\n      w = d.length - 1;\r\n      n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;\r\n\r\n      // Subtract the number of trailing zeros of the last word.\r\n      w = d[w];\r\n      if (w) for (; w % 10 == 0; w /= 10) n--;\r\n      if (n < 0) n = 0;\r\n    }\r\n\r\n    return n;\r\n  };\r\n\r\n\r\n  /*\r\n   *  n / 0 = I\r\n   *  n / N = N\r\n   *  n / I = 0\r\n   *  0 / n = 0\r\n   *  0 / 0 = N\r\n   *  0 / N = N\r\n   *  0 / I = 0\r\n   *  N / n = N\r\n   *  N / 0 = N\r\n   *  N / N = N\r\n   *  N / I = N\r\n   *  I / n = I\r\n   *  I / 0 = I\r\n   *  I / N = N\r\n   *  I / I = N\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal divided by `y`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.dividedBy = P.div = function (y) {\r\n    return divide(this, new this.constructor(y));\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the integer part of dividing the value of this Decimal\r\n   * by the value of `y`, rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.dividedToIntegerBy = P.divToInt = function (y) {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n    return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is equal to the value of `y`, otherwise return false.\r\n   *\r\n   */\r\n  P.equals = P.eq = function (y) {\r\n    return this.cmp(y) === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the\r\n   * direction of negative Infinity.\r\n   *\r\n   */\r\n  P.floor = function () {\r\n    return finalise(new this.constructor(this), this.e + 1, 3);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is greater than the value of `y`, otherwise return\r\n   * false.\r\n   *\r\n   */\r\n  P.greaterThan = P.gt = function (y) {\r\n    return this.cmp(y) > 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is greater than or equal to the value of `y`,\r\n   * otherwise return false.\r\n   *\r\n   */\r\n  P.greaterThanOrEqualTo = P.gte = function (y) {\r\n    var k = this.cmp(y);\r\n    return k == 1 || k === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic cosine of the value in radians of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [1, Infinity]\r\n   *\r\n   * cosh(x) = 1 + x^2/2! + x^4/4! + x^6/6! + ...\r\n   *\r\n   * cosh(0)         = 1\r\n   * cosh(-0)        = 1\r\n   * cosh(Infinity)  = Infinity\r\n   * cosh(-Infinity) = Infinity\r\n   * cosh(NaN)       = NaN\r\n   *\r\n   *  x        time taken (ms)   result\r\n   * 1000      9                 9.8503555700852349694e+433\r\n   * 10000     25                4.4034091128314607936e+4342\r\n   * 100000    171               1.4033316802130615897e+43429\r\n   * 1000000   3817              1.5166076984010437725e+434294\r\n   * 10000000  abandoned after 2 minute wait\r\n   *\r\n   * TODO? Compare performance of cosh(x) = 0.5 * (exp(x) + exp(-x))\r\n   *\r\n   */\r\n  P.hyperbolicCosine = P.cosh = function () {\r\n    var k, n, pr, rm, len,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      one = new Ctor(1);\r\n\r\n    if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);\r\n    if (x.isZero()) return one;\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\r\n    Ctor.rounding = 1;\r\n    len = x.d.length;\r\n\r\n    // Argument reduction: cos(4x) = 1 - 8cos^2(x) + 8cos^4(x) + 1\r\n    // i.e. cos(x) = 1 - cos^2(x/4)(8 - 8cos^2(x/4))\r\n\r\n    // Estimate the optimum number of times to use the argument reduction.\r\n    // TODO? Estimation reused from cosine() and may not be optimal here.\r\n    if (len < 32) {\r\n      k = Math.ceil(len / 3);\r\n      n = (1 / tinyPow(4, k)).toString();\r\n    } else {\r\n      k = 16;\r\n      n = '2.3283064365386962890625e-10';\r\n    }\r\n\r\n    x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);\r\n\r\n    // Reverse argument reduction\r\n    var cosh2_x,\r\n      i = k,\r\n      d8 = new Ctor(8);\r\n    for (; i--;) {\r\n      cosh2_x = x.times(x);\r\n      x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));\r\n    }\r\n\r\n    return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic sine of the value in radians of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * sinh(x) = x + x^3/3! + x^5/5! + x^7/7! + ...\r\n   *\r\n   * sinh(0)         = 0\r\n   * sinh(-0)        = -0\r\n   * sinh(Infinity)  = Infinity\r\n   * sinh(-Infinity) = -Infinity\r\n   * sinh(NaN)       = NaN\r\n   *\r\n   * x        time taken (ms)\r\n   * 10       2 ms\r\n   * 100      5 ms\r\n   * 1000     14 ms\r\n   * 10000    82 ms\r\n   * 100000   886 ms            1.4033316802130615897e+43429\r\n   * 200000   2613 ms\r\n   * 300000   5407 ms\r\n   * 400000   8824 ms\r\n   * 500000   13026 ms          8.7080643612718084129e+217146\r\n   * 1000000  48543 ms\r\n   *\r\n   * TODO? Compare performance of sinh(x) = 0.5 * (exp(x) - exp(-x))\r\n   *\r\n   */\r\n  P.hyperbolicSine = P.sinh = function () {\r\n    var k, pr, rm, len,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite() || x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\r\n    Ctor.rounding = 1;\r\n    len = x.d.length;\r\n\r\n    if (len < 3) {\r\n      x = taylorSeries(Ctor, 2, x, x, true);\r\n    } else {\r\n\r\n      // Alternative argument reduction: sinh(3x) = sinh(x)(3 + 4sinh^2(x))\r\n      // i.e. sinh(x) = sinh(x/3)(3 + 4sinh^2(x/3))\r\n      // 3 multiplications and 1 addition\r\n\r\n      // Argument reduction: sinh(5x) = sinh(x)(5 + sinh^2(x)(20 + 16sinh^2(x)))\r\n      // i.e. sinh(x) = sinh(x/5)(5 + sinh^2(x/5)(20 + 16sinh^2(x/5)))\r\n      // 4 multiplications and 2 additions\r\n\r\n      // Estimate the optimum number of times to use the argument reduction.\r\n      k = 1.4 * Math.sqrt(len);\r\n      k = k > 16 ? 16 : k | 0;\r\n\r\n      x = x.times(1 / tinyPow(5, k));\r\n      x = taylorSeries(Ctor, 2, x, x, true);\r\n\r\n      // Reverse argument reduction\r\n      var sinh2_x,\r\n        d5 = new Ctor(5),\r\n        d16 = new Ctor(16),\r\n        d20 = new Ctor(20);\r\n      for (; k--;) {\r\n        sinh2_x = x.times(x);\r\n        x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));\r\n      }\r\n    }\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(x, pr, rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic tangent of the value in radians of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-1, 1]\r\n   *\r\n   * tanh(x) = sinh(x) / cosh(x)\r\n   *\r\n   * tanh(0)         = 0\r\n   * tanh(-0)        = -0\r\n   * tanh(Infinity)  = 1\r\n   * tanh(-Infinity) = -1\r\n   * tanh(NaN)       = NaN\r\n   *\r\n   */\r\n  P.hyperbolicTangent = P.tanh = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite()) return new Ctor(x.s);\r\n    if (x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + 7;\r\n    Ctor.rounding = 1;\r\n\r\n    return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arccosine (inverse cosine) in radians of the value of\r\n   * this Decimal.\r\n   *\r\n   * Domain: [-1, 1]\r\n   * Range: [0, pi]\r\n   *\r\n   * acos(x) = pi/2 - asin(x)\r\n   *\r\n   * acos(0)       = pi/2\r\n   * acos(-0)      = pi/2\r\n   * acos(1)       = 0\r\n   * acos(-1)      = pi\r\n   * acos(1/2)     = pi/3\r\n   * acos(-1/2)    = 2*pi/3\r\n   * acos(|x| > 1) = NaN\r\n   * acos(NaN)     = NaN\r\n   *\r\n   */\r\n  P.inverseCosine = P.acos = function () {\r\n    var halfPi,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      k = x.abs().cmp(1),\r\n      pr = Ctor.precision,\r\n      rm = Ctor.rounding;\r\n\r\n    if (k !== -1) {\r\n      return k === 0\r\n        // |x| is 1\r\n        ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0)\r\n        // |x| > 1 or x is NaN\r\n        : new Ctor(NaN);\r\n    }\r\n\r\n    if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);\r\n\r\n    // TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3\r\n\r\n    Ctor.precision = pr + 6;\r\n    Ctor.rounding = 1;\r\n\r\n    x = x.asin();\r\n    halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return halfPi.minus(x);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic cosine in radians of the\r\n   * value of this Decimal.\r\n   *\r\n   * Domain: [1, Infinity]\r\n   * Range: [0, Infinity]\r\n   *\r\n   * acosh(x) = ln(x + sqrt(x^2 - 1))\r\n   *\r\n   * acosh(x < 1)     = NaN\r\n   * acosh(NaN)       = NaN\r\n   * acosh(Infinity)  = Infinity\r\n   * acosh(-Infinity) = NaN\r\n   * acosh(0)         = NaN\r\n   * acosh(-0)        = NaN\r\n   * acosh(1)         = 0\r\n   * acosh(-1)        = NaN\r\n   *\r\n   */\r\n  P.inverseHyperbolicCosine = P.acosh = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);\r\n    if (!x.isFinite()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;\r\n    Ctor.rounding = 1;\r\n    external = false;\r\n\r\n    x = x.times(x).minus(1).sqrt().plus(x);\r\n\r\n    external = true;\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return x.ln();\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic sine in radians of the value\r\n   * of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * asinh(x) = ln(x + sqrt(x^2 + 1))\r\n   *\r\n   * asinh(NaN)       = NaN\r\n   * asinh(Infinity)  = Infinity\r\n   * asinh(-Infinity) = -Infinity\r\n   * asinh(0)         = 0\r\n   * asinh(-0)        = -0\r\n   *\r\n   */\r\n  P.inverseHyperbolicSine = P.asinh = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite() || x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;\r\n    Ctor.rounding = 1;\r\n    external = false;\r\n\r\n    x = x.times(x).plus(1).sqrt().plus(x);\r\n\r\n    external = true;\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return x.ln();\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic tangent in radians of the\r\n   * value of this Decimal.\r\n   *\r\n   * Domain: [-1, 1]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * atanh(x) = 0.5 * ln((1 + x) / (1 - x))\r\n   *\r\n   * atanh(|x| > 1)   = NaN\r\n   * atanh(NaN)       = NaN\r\n   * atanh(Infinity)  = NaN\r\n   * atanh(-Infinity) = NaN\r\n   * atanh(0)         = 0\r\n   * atanh(-0)        = -0\r\n   * atanh(1)         = Infinity\r\n   * atanh(-1)        = -Infinity\r\n   *\r\n   */\r\n  P.inverseHyperbolicTangent = P.atanh = function () {\r\n    var pr, rm, wpr, xsd,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite()) return new Ctor(NaN);\r\n    if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    xsd = x.sd();\r\n\r\n    if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);\r\n\r\n    Ctor.precision = wpr = xsd - x.e;\r\n\r\n    x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);\r\n\r\n    Ctor.precision = pr + 4;\r\n    Ctor.rounding = 1;\r\n\r\n    x = x.ln();\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return x.times(0.5);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arcsine (inverse sine) in radians of the value of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-pi/2, pi/2]\r\n   *\r\n   * asin(x) = 2*atan(x/(1 + sqrt(1 - x^2)))\r\n   *\r\n   * asin(0)       = 0\r\n   * asin(-0)      = -0\r\n   * asin(1/2)     = pi/6\r\n   * asin(-1/2)    = -pi/6\r\n   * asin(1)       = pi/2\r\n   * asin(-1)      = -pi/2\r\n   * asin(|x| > 1) = NaN\r\n   * asin(NaN)     = NaN\r\n   *\r\n   * TODO? Compare performance of Taylor series.\r\n   *\r\n   */\r\n  P.inverseSine = P.asin = function () {\r\n    var halfPi, k,\r\n      pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (x.isZero()) return new Ctor(x);\r\n\r\n    k = x.abs().cmp(1);\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n\r\n    if (k !== -1) {\r\n\r\n      // |x| is 1\r\n      if (k === 0) {\r\n        halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\r\n        halfPi.s = x.s;\r\n        return halfPi;\r\n      }\r\n\r\n      // |x| > 1 or x is NaN\r\n      return new Ctor(NaN);\r\n    }\r\n\r\n    // TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6\r\n\r\n    Ctor.precision = pr + 6;\r\n    Ctor.rounding = 1;\r\n\r\n    x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return x.times(2);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arctangent (inverse tangent) in radians of the value\r\n   * of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-pi/2, pi/2]\r\n   *\r\n   * atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...\r\n   *\r\n   * atan(0)         = 0\r\n   * atan(-0)        = -0\r\n   * atan(1)         = pi/4\r\n   * atan(-1)        = -pi/4\r\n   * atan(Infinity)  = pi/2\r\n   * atan(-Infinity) = -pi/2\r\n   * atan(NaN)       = NaN\r\n   *\r\n   */\r\n  P.inverseTangent = P.atan = function () {\r\n    var i, j, k, n, px, t, r, wpr, x2,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      pr = Ctor.precision,\r\n      rm = Ctor.rounding;\r\n\r\n    if (!x.isFinite()) {\r\n      if (!x.s) return new Ctor(NaN);\r\n      if (pr + 4 <= PI_PRECISION) {\r\n        r = getPi(Ctor, pr + 4, rm).times(0.5);\r\n        r.s = x.s;\r\n        return r;\r\n      }\r\n    } else if (x.isZero()) {\r\n      return new Ctor(x);\r\n    } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {\r\n      r = getPi(Ctor, pr + 4, rm).times(0.25);\r\n      r.s = x.s;\r\n      return r;\r\n    }\r\n\r\n    Ctor.precision = wpr = pr + 10;\r\n    Ctor.rounding = 1;\r\n\r\n    // TODO? if (x >= 1 && pr <= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);\r\n\r\n    // Argument reduction\r\n    // Ensure |x| < 0.42\r\n    // atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))\r\n\r\n    k = Math.min(28, wpr / LOG_BASE + 2 | 0);\r\n\r\n    for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));\r\n\r\n    external = false;\r\n\r\n    j = Math.ceil(wpr / LOG_BASE);\r\n    n = 1;\r\n    x2 = x.times(x);\r\n    r = new Ctor(x);\r\n    px = x;\r\n\r\n    // atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...\r\n    for (; i !== -1;) {\r\n      px = px.times(x2);\r\n      t = r.minus(px.div(n += 2));\r\n\r\n      px = px.times(x2);\r\n      r = t.plus(px.div(n += 2));\r\n\r\n      if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] && i--;);\r\n    }\r\n\r\n    if (k) r = r.times(2 << (k - 1));\r\n\r\n    external = true;\r\n\r\n    return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is a finite number, otherwise return false.\r\n   *\r\n   */\r\n  P.isFinite = function () {\r\n    return !!this.d;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is an integer, otherwise return false.\r\n   *\r\n   */\r\n  P.isInteger = P.isInt = function () {\r\n    return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is NaN, otherwise return false.\r\n   *\r\n   */\r\n  P.isNaN = function () {\r\n    return !this.s;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is negative, otherwise return false.\r\n   *\r\n   */\r\n  P.isNegative = P.isNeg = function () {\r\n    return this.s < 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is positive, otherwise return false.\r\n   *\r\n   */\r\n  P.isPositive = P.isPos = function () {\r\n    return this.s > 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is 0 or -0, otherwise return false.\r\n   *\r\n   */\r\n  P.isZero = function () {\r\n    return !!this.d && this.d[0] === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is less than `y`, otherwise return false.\r\n   *\r\n   */\r\n  P.lessThan = P.lt = function (y) {\r\n    return this.cmp(y) < 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is less than or equal to `y`, otherwise return false.\r\n   *\r\n   */\r\n  P.lessThanOrEqualTo = P.lte = function (y) {\r\n    return this.cmp(y) < 1;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the logarithm of the value of this Decimal to the specified base, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * If no base is specified, return log[10](arg).\r\n   *\r\n   * log[base](arg) = ln(arg) / ln(base)\r\n   *\r\n   * The result will always be correctly rounded if the base of the log is 10, and 'almost always'\r\n   * otherwise:\r\n   *\r\n   * Depending on the rounding mode, the result may be incorrectly rounded if the first fifteen\r\n   * rounding digits are [49]99999999999999 or [50]00000000000000. In that case, the maximum error\r\n   * between the result and the correctly rounded result will be one ulp (unit in the last place).\r\n   *\r\n   * log[-b](a)       = NaN\r\n   * log[0](a)        = NaN\r\n   * log[1](a)        = NaN\r\n   * log[NaN](a)      = NaN\r\n   * log[Infinity](a) = NaN\r\n   * log[b](0)        = -Infinity\r\n   * log[b](-0)       = -Infinity\r\n   * log[b](-a)       = NaN\r\n   * log[b](1)        = 0\r\n   * log[b](Infinity) = Infinity\r\n   * log[b](NaN)      = NaN\r\n   *\r\n   * [base] {number|string|Decimal} The base of the logarithm.\r\n   *\r\n   */\r\n  P.logarithm = P.log = function (base) {\r\n    var isBase10, d, denominator, k, inf, num, sd, r,\r\n      arg = this,\r\n      Ctor = arg.constructor,\r\n      pr = Ctor.precision,\r\n      rm = Ctor.rounding,\r\n      guard = 5;\r\n\r\n    // Default base is 10.\r\n    if (base == null) {\r\n      base = new Ctor(10);\r\n      isBase10 = true;\r\n    } else {\r\n      base = new Ctor(base);\r\n      d = base.d;\r\n\r\n      // Return NaN if base is negative, or non-finite, or is 0 or 1.\r\n      if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);\r\n\r\n      isBase10 = base.eq(10);\r\n    }\r\n\r\n    d = arg.d;\r\n\r\n    // Is arg negative, non-finite, 0 or 1?\r\n    if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {\r\n      return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);\r\n    }\r\n\r\n    // The result will have a non-terminating decimal expansion if base is 10 and arg is not an\r\n    // integer power of 10.\r\n    if (isBase10) {\r\n      if (d.length > 1) {\r\n        inf = true;\r\n      } else {\r\n        for (k = d[0]; k % 10 === 0;) k /= 10;\r\n        inf = k !== 1;\r\n      }\r\n    }\r\n\r\n    external = false;\r\n    sd = pr + guard;\r\n    num = naturalLogarithm(arg, sd);\r\n    denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\r\n\r\n    // The result will have 5 rounding digits.\r\n    r = divide(num, denominator, sd, 1);\r\n\r\n    // If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,\r\n    // calculate 10 further digits.\r\n    //\r\n    // If the result is known to have an infinite decimal expansion, repeat this until it is clear\r\n    // that the result is above or below the boundary. Otherwise, if after calculating the 10\r\n    // further digits, the last 14 are nines, round up and assume the result is exact.\r\n    // Also assume the result is exact if the last 14 are zero.\r\n    //\r\n    // Example of a result that will be incorrectly rounded:\r\n    // log[1048576](4503599627370502) = 2.60000000000000009610279511444746...\r\n    // The above result correctly rounded using ROUND_CEIL to 1 decimal place should be 2.7, but it\r\n    // will be given as 2.6 as there are 15 zeros immediately after the requested decimal place, so\r\n    // the exact result would be assumed to be 2.6, which rounded using ROUND_CEIL to 1 decimal\r\n    // place is still 2.6.\r\n    if (checkRoundingDigits(r.d, k = pr, rm)) {\r\n\r\n      do {\r\n        sd += 10;\r\n        num = naturalLogarithm(arg, sd);\r\n        denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\r\n        r = divide(num, denominator, sd, 1);\r\n\r\n        if (!inf) {\r\n\r\n          // Check for 14 nines from the 2nd rounding digit, as the first may be 4.\r\n          if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {\r\n            r = finalise(r, pr + 1, 0);\r\n          }\r\n\r\n          break;\r\n        }\r\n      } while (checkRoundingDigits(r.d, k += 10, rm));\r\n    }\r\n\r\n    external = true;\r\n\r\n    return finalise(r, pr, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the maximum of the arguments and the value of this Decimal.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n  P.max = function () {\r\n    Array.prototype.push.call(arguments, this);\r\n    return maxOrMin(this.constructor, arguments, 'lt');\r\n  };\r\n   */\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the minimum of the arguments and the value of this Decimal.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n  P.min = function () {\r\n    Array.prototype.push.call(arguments, this);\r\n    return maxOrMin(this.constructor, arguments, 'gt');\r\n  };\r\n   */\r\n\r\n\r\n  /*\r\n   *  n - 0 = n\r\n   *  n - N = N\r\n   *  n - I = -I\r\n   *  0 - n = -n\r\n   *  0 - 0 = 0\r\n   *  0 - N = N\r\n   *  0 - I = -I\r\n   *  N - n = N\r\n   *  N - 0 = N\r\n   *  N - N = N\r\n   *  N - I = N\r\n   *  I - n = I\r\n   *  I - 0 = I\r\n   *  I - N = N\r\n   *  I - I = N\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal minus `y`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.minus = P.sub = function (y) {\r\n    var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    y = new Ctor(y);\r\n\r\n    // If either is not finite...\r\n    if (!x.d || !y.d) {\r\n\r\n      // Return NaN if either is NaN.\r\n      if (!x.s || !y.s) y = new Ctor(NaN);\r\n\r\n      // Return y negated if x is finite and y is Infinity.\r\n      else if (x.d) y.s = -y.s;\r\n\r\n      // Return x if y is finite and x is Infinity.\r\n      // Return x if both are Infinity with different signs.\r\n      // Return NaN if both are Infinity with the same sign.\r\n      else y = new Ctor(y.d || x.s !== y.s ? x : NaN);\r\n\r\n      return y;\r\n    }\r\n\r\n    // If signs differ...\r\n    if (x.s != y.s) {\r\n      y.s = -y.s;\r\n      return x.plus(y);\r\n    }\r\n\r\n    xd = x.d;\r\n    yd = y.d;\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n\r\n    // If either is zero...\r\n    if (!xd[0] || !yd[0]) {\r\n\r\n      // Return y negated if x is zero and y is non-zero.\r\n      if (yd[0]) y.s = -y.s;\r\n\r\n      // Return x if y is zero and x is non-zero.\r\n      else if (xd[0]) y = new Ctor(x);\r\n\r\n      // Return zero if both are zero.\r\n      // From IEEE 754 (2008) 6.3: 0 - 0 = -0 - -0 = -0 when rounding to -Infinity.\r\n      else return new Ctor(rm === 3 ? -0 : 0);\r\n\r\n      return external ? finalise(y, pr, rm) : y;\r\n    }\r\n\r\n    // x and y are finite, non-zero numbers with the same sign.\r\n\r\n    // Calculate base 1e7 exponents.\r\n    e = mathfloor(y.e / LOG_BASE);\r\n    xe = mathfloor(x.e / LOG_BASE);\r\n\r\n    xd = xd.slice();\r\n    k = xe - e;\r\n\r\n    // If base 1e7 exponents differ...\r\n    if (k) {\r\n      xLTy = k < 0;\r\n\r\n      if (xLTy) {\r\n        d = xd;\r\n        k = -k;\r\n        len = yd.length;\r\n      } else {\r\n        d = yd;\r\n        e = xe;\r\n        len = xd.length;\r\n      }\r\n\r\n      // Numbers with massively different exponents would result in a very high number of\r\n      // zeros needing to be prepended, but this can be avoided while still ensuring correct\r\n      // rounding by limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.\r\n      i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;\r\n\r\n      if (k > i) {\r\n        k = i;\r\n        d.length = 1;\r\n      }\r\n\r\n      // Prepend zeros to equalise exponents.\r\n      d.reverse();\r\n      for (i = k; i--;) d.push(0);\r\n      d.reverse();\r\n\r\n    // Base 1e7 exponents equal.\r\n    } else {\r\n\r\n      // Check digits to determine which is the bigger number.\r\n\r\n      i = xd.length;\r\n      len = yd.length;\r\n      xLTy = i < len;\r\n      if (xLTy) len = i;\r\n\r\n      for (i = 0; i < len; i++) {\r\n        if (xd[i] != yd[i]) {\r\n          xLTy = xd[i] < yd[i];\r\n          break;\r\n        }\r\n      }\r\n\r\n      k = 0;\r\n    }\r\n\r\n    if (xLTy) {\r\n      d = xd;\r\n      xd = yd;\r\n      yd = d;\r\n      y.s = -y.s;\r\n    }\r\n\r\n    len = xd.length;\r\n\r\n    // Append zeros to `xd` if shorter.\r\n    // Don't add zeros to `yd` if shorter as subtraction only needs to start at `yd` length.\r\n    for (i = yd.length - len; i > 0; --i) xd[len++] = 0;\r\n\r\n    // Subtract yd from xd.\r\n    for (i = yd.length; i > k;) {\r\n\r\n      if (xd[--i] < yd[i]) {\r\n        for (j = i; j && xd[--j] === 0;) xd[j] = BASE - 1;\r\n        --xd[j];\r\n        xd[i] += BASE;\r\n      }\r\n\r\n      xd[i] -= yd[i];\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    for (; xd[--len] === 0;) xd.pop();\r\n\r\n    // Remove leading zeros and adjust exponent accordingly.\r\n    for (; xd[0] === 0; xd.shift()) --e;\r\n\r\n    // Zero?\r\n    if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);\r\n\r\n    y.d = xd;\r\n    y.e = getBase10Exponent(xd, e);\r\n\r\n    return external ? finalise(y, pr, rm) : y;\r\n  };\r\n\r\n\r\n  /*\r\n   *   n % 0 =  N\r\n   *   n % N =  N\r\n   *   n % I =  n\r\n   *   0 % n =  0\r\n   *  -0 % n = -0\r\n   *   0 % 0 =  N\r\n   *   0 % N =  N\r\n   *   0 % I =  0\r\n   *   N % n =  N\r\n   *   N % 0 =  N\r\n   *   N % N =  N\r\n   *   N % I =  N\r\n   *   I % n =  N\r\n   *   I % 0 =  N\r\n   *   I % N =  N\r\n   *   I % I =  N\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal modulo `y`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * The result depends on the modulo mode.\r\n   *\r\n   */\r\n  P.modulo = P.mod = function (y) {\r\n    var q,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    y = new Ctor(y);\r\n\r\n    // Return NaN if x is Infinity or NaN, or y is NaN or 0.\r\n    if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);\r\n\r\n    // Return x if y is Infinity or x is 0.\r\n    if (!y.d || x.d && !x.d[0]) {\r\n      return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);\r\n    }\r\n\r\n    // Prevent rounding of intermediate calculations.\r\n    external = false;\r\n\r\n    if (Ctor.modulo == 9) {\r\n\r\n      // Euclidian division: q = sign(y) * floor(x / abs(y))\r\n      // result = x - q * y    where  0 <= result < abs(y)\r\n      q = divide(x, y.abs(), 0, 3, 1);\r\n      q.s *= y.s;\r\n    } else {\r\n      q = divide(x, y, 0, Ctor.modulo, 1);\r\n    }\r\n\r\n    q = q.times(y);\r\n\r\n    external = true;\r\n\r\n    return x.minus(q);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural exponential of the value of this Decimal,\r\n   * i.e. the base e raised to the power the value of this Decimal, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.naturalExponential = P.exp = function () {\r\n    return naturalExponential(this);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural logarithm of the value of this Decimal,\r\n   * rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.naturalLogarithm = P.ln = function () {\r\n    return naturalLogarithm(this);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if multiplied by\r\n   * -1.\r\n   *\r\n   */\r\n  P.negated = P.neg = function () {\r\n    var x = new this.constructor(this);\r\n    x.s = -x.s;\r\n    return finalise(x);\r\n  };\r\n\r\n\r\n  /*\r\n   *  n + 0 = n\r\n   *  n + N = N\r\n   *  n + I = I\r\n   *  0 + n = n\r\n   *  0 + 0 = 0\r\n   *  0 + N = N\r\n   *  0 + I = I\r\n   *  N + n = N\r\n   *  N + 0 = N\r\n   *  N + N = N\r\n   *  N + I = N\r\n   *  I + n = I\r\n   *  I + 0 = I\r\n   *  I + N = N\r\n   *  I + I = I\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal plus `y`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.plus = P.add = function (y) {\r\n    var carry, d, e, i, k, len, pr, rm, xd, yd,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    y = new Ctor(y);\r\n\r\n    // If either is not finite...\r\n    if (!x.d || !y.d) {\r\n\r\n      // Return NaN if either is NaN.\r\n      if (!x.s || !y.s) y = new Ctor(NaN);\r\n\r\n      // Return x if y is finite and x is Infinity.\r\n      // Return x if both are Infinity with the same sign.\r\n      // Return NaN if both are Infinity with different signs.\r\n      // Return y if x is finite and y is Infinity.\r\n      else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);\r\n\r\n      return y;\r\n    }\r\n\r\n     // If signs differ...\r\n    if (x.s != y.s) {\r\n      y.s = -y.s;\r\n      return x.minus(y);\r\n    }\r\n\r\n    xd = x.d;\r\n    yd = y.d;\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n\r\n    // If either is zero...\r\n    if (!xd[0] || !yd[0]) {\r\n\r\n      // Return x if y is zero.\r\n      // Return y if y is non-zero.\r\n      if (!yd[0]) y = new Ctor(x);\r\n\r\n      return external ? finalise(y, pr, rm) : y;\r\n    }\r\n\r\n    // x and y are finite, non-zero numbers with the same sign.\r\n\r\n    // Calculate base 1e7 exponents.\r\n    k = mathfloor(x.e / LOG_BASE);\r\n    e = mathfloor(y.e / LOG_BASE);\r\n\r\n    xd = xd.slice();\r\n    i = k - e;\r\n\r\n    // If base 1e7 exponents differ...\r\n    if (i) {\r\n\r\n      if (i < 0) {\r\n        d = xd;\r\n        i = -i;\r\n        len = yd.length;\r\n      } else {\r\n        d = yd;\r\n        e = k;\r\n        len = xd.length;\r\n      }\r\n\r\n      // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.\r\n      k = Math.ceil(pr / LOG_BASE);\r\n      len = k > len ? k + 1 : len + 1;\r\n\r\n      if (i > len) {\r\n        i = len;\r\n        d.length = 1;\r\n      }\r\n\r\n      // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.\r\n      d.reverse();\r\n      for (; i--;) d.push(0);\r\n      d.reverse();\r\n    }\r\n\r\n    len = xd.length;\r\n    i = yd.length;\r\n\r\n    // If yd is longer than xd, swap xd and yd so xd points to the longer array.\r\n    if (len - i < 0) {\r\n      i = len;\r\n      d = yd;\r\n      yd = xd;\r\n      xd = d;\r\n    }\r\n\r\n    // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.\r\n    for (carry = 0; i;) {\r\n      carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;\r\n      xd[i] %= BASE;\r\n    }\r\n\r\n    if (carry) {\r\n      xd.unshift(carry);\r\n      ++e;\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    // No need to check for zero, as +x + +y != 0 && -x + -y != 0\r\n    for (len = xd.length; xd[--len] == 0;) xd.pop();\r\n\r\n    y.d = xd;\r\n    y.e = getBase10Exponent(xd, e);\r\n\r\n    return external ? finalise(y, pr, rm) : y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the number of significant digits of the value of this Decimal.\r\n   *\r\n   * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.\r\n   *\r\n   */\r\n  P.precision = P.sd = function (z) {\r\n    var k,\r\n      x = this;\r\n\r\n    if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);\r\n\r\n    if (x.d) {\r\n      k = getPrecision(x.d);\r\n      if (z && x.e + 1 > k) k = x.e + 1;\r\n    } else {\r\n      k = NaN;\r\n    }\r\n\r\n    return k;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using\r\n   * rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.round = function () {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n\r\n    return finalise(new Ctor(x), x.e + 1, Ctor.rounding);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the sine of the value in radians of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-1, 1]\r\n   *\r\n   * sin(x) = x - x^3/3! + x^5/5! - ...\r\n   *\r\n   * sin(0)         = 0\r\n   * sin(-0)        = -0\r\n   * sin(Infinity)  = NaN\r\n   * sin(-Infinity) = NaN\r\n   * sin(NaN)       = NaN\r\n   *\r\n   */\r\n  P.sine = P.sin = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite()) return new Ctor(NaN);\r\n    if (x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\r\n    Ctor.rounding = 1;\r\n\r\n    x = sine(Ctor, toLessThanHalfPi(Ctor, x));\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the square root of this Decimal, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   *  sqrt(-n) =  N\r\n   *  sqrt(N)  =  N\r\n   *  sqrt(-I) =  N\r\n   *  sqrt(I)  =  I\r\n   *  sqrt(0)  =  0\r\n   *  sqrt(-0) = -0\r\n   *\r\n   */\r\n  P.squareRoot = P.sqrt = function () {\r\n    var m, n, sd, r, rep, t,\r\n      x = this,\r\n      d = x.d,\r\n      e = x.e,\r\n      s = x.s,\r\n      Ctor = x.constructor;\r\n\r\n    // Negative/NaN/Infinity/zero?\r\n    if (s !== 1 || !d || !d[0]) {\r\n      return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);\r\n    }\r\n\r\n    external = false;\r\n\r\n    // Initial estimate.\r\n    s = Math.sqrt(+x);\r\n\r\n    // Math.sqrt underflow/overflow?\r\n    // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\r\n    if (s == 0 || s == 1 / 0) {\r\n      n = digitsToString(d);\r\n\r\n      if ((n.length + e) % 2 == 0) n += '0';\r\n      s = Math.sqrt(n);\r\n      e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);\r\n\r\n      if (s == 1 / 0) {\r\n        n = '5e' + e;\r\n      } else {\r\n        n = s.toExponential();\r\n        n = n.slice(0, n.indexOf('e') + 1) + e;\r\n      }\r\n\r\n      r = new Ctor(n);\r\n    } else {\r\n      r = new Ctor(s.toString());\r\n    }\r\n\r\n    sd = (e = Ctor.precision) + 3;\r\n\r\n    // Newton-Raphson iteration.\r\n    for (;;) {\r\n      t = r;\r\n      r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);\r\n\r\n      // TODO? Replace with for-loop and checkRoundingDigits.\r\n      if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\r\n        n = n.slice(sd - 3, sd + 1);\r\n\r\n        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or\r\n        // 4999, i.e. approaching a rounding boundary, continue the iteration.\r\n        if (n == '9999' || !rep && n == '4999') {\r\n\r\n          // On the first iteration only, check to see if rounding up gives the exact result as the\r\n          // nines may infinitely repeat.\r\n          if (!rep) {\r\n            finalise(t, e + 1, 0);\r\n\r\n            if (t.times(t).eq(x)) {\r\n              r = t;\r\n              break;\r\n            }\r\n          }\r\n\r\n          sd += 4;\r\n          rep = 1;\r\n        } else {\r\n\r\n          // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.\r\n          // If not, then there are further digits and m will be truthy.\r\n          if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n            // Truncate to the first rounding digit.\r\n            finalise(r, e + 1, 1);\r\n            m = !r.times(r).eq(x);\r\n          }\r\n\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    external = true;\r\n\r\n    return finalise(r, e, Ctor.rounding, m);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the tangent of the value in radians of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * tan(0)         = 0\r\n   * tan(-0)        = -0\r\n   * tan(Infinity)  = NaN\r\n   * tan(-Infinity) = NaN\r\n   * tan(NaN)       = NaN\r\n   *\r\n   */\r\n  P.tangent = P.tan = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite()) return new Ctor(NaN);\r\n    if (x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + 10;\r\n    Ctor.rounding = 1;\r\n\r\n    x = x.sin();\r\n    x.s = 1;\r\n    x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   *  n * 0 = 0\r\n   *  n * N = N\r\n   *  n * I = I\r\n   *  0 * n = 0\r\n   *  0 * 0 = 0\r\n   *  0 * N = N\r\n   *  0 * I = N\r\n   *  N * n = N\r\n   *  N * 0 = N\r\n   *  N * N = N\r\n   *  N * I = N\r\n   *  I * n = I\r\n   *  I * 0 = N\r\n   *  I * N = N\r\n   *  I * I = I\r\n   *\r\n   * Return a new Decimal whose value is this Decimal times `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.times = P.mul = function (y) {\r\n    var carry, e, i, k, r, rL, t, xdL, ydL,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      xd = x.d,\r\n      yd = (y = new Ctor(y)).d;\r\n\r\n    y.s *= x.s;\r\n\r\n     // If either is NaN, Infinity or 0...\r\n    if (!xd || !xd[0] || !yd || !yd[0]) {\r\n\r\n      return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd\r\n\r\n        // Return NaN if either is NaN.\r\n        // Return NaN if x is 0 and y is Infinity, or y is 0 and x is Infinity.\r\n        ? NaN\r\n\r\n        // Return Infinity if either is Infinity.\r\n        // Return 0 if either is 0.\r\n        : !xd || !yd ? y.s / 0 : y.s * 0);\r\n    }\r\n\r\n    e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);\r\n    xdL = xd.length;\r\n    ydL = yd.length;\r\n\r\n    // Ensure xd points to the longer array.\r\n    if (xdL < ydL) {\r\n      r = xd;\r\n      xd = yd;\r\n      yd = r;\r\n      rL = xdL;\r\n      xdL = ydL;\r\n      ydL = rL;\r\n    }\r\n\r\n    // Initialise the result array with zeros.\r\n    r = [];\r\n    rL = xdL + ydL;\r\n    for (i = rL; i--;) r.push(0);\r\n\r\n    // Multiply!\r\n    for (i = ydL; --i >= 0;) {\r\n      carry = 0;\r\n      for (k = xdL + i; k > i;) {\r\n        t = r[k] + yd[i] * xd[k - i - 1] + carry;\r\n        r[k--] = t % BASE | 0;\r\n        carry = t / BASE | 0;\r\n      }\r\n\r\n      r[k] = (r[k] + carry) % BASE | 0;\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    for (; !r[--rL];) r.pop();\r\n\r\n    if (carry) ++e;\r\n    else r.shift();\r\n\r\n    y.d = r;\r\n    y.e = getBase10Exponent(r, e);\r\n\r\n    return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in base 2, round to `sd` significant\r\n   * digits using rounding mode `rm`.\r\n   *\r\n   * If the optional `sd` argument is present then return binary exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toBinary = function (sd, rm) {\r\n    return toStringBinary(this, 2, sd, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `dp`\r\n   * decimal places using rounding mode `rm` or `rounding` if `rm` is omitted.\r\n   *\r\n   * If `dp` is omitted, return a new Decimal whose value is the value of this Decimal.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toDecimalPlaces = P.toDP = function (dp, rm) {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n\r\n    x = new Ctor(x);\r\n    if (dp === void 0) return x;\r\n\r\n    checkInt32(dp, 0, MAX_DIGITS);\r\n\r\n    if (rm === void 0) rm = Ctor.rounding;\r\n    else checkInt32(rm, 0, 8);\r\n\r\n    return finalise(x, dp + x.e + 1, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in exponential notation rounded to\r\n   * `dp` fixed decimal places using rounding mode `rounding`.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toExponential = function (dp, rm) {\r\n    var str,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (dp === void 0) {\r\n      str = finiteToString(x, true);\r\n    } else {\r\n      checkInt32(dp, 0, MAX_DIGITS);\r\n\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n\r\n      x = finalise(new Ctor(x), dp + 1, rm);\r\n      str = finiteToString(x, true, dp + 1);\r\n    }\r\n\r\n    return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in normal (fixed-point) notation to\r\n   * `dp` fixed decimal places and rounded using rounding mode `rm` or `rounding` if `rm` is\r\n   * omitted.\r\n   *\r\n   * As with JavaScript numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.\r\n   * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.\r\n   * (-0).toFixed(3) is '0.000'.\r\n   * (-0.5).toFixed(0) is '-0'.\r\n   *\r\n   */\r\n  P.toFixed = function (dp, rm) {\r\n    var str, y,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (dp === void 0) {\r\n      str = finiteToString(x);\r\n    } else {\r\n      checkInt32(dp, 0, MAX_DIGITS);\r\n\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n\r\n      y = finalise(new Ctor(x), dp + x.e + 1, rm);\r\n      str = finiteToString(y, false, dp + y.e + 1);\r\n    }\r\n\r\n    // To determine whether to add the minus sign look at the value before it was rounded,\r\n    // i.e. look at `x` rather than `y`.\r\n    return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return an array representing the value of this Decimal as a simple fraction with an integer\r\n   * numerator and an integer denominator.\r\n   *\r\n   * The denominator will be a positive non-zero value less than or equal to the specified maximum\r\n   * denominator. If a maximum denominator is not specified, the denominator will be the lowest\r\n   * value necessary to represent the number exactly.\r\n   *\r\n   * [maxD] {number|string|Decimal} Maximum denominator. Integer >= 1 and < Infinity.\r\n   *\r\n   */\r\n  P.toFraction = function (maxD) {\r\n    var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r,\r\n      x = this,\r\n      xd = x.d,\r\n      Ctor = x.constructor;\r\n\r\n    if (!xd) return new Ctor(x);\r\n\r\n    n1 = d0 = new Ctor(1);\r\n    d1 = n0 = new Ctor(0);\r\n\r\n    d = new Ctor(d1);\r\n    e = d.e = getPrecision(xd) - x.e - 1;\r\n    k = e % LOG_BASE;\r\n    d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);\r\n\r\n    if (maxD == null) {\r\n\r\n      // d is 10**e, the minimum max-denominator needed.\r\n      maxD = e > 0 ? d : n1;\r\n    } else {\r\n      n = new Ctor(maxD);\r\n      if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);\r\n      maxD = n.gt(d) ? (e > 0 ? d : n1) : n;\r\n    }\r\n\r\n    external = false;\r\n    n = new Ctor(digitsToString(xd));\r\n    pr = Ctor.precision;\r\n    Ctor.precision = e = xd.length * LOG_BASE * 2;\r\n\r\n    for (;;)  {\r\n      q = divide(n, d, 0, 1, 1);\r\n      d2 = d0.plus(q.times(d1));\r\n      if (d2.cmp(maxD) == 1) break;\r\n      d0 = d1;\r\n      d1 = d2;\r\n      d2 = n1;\r\n      n1 = n0.plus(q.times(d2));\r\n      n0 = d2;\r\n      d2 = d;\r\n      d = n.minus(q.times(d2));\r\n      n = d2;\r\n    }\r\n\r\n    d2 = divide(maxD.minus(d0), d1, 0, 1, 1);\r\n    n0 = n0.plus(d2.times(n1));\r\n    d0 = d0.plus(d2.times(d1));\r\n    n0.s = n1.s = x.s;\r\n\r\n    // Determine which fraction is closer to x, n0/d0 or n1/d1?\r\n    r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1\r\n        ? [n1, d1] : [n0, d0];\r\n\r\n    Ctor.precision = pr;\r\n    external = true;\r\n\r\n    return r;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in base 16, round to `sd` significant\r\n   * digits using rounding mode `rm`.\r\n   *\r\n   * If the optional `sd` argument is present then return binary exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toHexadecimal = P.toHex = function (sd, rm) {\r\n    return toStringBinary(this, 16, sd, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Returns a new Decimal whose value is the nearest multiple of `y` in the direction of rounding\r\n   * mode `rm`, or `Decimal.rounding` if `rm` is omitted, to the value of this Decimal.\r\n   *\r\n   * The return value will always have the same sign as this Decimal, unless either this Decimal\r\n   * or `y` is NaN, in which case the return value will be also be NaN.\r\n   *\r\n   * The return value is not affected by the value of `precision`.\r\n   *\r\n   * y {number|string|Decimal} The magnitude to round to a multiple of.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * 'toNearest() rounding mode not an integer: {rm}'\r\n   * 'toNearest() rounding mode out of range: {rm}'\r\n   *\r\n   */\r\n  P.toNearest = function (y, rm) {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n\r\n    x = new Ctor(x);\r\n\r\n    if (y == null) {\r\n\r\n      // If x is not finite, return x.\r\n      if (!x.d) return x;\r\n\r\n      y = new Ctor(1);\r\n      rm = Ctor.rounding;\r\n    } else {\r\n      y = new Ctor(y);\r\n      if (rm === void 0) {\r\n        rm = Ctor.rounding;\r\n      } else {\r\n        checkInt32(rm, 0, 8);\r\n      }\r\n\r\n      // If x is not finite, return x if y is not NaN, else NaN.\r\n      if (!x.d) return y.s ? x : y;\r\n\r\n      // If y is not finite, return Infinity with the sign of x if y is Infinity, else NaN.\r\n      if (!y.d) {\r\n        if (y.s) y.s = x.s;\r\n        return y;\r\n      }\r\n    }\r\n\r\n    // If y is not zero, calculate the nearest multiple of y to x.\r\n    if (y.d[0]) {\r\n      external = false;\r\n      x = divide(x, y, 0, rm, 1).times(y);\r\n      external = true;\r\n      finalise(x);\r\n\r\n    // If y is zero, return zero with the sign of x.\r\n    } else {\r\n      y.s = x.s;\r\n      x = y;\r\n    }\r\n\r\n    return x;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the value of this Decimal converted to a number primitive.\r\n   * Zero keeps its sign.\r\n   *\r\n   */\r\n  P.toNumber = function () {\r\n    return +this;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in base 8, round to `sd` significant\r\n   * digits using rounding mode `rm`.\r\n   *\r\n   * If the optional `sd` argument is present then return binary exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toOctal = function (sd, rm) {\r\n    return toStringBinary(this, 8, sd, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal raised to the power `y`, rounded\r\n   * to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * ECMAScript compliant.\r\n   *\r\n   *   pow(x, NaN)                           = NaN\r\n   *   pow(x, 0)                            = 1\r\n\r\n   *   pow(NaN, non-zero)                    = NaN\r\n   *   pow(abs(x) > 1, +Infinity)            = +Infinity\r\n   *   pow(abs(x) > 1, -Infinity)            = +0\r\n   *   pow(abs(x) == 1, Infinity)           = NaN\r\n   *   pow(abs(x) < 1, +Infinity)            = +0\r\n   *   pow(abs(x) < 1, -Infinity)            = +Infinity\r\n   *   pow(+Infinity, y > 0)                 = +Infinity\r\n   *   pow(+Infinity, y < 0)                 = +0\r\n   *   pow(-Infinity, odd integer > 0)       = -Infinity\r\n   *   pow(-Infinity, even integer > 0)      = +Infinity\r\n   *   pow(-Infinity, odd integer < 0)       = -0\r\n   *   pow(-Infinity, even integer < 0)      = +0\r\n   *   pow(+0, y > 0)                        = +0\r\n   *   pow(+0, y < 0)                        = +Infinity\r\n   *   pow(-0, odd integer > 0)              = -0\r\n   *   pow(-0, even integer > 0)             = +0\r\n   *   pow(-0, odd integer < 0)              = -Infinity\r\n   *   pow(-0, even integer < 0)             = +Infinity\r\n   *   pow(finite x < 0, finite non-integer) = NaN\r\n   *\r\n   * For non-integer or very large exponents pow(x, y) is calculated using\r\n   *\r\n   *   x^y = exp(y*ln(x))\r\n   *\r\n   * Assuming the first 15 rounding digits are each equally likely to be any digit 0-9, the\r\n   * probability of an incorrectly rounded result\r\n   * P([49]9{14} | [50]0{14}) = 2 * 0.2 * 10^-14 = 4e-15 = 1/2.5e+14\r\n   * i.e. 1 in 250,000,000,000,000\r\n   *\r\n   * If a result is incorrectly rounded the maximum error will be 1 ulp (unit in last place).\r\n   *\r\n   * y {number|string|Decimal} The power to which to raise this Decimal.\r\n   *\r\n   */\r\n  P.toPower = P.pow = function (y) {\r\n    var e, k, pr, r, rm, s,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      yn = +(y = new Ctor(y));\r\n\r\n    // Either Infinity, NaN or 0?\r\n    if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow(+x, yn));\r\n\r\n    x = new Ctor(x);\r\n\r\n    if (x.eq(1)) return x;\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n\r\n    if (y.eq(1)) return finalise(x, pr, rm);\r\n\r\n    // y exponent\r\n    e = mathfloor(y.e / LOG_BASE);\r\n\r\n    // If y is a small integer use the 'exponentiation by squaring' algorithm.\r\n    if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {\r\n      r = intPow(Ctor, x, k, pr);\r\n      return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);\r\n    }\r\n\r\n    s = x.s;\r\n\r\n    // if x is negative\r\n    if (s < 0) {\r\n\r\n      // if y is not an integer\r\n      if (e < y.d.length - 1) return new Ctor(NaN);\r\n\r\n      // Result is positive if x is negative and the last digit of integer y is even.\r\n      if ((y.d[e] & 1) == 0) s = 1;\r\n\r\n      // if x.eq(-1)\r\n      if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {\r\n        x.s = s;\r\n        return x;\r\n      }\r\n    }\r\n\r\n    // Estimate result exponent.\r\n    // x^y = 10^e,  where e = y * log10(x)\r\n    // log10(x) = log10(x_significand) + x_exponent\r\n    // log10(x_significand) = ln(x_significand) / ln(10)\r\n    k = mathpow(+x, yn);\r\n    e = k == 0 || !isFinite(k)\r\n      ? mathfloor(yn * (Math.log('0.' + digitsToString(x.d)) / Math.LN10 + x.e + 1))\r\n      : new Ctor(k + '').e;\r\n\r\n    // Exponent estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.\r\n\r\n    // Overflow/underflow?\r\n    if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);\r\n\r\n    external = false;\r\n    Ctor.rounding = x.s = 1;\r\n\r\n    // Estimate the extra guard digits needed to ensure five correct rounding digits from\r\n    // naturalLogarithm(x). Example of failure without these extra digits (precision: 10):\r\n    // new Decimal(2.32456).pow('2087987436534566.46411')\r\n    // should be 1.162377823e+764914905173815, but is 1.162355823e+764914905173815\r\n    k = Math.min(12, (e + '').length);\r\n\r\n    // r = x^y = exp(y*ln(x))\r\n    r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);\r\n\r\n    // r may be Infinity, e.g. (0.9999999999999999).pow(-1e+40)\r\n    if (r.d) {\r\n\r\n      // Truncate to the required precision plus five rounding digits.\r\n      r = finalise(r, pr + 5, 1);\r\n\r\n      // If the rounding digits are [49]9999 or [50]0000 increase the precision by 10 and recalculate\r\n      // the result.\r\n      if (checkRoundingDigits(r.d, pr, rm)) {\r\n        e = pr + 10;\r\n\r\n        // Truncate to the increased precision plus five rounding digits.\r\n        r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);\r\n\r\n        // Check for 14 nines from the 2nd rounding digit (the first rounding digit may be 4 or 9).\r\n        if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {\r\n          r = finalise(r, pr + 1, 0);\r\n        }\r\n      }\r\n    }\r\n\r\n    r.s = s;\r\n    external = true;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(r, pr, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal rounded to `sd` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * Return exponential notation if `sd` is less than the number of digits necessary to represent\r\n   * the integer part of the value in normal notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toPrecision = function (sd, rm) {\r\n    var str,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (sd === void 0) {\r\n      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\r\n    } else {\r\n      checkInt32(sd, 1, MAX_DIGITS);\r\n\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n\r\n      x = finalise(new Ctor(x), sd, rm);\r\n      str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);\r\n    }\r\n\r\n    return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `sd`\r\n   * significant digits using rounding mode `rm`, or to `precision` and `rounding` respectively if\r\n   * omitted.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * 'toSD() digits out of range: {sd}'\r\n   * 'toSD() digits not an integer: {sd}'\r\n   * 'toSD() rounding mode not an integer: {rm}'\r\n   * 'toSD() rounding mode out of range: {rm}'\r\n   *\r\n   */\r\n  P.toSignificantDigits = P.toSD = function (sd, rm) {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (sd === void 0) {\r\n      sd = Ctor.precision;\r\n      rm = Ctor.rounding;\r\n    } else {\r\n      checkInt32(sd, 1, MAX_DIGITS);\r\n\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n    }\r\n\r\n    return finalise(new Ctor(x), sd, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal.\r\n   *\r\n   * Return exponential notation if this Decimal has a positive exponent equal to or greater than\r\n   * `toExpPos`, or a negative exponent equal to or less than `toExpNeg`.\r\n   *\r\n   */\r\n  P.toString = function () {\r\n    var x = this,\r\n      Ctor = x.constructor,\r\n      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\r\n\r\n    return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal truncated to a whole number.\r\n   *\r\n   */\r\n  P.truncated = P.trunc = function () {\r\n    return finalise(new this.constructor(this), this.e + 1, 1);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal.\r\n   * Unlike `toString`, negative zero will include the minus sign.\r\n   *\r\n   */\r\n  P.valueOf = P.toJSON = function () {\r\n    var x = this,\r\n      Ctor = x.constructor,\r\n      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\r\n\r\n    return x.isNeg() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  // Helper functions for Decimal.prototype (P) and/or Decimal methods, and their callers.\r\n\r\n\r\n  /*\r\n   *  digitsToString           P.cubeRoot, P.logarithm, P.squareRoot, P.toFraction, P.toPower,\r\n   *                           finiteToString, naturalExponential, naturalLogarithm\r\n   *  checkInt32               P.toDecimalPlaces, P.toExponential, P.toFixed, P.toNearest,\r\n   *                           P.toPrecision, P.toSignificantDigits, toStringBinary, random\r\n   *  checkRoundingDigits      P.logarithm, P.toPower, naturalExponential, naturalLogarithm\r\n   *  convertBase              toStringBinary, parseOther\r\n   *  cos                      P.cos\r\n   *  divide                   P.atanh, P.cubeRoot, P.dividedBy, P.dividedToIntegerBy,\r\n   *                           P.logarithm, P.modulo, P.squareRoot, P.tan, P.tanh, P.toFraction,\r\n   *                           P.toNearest, toStringBinary, naturalExponential, naturalLogarithm,\r\n   *                           taylorSeries, atan2, parseOther\r\n   *  finalise                 P.absoluteValue, P.atan, P.atanh, P.ceil, P.cos, P.cosh,\r\n   *                           P.cubeRoot, P.dividedToIntegerBy, P.floor, P.logarithm, P.minus,\r\n   *                           P.modulo, P.negated, P.plus, P.round, P.sin, P.sinh, P.squareRoot,\r\n   *                           P.tan, P.times, P.toDecimalPlaces, P.toExponential, P.toFixed,\r\n   *                           P.toNearest, P.toPower, P.toPrecision, P.toSignificantDigits,\r\n   *                           P.truncated, divide, getLn10, getPi, naturalExponential,\r\n   *                           naturalLogarithm, ceil, floor, round, trunc\r\n   *  finiteToString           P.toExponential, P.toFixed, P.toPrecision, P.toString, P.valueOf,\r\n   *                           toStringBinary\r\n   *  getBase10Exponent        P.minus, P.plus, P.times, parseOther\r\n   *  getLn10                  P.logarithm, naturalLogarithm\r\n   *  getPi                    P.acos, P.asin, P.atan, toLessThanHalfPi, atan2\r\n   *  getPrecision             P.precision, P.toFraction\r\n   *  getZeroString            digitsToString, finiteToString\r\n   *  intPow                   P.toPower, parseOther\r\n   *  isOdd                    toLessThanHalfPi\r\n   *  maxOrMin                 max, min\r\n   *  naturalExponential       P.naturalExponential, P.toPower\r\n   *  naturalLogarithm         P.acosh, P.asinh, P.atanh, P.logarithm, P.naturalLogarithm,\r\n   *                           P.toPower, naturalExponential\r\n   *  nonFiniteToString        finiteToString, toStringBinary\r\n   *  parseDecimal             Decimal\r\n   *  parseOther               Decimal\r\n   *  sin                      P.sin\r\n   *  taylorSeries             P.cosh, P.sinh, cos, sin\r\n   *  toLessThanHalfPi         P.cos, P.sin\r\n   *  toStringBinary           P.toBinary, P.toHexadecimal, P.toOctal\r\n   *  truncate                 intPow\r\n   *\r\n   *  Throws:                  P.logarithm, P.precision, P.toFraction, checkInt32, getLn10, getPi,\r\n   *                           naturalLogarithm, config, parseOther, random, Decimal\r\n   */\r\n\r\n\r\n  function digitsToString(d) {\r\n    var i, k, ws,\r\n      indexOfLastWord = d.length - 1,\r\n      str = '',\r\n      w = d[0];\r\n\r\n    if (indexOfLastWord > 0) {\r\n      str += w;\r\n      for (i = 1; i < indexOfLastWord; i++) {\r\n        ws = d[i] + '';\r\n        k = LOG_BASE - ws.length;\r\n        if (k) str += getZeroString(k);\r\n        str += ws;\r\n      }\r\n\r\n      w = d[i];\r\n      ws = w + '';\r\n      k = LOG_BASE - ws.length;\r\n      if (k) str += getZeroString(k);\r\n    } else if (w === 0) {\r\n      return '0';\r\n    }\r\n\r\n    // Remove trailing zeros of last w.\r\n    for (; w % 10 === 0;) w /= 10;\r\n\r\n    return str + w;\r\n  }\r\n\r\n\r\n  function checkInt32(i, min, max) {\r\n    if (i !== ~~i || i < min || i > max) {\r\n      throw Error(invalidArgument + i);\r\n    }\r\n  }\r\n\r\n\r\n  /*\r\n   * Check 5 rounding digits if `repeating` is null, 4 otherwise.\r\n   * `repeating == null` if caller is `log` or `pow`,\r\n   * `repeating != null` if caller is `naturalLogarithm` or `naturalExponential`.\r\n   */\r\n  function checkRoundingDigits(d, i, rm, repeating) {\r\n    var di, k, r, rd;\r\n\r\n    // Get the length of the first word of the array d.\r\n    for (k = d[0]; k >= 10; k /= 10) --i;\r\n\r\n    // Is the rounding digit in the first word of d?\r\n    if (--i < 0) {\r\n      i += LOG_BASE;\r\n      di = 0;\r\n    } else {\r\n      di = Math.ceil((i + 1) / LOG_BASE);\r\n      i %= LOG_BASE;\r\n    }\r\n\r\n    // i is the index (0 - 6) of the rounding digit.\r\n    // E.g. if within the word 3487563 the first rounding digit is 5,\r\n    // then i = 4, k = 1000, rd = 3487563 % 1000 = 563\r\n    k = mathpow(10, LOG_BASE - i);\r\n    rd = d[di] % k | 0;\r\n\r\n    if (repeating == null) {\r\n      if (i < 3) {\r\n        if (i == 0) rd = rd / 100 | 0;\r\n        else if (i == 1) rd = rd / 10 | 0;\r\n        r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 50000 || rd == 0;\r\n      } else {\r\n        r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) &&\r\n          (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 ||\r\n            (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;\r\n      }\r\n    } else {\r\n      if (i < 4) {\r\n        if (i == 0) rd = rd / 1000 | 0;\r\n        else if (i == 1) rd = rd / 100 | 0;\r\n        else if (i == 2) rd = rd / 10 | 0;\r\n        r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;\r\n      } else {\r\n        r = ((repeating || rm < 4) && rd + 1 == k ||\r\n        (!repeating && rm > 3) && rd + 1 == k / 2) &&\r\n          (d[di + 1] / k / 1000 | 0) == mathpow(10, i - 3) - 1;\r\n      }\r\n    }\r\n\r\n    return r;\r\n  }\r\n\r\n\r\n  // Convert string of `baseIn` to an array of numbers of `baseOut`.\r\n  // Eg. convertBase('255', 10, 16) returns [15, 15].\r\n  // Eg. convertBase('ff', 16, 10) returns [2, 5, 5].\r\n  function convertBase(str, baseIn, baseOut) {\r\n    var j,\r\n      arr = [0],\r\n      arrL,\r\n      i = 0,\r\n      strL = str.length;\r\n\r\n    for (; i < strL;) {\r\n      for (arrL = arr.length; arrL--;) arr[arrL] *= baseIn;\r\n      arr[0] += NUMERALS.indexOf(str.charAt(i++));\r\n      for (j = 0; j < arr.length; j++) {\r\n        if (arr[j] > baseOut - 1) {\r\n          if (arr[j + 1] === void 0) arr[j + 1] = 0;\r\n          arr[j + 1] += arr[j] / baseOut | 0;\r\n          arr[j] %= baseOut;\r\n        }\r\n      }\r\n    }\r\n\r\n    return arr.reverse();\r\n  }\r\n\r\n\r\n  /*\r\n   * cos(x) = 1 - x^2/2! + x^4/4! - ...\r\n   * |x| < pi/2\r\n   *\r\n   */\r\n  function cosine(Ctor, x) {\r\n    var k, len, y;\r\n\r\n    if (x.isZero()) return x;\r\n\r\n    // Argument reduction: cos(4x) = 8*(cos^4(x) - cos^2(x)) + 1\r\n    // i.e. cos(x) = 8*(cos^4(x/4) - cos^2(x/4)) + 1\r\n\r\n    // Estimate the optimum number of times to use the argument reduction.\r\n    len = x.d.length;\r\n    if (len < 32) {\r\n      k = Math.ceil(len / 3);\r\n      y = (1 / tinyPow(4, k)).toString();\r\n    } else {\r\n      k = 16;\r\n      y = '2.3283064365386962890625e-10';\r\n    }\r\n\r\n    Ctor.precision += k;\r\n\r\n    x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));\r\n\r\n    // Reverse argument reduction\r\n    for (var i = k; i--;) {\r\n      var cos2x = x.times(x);\r\n      x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);\r\n    }\r\n\r\n    Ctor.precision -= k;\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * Perform division in the specified base.\r\n   */\r\n  var divide = (function () {\r\n\r\n    // Assumes non-zero x and k, and hence non-zero result.\r\n    function multiplyInteger(x, k, base) {\r\n      var temp,\r\n        carry = 0,\r\n        i = x.length;\r\n\r\n      for (x = x.slice(); i--;) {\r\n        temp = x[i] * k + carry;\r\n        x[i] = temp % base | 0;\r\n        carry = temp / base | 0;\r\n      }\r\n\r\n      if (carry) x.unshift(carry);\r\n\r\n      return x;\r\n    }\r\n\r\n    function compare(a, b, aL, bL) {\r\n      var i, r;\r\n\r\n      if (aL != bL) {\r\n        r = aL > bL ? 1 : -1;\r\n      } else {\r\n        for (i = r = 0; i < aL; i++) {\r\n          if (a[i] != b[i]) {\r\n            r = a[i] > b[i] ? 1 : -1;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      return r;\r\n    }\r\n\r\n    function subtract(a, b, aL, base) {\r\n      var i = 0;\r\n\r\n      // Subtract b from a.\r\n      for (; aL--;) {\r\n        a[aL] -= i;\r\n        i = a[aL] < b[aL] ? 1 : 0;\r\n        a[aL] = i * base + a[aL] - b[aL];\r\n      }\r\n\r\n      // Remove leading zeros.\r\n      for (; !a[0] && a.length > 1;) a.shift();\r\n    }\r\n\r\n    return function (x, y, pr, rm, dp, base) {\r\n      var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0,\r\n        yL, yz,\r\n        Ctor = x.constructor,\r\n        sign = x.s == y.s ? 1 : -1,\r\n        xd = x.d,\r\n        yd = y.d;\r\n\r\n      // Either NaN, Infinity or 0?\r\n      if (!xd || !xd[0] || !yd || !yd[0]) {\r\n\r\n        return new Ctor(// Return NaN if either NaN, or both Infinity or 0.\r\n          !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN :\r\n\r\n          // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.\r\n          xd && xd[0] == 0 || !yd ? sign * 0 : sign / 0);\r\n      }\r\n\r\n      if (base) {\r\n        logBase = 1;\r\n        e = x.e - y.e;\r\n      } else {\r\n        base = BASE;\r\n        logBase = LOG_BASE;\r\n        e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);\r\n      }\r\n\r\n      yL = yd.length;\r\n      xL = xd.length;\r\n      q = new Ctor(sign);\r\n      qd = q.d = [];\r\n\r\n      // Result exponent may be one less than e.\r\n      // The digit array of a Decimal from toStringBinary may have trailing zeros.\r\n      for (i = 0; yd[i] == (xd[i] || 0); i++);\r\n\r\n      if (yd[i] > (xd[i] || 0)) e--;\r\n\r\n      if (pr == null) {\r\n        sd = pr = Ctor.precision;\r\n        rm = Ctor.rounding;\r\n      } else if (dp) {\r\n        sd = pr + (x.e - y.e) + 1;\r\n      } else {\r\n        sd = pr;\r\n      }\r\n\r\n      if (sd < 0) {\r\n        qd.push(1);\r\n        more = true;\r\n      } else {\r\n\r\n        // Convert precision in number of base 10 digits to base 1e7 digits.\r\n        sd = sd / logBase + 2 | 0;\r\n        i = 0;\r\n\r\n        // divisor < 1e7\r\n        if (yL == 1) {\r\n          k = 0;\r\n          yd = yd[0];\r\n          sd++;\r\n\r\n          // k is the carry.\r\n          for (; (i < xL || k) && sd--; i++) {\r\n            t = k * base + (xd[i] || 0);\r\n            qd[i] = t / yd | 0;\r\n            k = t % yd | 0;\r\n          }\r\n\r\n          more = k || i < xL;\r\n\r\n        // divisor >= 1e7\r\n        } else {\r\n\r\n          // Normalise xd and yd so highest order digit of yd is >= base/2\r\n          k = base / (yd[0] + 1) | 0;\r\n\r\n          if (k > 1) {\r\n            yd = multiplyInteger(yd, k, base);\r\n            xd = multiplyInteger(xd, k, base);\r\n            yL = yd.length;\r\n            xL = xd.length;\r\n          }\r\n\r\n          xi = yL;\r\n          rem = xd.slice(0, yL);\r\n          remL = rem.length;\r\n\r\n          // Add zeros to make remainder as long as divisor.\r\n          for (; remL < yL;) rem[remL++] = 0;\r\n\r\n          yz = yd.slice();\r\n          yz.unshift(0);\r\n          yd0 = yd[0];\r\n\r\n          if (yd[1] >= base / 2) ++yd0;\r\n\r\n          do {\r\n            k = 0;\r\n\r\n            // Compare divisor and remainder.\r\n            cmp = compare(yd, rem, yL, remL);\r\n\r\n            // If divisor < remainder.\r\n            if (cmp < 0) {\r\n\r\n              // Calculate trial digit, k.\r\n              rem0 = rem[0];\r\n              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\r\n\r\n              // k will be how many times the divisor goes into the current remainder.\r\n              k = rem0 / yd0 | 0;\r\n\r\n              //  Algorithm:\r\n              //  1. product = divisor * trial digit (k)\r\n              //  2. if product > remainder: product -= divisor, k--\r\n              //  3. remainder -= product\r\n              //  4. if product was < remainder at 2:\r\n              //    5. compare new remainder and divisor\r\n              //    6. If remainder > divisor: remainder -= divisor, k++\r\n\r\n              if (k > 1) {\r\n                if (k >= base) k = base - 1;\r\n\r\n                // product = divisor * trial digit.\r\n                prod = multiplyInteger(yd, k, base);\r\n                prodL = prod.length;\r\n                remL = rem.length;\r\n\r\n                // Compare product and remainder.\r\n                cmp = compare(prod, rem, prodL, remL);\r\n\r\n                // product > remainder.\r\n                if (cmp == 1) {\r\n                  k--;\r\n\r\n                  // Subtract divisor from product.\r\n                  subtract(prod, yL < prodL ? yz : yd, prodL, base);\r\n                }\r\n              } else {\r\n\r\n                // cmp is -1.\r\n                // If k is 0, there is no need to compare yd and rem again below, so change cmp to 1\r\n                // to avoid it. If k is 1 there is a need to compare yd and rem again below.\r\n                if (k == 0) cmp = k = 1;\r\n                prod = yd.slice();\r\n              }\r\n\r\n              prodL = prod.length;\r\n              if (prodL < remL) prod.unshift(0);\r\n\r\n              // Subtract product from remainder.\r\n              subtract(rem, prod, remL, base);\r\n\r\n              // If product was < previous remainder.\r\n              if (cmp == -1) {\r\n                remL = rem.length;\r\n\r\n                // Compare divisor and new remainder.\r\n                cmp = compare(yd, rem, yL, remL);\r\n\r\n                // If divisor < new remainder, subtract divisor from remainder.\r\n                if (cmp < 1) {\r\n                  k++;\r\n\r\n                  // Subtract divisor from remainder.\r\n                  subtract(rem, yL < remL ? yz : yd, remL, base);\r\n                }\r\n              }\r\n\r\n              remL = rem.length;\r\n            } else if (cmp === 0) {\r\n              k++;\r\n              rem = [0];\r\n            }    // if cmp === 1, k will be 0\r\n\r\n            // Add the next digit, k, to the result array.\r\n            qd[i++] = k;\r\n\r\n            // Update the remainder.\r\n            if (cmp && rem[0]) {\r\n              rem[remL++] = xd[xi] || 0;\r\n            } else {\r\n              rem = [xd[xi]];\r\n              remL = 1;\r\n            }\r\n\r\n          } while ((xi++ < xL || rem[0] !== void 0) && sd--);\r\n\r\n          more = rem[0] !== void 0;\r\n        }\r\n\r\n        // Leading zero?\r\n        if (!qd[0]) qd.shift();\r\n      }\r\n\r\n      // logBase is 1 when divide is being used for base conversion.\r\n      if (logBase == 1) {\r\n        q.e = e;\r\n        inexact = more;\r\n      } else {\r\n\r\n        // To calculate q.e, first get the number of digits of qd[0].\r\n        for (i = 1, k = qd[0]; k >= 10; k /= 10) i++;\r\n        q.e = i + e * logBase - 1;\r\n\r\n        finalise(q, dp ? pr + q.e + 1 : pr, rm, more);\r\n      }\r\n\r\n      return q;\r\n    };\r\n  })();\r\n\r\n\r\n  /*\r\n   * Round `x` to `sd` significant digits using rounding mode `rm`.\r\n   * Check for over/under-flow.\r\n   */\r\n   function finalise(x, sd, rm, isTruncated) {\r\n    var digits, i, j, k, rd, roundUp, w, xd, xdi,\r\n      Ctor = x.constructor;\r\n\r\n    // Don't round if sd is null or undefined.\r\n    out: if (sd != null) {\r\n      xd = x.d;\r\n\r\n      // Infinity/NaN.\r\n      if (!xd) return x;\r\n\r\n      // rd: the rounding digit, i.e. the digit after the digit that may be rounded up.\r\n      // w: the word of xd containing rd, a base 1e7 number.\r\n      // xdi: the index of w within xd.\r\n      // digits: the number of digits of w.\r\n      // i: what would be the index of rd within w if all the numbers were 7 digits long (i.e. if\r\n      // they had leading zeros)\r\n      // j: if > 0, the actual index of rd within w (if < 0, rd is a leading zero).\r\n\r\n      // Get the length of the first word of the digits array xd.\r\n      for (digits = 1, k = xd[0]; k >= 10; k /= 10) digits++;\r\n      i = sd - digits;\r\n\r\n      // Is the rounding digit in the first word of xd?\r\n      if (i < 0) {\r\n        i += LOG_BASE;\r\n        j = sd;\r\n        w = xd[xdi = 0];\r\n\r\n        // Get the rounding digit at index j of w.\r\n        rd = w / mathpow(10, digits - j - 1) % 10 | 0;\r\n      } else {\r\n        xdi = Math.ceil((i + 1) / LOG_BASE);\r\n        k = xd.length;\r\n        if (xdi >= k) {\r\n          if (isTruncated) {\r\n\r\n            // Needed by `naturalExponential`, `naturalLogarithm` and `squareRoot`.\r\n            for (; k++ <= xdi;) xd.push(0);\r\n            w = rd = 0;\r\n            digits = 1;\r\n            i %= LOG_BASE;\r\n            j = i - LOG_BASE + 1;\r\n          } else {\r\n            break out;\r\n          }\r\n        } else {\r\n          w = k = xd[xdi];\r\n\r\n          // Get the number of digits of w.\r\n          for (digits = 1; k >= 10; k /= 10) digits++;\r\n\r\n          // Get the index of rd within w.\r\n          i %= LOG_BASE;\r\n\r\n          // Get the index of rd within w, adjusted for leading zeros.\r\n          // The number of leading zeros of w is given by LOG_BASE - digits.\r\n          j = i - LOG_BASE + digits;\r\n\r\n          // Get the rounding digit at index j of w.\r\n          rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;\r\n        }\r\n      }\r\n\r\n      // Are there any non-zero digits after the rounding digit?\r\n      isTruncated = isTruncated || sd < 0 ||\r\n        xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));\r\n\r\n      // The expression `w % mathpow(10, digits - j - 1)` returns all the digits of w to the right\r\n      // of the digit at (left-to-right) index j, e.g. if w is 908714 and j is 2, the expression\r\n      // will give 714.\r\n\r\n      roundUp = rm < 4\r\n        ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n        : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 &&\r\n\r\n          // Check whether the digit to the left of the rounding digit is odd.\r\n          ((i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10) & 1 ||\r\n            rm == (x.s < 0 ? 8 : 7));\r\n\r\n      if (sd < 1 || !xd[0]) {\r\n        xd.length = 0;\r\n        if (roundUp) {\r\n\r\n          // Convert sd to decimal places.\r\n          sd -= x.e + 1;\r\n\r\n          // 1, 0.1, 0.01, 0.001, 0.0001 etc.\r\n          xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);\r\n          x.e = -sd || 0;\r\n        } else {\r\n\r\n          // Zero.\r\n          xd[0] = x.e = 0;\r\n        }\r\n\r\n        return x;\r\n      }\r\n\r\n      // Remove excess digits.\r\n      if (i == 0) {\r\n        xd.length = xdi;\r\n        k = 1;\r\n        xdi--;\r\n      } else {\r\n        xd.length = xdi + 1;\r\n        k = mathpow(10, LOG_BASE - i);\r\n\r\n        // E.g. 56700 becomes 56000 if 7 is the rounding digit.\r\n        // j > 0 means i > number of leading zeros of w.\r\n        xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;\r\n      }\r\n\r\n      if (roundUp) {\r\n        for (;;) {\r\n\r\n          // Is the digit to be rounded up in the first word of xd?\r\n          if (xdi == 0) {\r\n\r\n            // i will be the length of xd[0] before k is added.\r\n            for (i = 1, j = xd[0]; j >= 10; j /= 10) i++;\r\n            j = xd[0] += k;\r\n            for (k = 1; j >= 10; j /= 10) k++;\r\n\r\n            // if i != k the length has increased.\r\n            if (i != k) {\r\n              x.e++;\r\n              if (xd[0] == BASE) xd[0] = 1;\r\n            }\r\n\r\n            break;\r\n          } else {\r\n            xd[xdi] += k;\r\n            if (xd[xdi] != BASE) break;\r\n            xd[xdi--] = 0;\r\n            k = 1;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Remove trailing zeros.\r\n      for (i = xd.length; xd[--i] === 0;) xd.pop();\r\n    }\r\n\r\n    if (external) {\r\n\r\n      // Overflow?\r\n      if (x.e > Ctor.maxE) {\r\n\r\n        // Infinity.\r\n        x.d = null;\r\n        x.e = NaN;\r\n\r\n      // Underflow?\r\n      } else if (x.e < Ctor.minE) {\r\n\r\n        // Zero.\r\n        x.e = 0;\r\n        x.d = [0];\r\n        // Ctor.underflow = true;\r\n      } // else Ctor.underflow = false;\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  function finiteToString(x, isExp, sd) {\r\n    if (!x.isFinite()) return nonFiniteToString(x);\r\n    var k,\r\n      e = x.e,\r\n      str = digitsToString(x.d),\r\n      len = str.length;\r\n\r\n    if (isExp) {\r\n      if (sd && (k = sd - len) > 0) {\r\n        str = str.charAt(0) + '.' + str.slice(1) + getZeroString(k);\r\n      } else if (len > 1) {\r\n        str = str.charAt(0) + '.' + str.slice(1);\r\n      }\r\n\r\n      str = str + (x.e < 0 ? 'e' : 'e+') + x.e;\r\n    } else if (e < 0) {\r\n      str = '0.' + getZeroString(-e - 1) + str;\r\n      if (sd && (k = sd - len) > 0) str += getZeroString(k);\r\n    } else if (e >= len) {\r\n      str += getZeroString(e + 1 - len);\r\n      if (sd && (k = sd - e - 1) > 0) str = str + '.' + getZeroString(k);\r\n    } else {\r\n      if ((k = e + 1) < len) str = str.slice(0, k) + '.' + str.slice(k);\r\n      if (sd && (k = sd - len) > 0) {\r\n        if (e + 1 === len) str += '.';\r\n        str += getZeroString(k);\r\n      }\r\n    }\r\n\r\n    return str;\r\n  }\r\n\r\n\r\n  // Calculate the base 10 exponent from the base 1e7 exponent.\r\n  function getBase10Exponent(digits, e) {\r\n    var w = digits[0];\r\n\r\n    // Add the number of digits of the first word of the digits array.\r\n    for ( e *= LOG_BASE; w >= 10; w /= 10) e++;\r\n    return e;\r\n  }\r\n\r\n\r\n  function getLn10(Ctor, sd, pr) {\r\n    if (sd > LN10_PRECISION) {\r\n\r\n      // Reset global state in case the exception is caught.\r\n      external = true;\r\n      if (pr) Ctor.precision = pr;\r\n      throw Error(precisionLimitExceeded);\r\n    }\r\n    return finalise(new Ctor(LN10), sd, 1, true);\r\n  }\r\n\r\n\r\n  function getPi(Ctor, sd, rm) {\r\n    if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);\r\n    return finalise(new Ctor(PI), sd, rm, true);\r\n  }\r\n\r\n\r\n  function getPrecision(digits) {\r\n    var w = digits.length - 1,\r\n      len = w * LOG_BASE + 1;\r\n\r\n    w = digits[w];\r\n\r\n    // If non-zero...\r\n    if (w) {\r\n\r\n      // Subtract the number of trailing zeros of the last word.\r\n      for (; w % 10 == 0; w /= 10) len--;\r\n\r\n      // Add the number of digits of the first word.\r\n      for (w = digits[0]; w >= 10; w /= 10) len++;\r\n    }\r\n\r\n    return len;\r\n  }\r\n\r\n\r\n  function getZeroString(k) {\r\n    var zs = '';\r\n    for (; k--;) zs += '0';\r\n    return zs;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of Decimal `x` to the power `n`, where `n` is an\r\n   * integer of type number.\r\n   *\r\n   * Implements 'exponentiation by squaring'. Called by `pow` and `parseOther`.\r\n   *\r\n   */\r\n  function intPow(Ctor, x, n, pr) {\r\n    var isTruncated,\r\n      r = new Ctor(1),\r\n\r\n      // Max n of 9007199254740991 takes 53 loop iterations.\r\n      // Maximum digits array length; leaves [28, 34] guard digits.\r\n      k = Math.ceil(pr / LOG_BASE + 4);\r\n\r\n    external = false;\r\n\r\n    for (;;) {\r\n      if (n % 2) {\r\n        r = r.times(x);\r\n        if (truncate(r.d, k)) isTruncated = true;\r\n      }\r\n\r\n      n = mathfloor(n / 2);\r\n      if (n === 0) {\r\n\r\n        // To ensure correct rounding when r.d is truncated, increment the last word if it is zero.\r\n        n = r.d.length - 1;\r\n        if (isTruncated && r.d[n] === 0) ++r.d[n];\r\n        break;\r\n      }\r\n\r\n      x = x.times(x);\r\n      truncate(x.d, k);\r\n    }\r\n\r\n    external = true;\r\n\r\n    return r;\r\n  }\r\n\r\n\r\n  function isOdd(n) {\r\n    return n.d[n.d.length - 1] & 1;\r\n  }\r\n\r\n\r\n  /*\r\n   * Handle `max` and `min`. `ltgt` is 'lt' or 'gt'.\r\n   */\r\n  function maxOrMin(Ctor, args, ltgt) {\r\n    var y,\r\n      x = new Ctor(args[0]),\r\n      i = 0;\r\n\r\n    for (; ++i < args.length;) {\r\n      y = new Ctor(args[i]);\r\n      if (!y.s) {\r\n        x = y;\r\n        break;\r\n      } else if (x[ltgt](y)) {\r\n        x = y;\r\n      }\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural exponential of `x` rounded to `sd` significant\r\n   * digits.\r\n   *\r\n   * Taylor/Maclaurin series.\r\n   *\r\n   * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ...\r\n   *\r\n   * Argument reduction:\r\n   *   Repeat x = x / 32, k += 5, until |x| < 0.1\r\n   *   exp(x) = exp(x / 2^k)^(2^k)\r\n   *\r\n   * Previously, the argument was initially reduced by\r\n   * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)\r\n   * to first put r in the range [0, ln10], before dividing by 32 until |x| < 0.1, but this was\r\n   * found to be slower than just dividing repeatedly by 32 as above.\r\n   *\r\n   * Max integer argument: exp('20723265836946413') = 6.3e+9000000000000000\r\n   * Min integer argument: exp('-20723265836946411') = 1.2e-9000000000000000\r\n   * (Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324)\r\n   *\r\n   *  exp(Infinity)  = Infinity\r\n   *  exp(-Infinity) = 0\r\n   *  exp(NaN)       = NaN\r\n   *  exp(0)        = 1\r\n   *\r\n   *  exp(x) is non-terminating for any finite, non-zero x.\r\n   *\r\n   *  The result will always be correctly rounded.\r\n   *\r\n   */\r\n  function naturalExponential(x, sd) {\r\n    var denominator, guard, j, pow, sum, t, wpr,\r\n      rep = 0,\r\n      i = 0,\r\n      k = 0,\r\n      Ctor = x.constructor,\r\n      rm = Ctor.rounding,\r\n      pr = Ctor.precision;\r\n\r\n    // 0/NaN/Infinity?\r\n    if (!x.d || !x.d[0] || x.e > 17) {\r\n\r\n      return new Ctor(x.d\r\n        ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0\r\n        : x.s ? x.s < 0 ? 0 : x : 0 / 0);\r\n    }\r\n\r\n    if (sd == null) {\r\n      external = false;\r\n      wpr = pr;\r\n    } else {\r\n      wpr = sd;\r\n    }\r\n\r\n    t = new Ctor(0.03125);\r\n\r\n    // while abs(x) >= 0.1\r\n    while (x.e > -2) {\r\n\r\n      // x = x / 2^5\r\n      x = x.times(t);\r\n      k += 5;\r\n    }\r\n\r\n    // Use 2 * log10(2^k) + 5 (empirically derived) to estimate the increase in precision\r\n    // necessary to ensure the first 4 rounding digits are correct.\r\n    guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;\r\n    wpr += guard;\r\n    denominator = pow = sum = new Ctor(1);\r\n    Ctor.precision = wpr;\r\n\r\n    for (;;) {\r\n      pow = finalise(pow.times(x), wpr, 1);\r\n      denominator = denominator.times(++i);\r\n      t = sum.plus(divide(pow, denominator, wpr, 1));\r\n\r\n      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {\r\n        j = k;\r\n        while (j--) sum = finalise(sum.times(sum), wpr, 1);\r\n\r\n        // Check to see if the first 4 rounding digits are [49]999.\r\n        // If so, repeat the summation with a higher precision, otherwise\r\n        // e.g. with precision: 18, rounding: 1\r\n        // exp(18.404272462595034083567793919843761) = 98372560.1229999999 (should be 98372560.123)\r\n        // `wpr - guard` is the index of first rounding digit.\r\n        if (sd == null) {\r\n\r\n          if (rep < 3 && checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {\r\n            Ctor.precision = wpr += 10;\r\n            denominator = pow = t = new Ctor(1);\r\n            i = 0;\r\n            rep++;\r\n          } else {\r\n            return finalise(sum, Ctor.precision = pr, rm, external = true);\r\n          }\r\n        } else {\r\n          Ctor.precision = pr;\r\n          return sum;\r\n        }\r\n      }\r\n\r\n      sum = t;\r\n    }\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural logarithm of `x` rounded to `sd` significant\r\n   * digits.\r\n   *\r\n   *  ln(-n)        = NaN\r\n   *  ln(0)         = -Infinity\r\n   *  ln(-0)        = -Infinity\r\n   *  ln(1)         = 0\r\n   *  ln(Infinity)  = Infinity\r\n   *  ln(-Infinity) = NaN\r\n   *  ln(NaN)       = NaN\r\n   *\r\n   *  ln(n) (n != 1) is non-terminating.\r\n   *\r\n   */\r\n  function naturalLogarithm(y, sd) {\r\n    var c, c0, denominator, e, numerator, rep, sum, t, wpr, x1, x2,\r\n      n = 1,\r\n      guard = 10,\r\n      x = y,\r\n      xd = x.d,\r\n      Ctor = x.constructor,\r\n      rm = Ctor.rounding,\r\n      pr = Ctor.precision;\r\n\r\n    // Is x negative or Infinity, NaN, 0 or 1?\r\n    if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {\r\n      return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);\r\n    }\r\n\r\n    if (sd == null) {\r\n      external = false;\r\n      wpr = pr;\r\n    } else {\r\n      wpr = sd;\r\n    }\r\n\r\n    Ctor.precision = wpr += guard;\r\n    c = digitsToString(xd);\r\n    c0 = c.charAt(0);\r\n\r\n    if (Math.abs(e = x.e) < 1.5e15) {\r\n\r\n      // Argument reduction.\r\n      // The series converges faster the closer the argument is to 1, so using\r\n      // ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b\r\n      // multiply the argument by itself until the leading digits of the significand are 7, 8, 9,\r\n      // 10, 11, 12 or 13, recording the number of multiplications so the sum of the series can\r\n      // later be divided by this number, then separate out the power of 10 using\r\n      // ln(a*10^b) = ln(a) + b*ln(10).\r\n\r\n      // max n is 21 (gives 0.9, 1.0 or 1.1) (9e15 / 21 = 4.2e14).\r\n      //while (c0 < 9 && c0 != 1 || c0 == 1 && c.charAt(1) > 1) {\r\n      // max n is 6 (gives 0.7 - 1.3)\r\n      while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {\r\n        x = x.times(y);\r\n        c = digitsToString(x.d);\r\n        c0 = c.charAt(0);\r\n        n++;\r\n      }\r\n\r\n      e = x.e;\r\n\r\n      if (c0 > 1) {\r\n        x = new Ctor('0.' + c);\r\n        e++;\r\n      } else {\r\n        x = new Ctor(c0 + '.' + c.slice(1));\r\n      }\r\n    } else {\r\n\r\n      // The argument reduction method above may result in overflow if the argument y is a massive\r\n      // number with exponent >= 1500000000000000 (9e15 / 6 = 1.5e15), so instead recall this\r\n      // function using ln(x*10^e) = ln(x) + e*ln(10).\r\n      t = getLn10(Ctor, wpr + 2, pr).times(e + '');\r\n      x = naturalLogarithm(new Ctor(c0 + '.' + c.slice(1)), wpr - guard).plus(t);\r\n      Ctor.precision = pr;\r\n\r\n      return sd == null ? finalise(x, pr, rm, external = true) : x;\r\n    }\r\n\r\n    // x1 is x reduced to a value near 1.\r\n    x1 = x;\r\n\r\n    // Taylor series.\r\n    // ln(y) = ln((1 + x)/(1 - x)) = 2(x + x^3/3 + x^5/5 + x^7/7 + ...)\r\n    // where x = (y - 1)/(y + 1)    (|x| < 1)\r\n    sum = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);\r\n    x2 = finalise(x.times(x), wpr, 1);\r\n    denominator = 3;\r\n\r\n    for (;;) {\r\n      numerator = finalise(numerator.times(x2), wpr, 1);\r\n      t = sum.plus(divide(numerator, new Ctor(denominator), wpr, 1));\r\n\r\n      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {\r\n        sum = sum.times(2);\r\n\r\n        // Reverse the argument reduction. Check that e is not 0 because, besides preventing an\r\n        // unnecessary calculation, -0 + 0 = +0 and to ensure correct rounding -0 needs to stay -0.\r\n        if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ''));\r\n        sum = divide(sum, new Ctor(n), wpr, 1);\r\n\r\n        // Is rm > 3 and the first 4 rounding digits 4999, or rm < 4 (or the summation has\r\n        // been repeated previously) and the first 4 rounding digits 9999?\r\n        // If so, restart the summation with a higher precision, otherwise\r\n        // e.g. with precision: 12, rounding: 1\r\n        // ln(135520028.6126091714265381533) = 18.7246299999 when it should be 18.72463.\r\n        // `wpr - guard` is the index of first rounding digit.\r\n        if (sd == null) {\r\n          if (checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {\r\n            Ctor.precision = wpr += guard;\r\n            t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);\r\n            x2 = finalise(x.times(x), wpr, 1);\r\n            denominator = rep = 1;\r\n          } else {\r\n            return finalise(sum, Ctor.precision = pr, rm, external = true);\r\n          }\r\n        } else {\r\n          Ctor.precision = pr;\r\n          return sum;\r\n        }\r\n      }\r\n\r\n      sum = t;\r\n      denominator += 2;\r\n    }\r\n  }\r\n\r\n\r\n  // Infinity, NaN.\r\n  function nonFiniteToString(x) {\r\n    // Unsigned.\r\n    return String(x.s * x.s / 0);\r\n  }\r\n\r\n\r\n  /*\r\n   * Parse the value of a new Decimal `x` from string `str`.\r\n   */\r\n  function parseDecimal(x, str) {\r\n    var e, i, len;\r\n\r\n    // Decimal point?\r\n    if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n\r\n    // Exponential form?\r\n    if ((i = str.search(/e/i)) > 0) {\r\n\r\n      // Determine exponent.\r\n      if (e < 0) e = i;\r\n      e += +str.slice(i + 1);\r\n      str = str.substring(0, i);\r\n    } else if (e < 0) {\r\n\r\n      // Integer.\r\n      e = str.length;\r\n    }\r\n\r\n    // Determine leading zeros.\r\n    for (i = 0; str.charCodeAt(i) === 48; i++);\r\n\r\n    // Determine trailing zeros.\r\n    for (len = str.length; str.charCodeAt(len - 1) === 48; --len);\r\n    str = str.slice(i, len);\r\n\r\n    if (str) {\r\n      len -= i;\r\n      x.e = e = e - i - 1;\r\n      x.d = [];\r\n\r\n      // Transform base\r\n\r\n      // e is the base 10 exponent.\r\n      // i is where to slice str to get the first word of the digits array.\r\n      i = (e + 1) % LOG_BASE;\r\n      if (e < 0) i += LOG_BASE;\r\n\r\n      if (i < len) {\r\n        if (i) x.d.push(+str.slice(0, i));\r\n        for (len -= LOG_BASE; i < len;) x.d.push(+str.slice(i, i += LOG_BASE));\r\n        str = str.slice(i);\r\n        i = LOG_BASE - str.length;\r\n      } else {\r\n        i -= len;\r\n      }\r\n\r\n      for (; i--;) str += '0';\r\n      x.d.push(+str);\r\n\r\n      if (external) {\r\n\r\n        // Overflow?\r\n        if (x.e > x.constructor.maxE) {\r\n\r\n          // Infinity.\r\n          x.d = null;\r\n          x.e = NaN;\r\n\r\n        // Underflow?\r\n        } else if (x.e < x.constructor.minE) {\r\n\r\n          // Zero.\r\n          x.e = 0;\r\n          x.d = [0];\r\n          // x.constructor.underflow = true;\r\n        } // else x.constructor.underflow = false;\r\n      }\r\n    } else {\r\n\r\n      // Zero.\r\n      x.e = 0;\r\n      x.d = [0];\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * Parse the value of a new Decimal `x` from a string `str`, which is not a decimal value.\r\n   */\r\n  function parseOther(x, str) {\r\n    var base, Ctor, divisor, i, isFloat, len, p, xd, xe;\r\n\r\n    if (str.indexOf('_') > -1) {\r\n      str = str.replace(/(\\d)_(?=\\d)/g, '$1');\r\n      if (isDecimal.test(str)) return parseDecimal(x, str);\r\n    } else if (str === 'Infinity' || str === 'NaN') {\r\n      if (!+str) x.s = NaN;\r\n      x.e = NaN;\r\n      x.d = null;\r\n      return x;\r\n    }\r\n\r\n    if (isHex.test(str))  {\r\n      base = 16;\r\n      str = str.toLowerCase();\r\n    } else if (isBinary.test(str))  {\r\n      base = 2;\r\n    } else if (isOctal.test(str))  {\r\n      base = 8;\r\n    } else {\r\n      throw Error(invalidArgument + str);\r\n    }\r\n\r\n    // Is there a binary exponent part?\r\n    i = str.search(/p/i);\r\n\r\n    if (i > 0) {\r\n      p = +str.slice(i + 1);\r\n      str = str.substring(2, i);\r\n    } else {\r\n      str = str.slice(2);\r\n    }\r\n\r\n    // Convert `str` as an integer then divide the result by `base` raised to a power such that the\r\n    // fraction part will be restored.\r\n    i = str.indexOf('.');\r\n    isFloat = i >= 0;\r\n    Ctor = x.constructor;\r\n\r\n    if (isFloat) {\r\n      str = str.replace('.', '');\r\n      len = str.length;\r\n      i = len - i;\r\n\r\n      // log[10](16) = 1.2041... , log[10](88) = 1.9444....\r\n      divisor = intPow(Ctor, new Ctor(base), i, i * 2);\r\n    }\r\n\r\n    xd = convertBase(str, base, BASE);\r\n    xe = xd.length - 1;\r\n\r\n    // Remove trailing zeros.\r\n    for (i = xe; xd[i] === 0; --i) xd.pop();\r\n    if (i < 0) return new Ctor(x.s * 0);\r\n    x.e = getBase10Exponent(xd, xe);\r\n    x.d = xd;\r\n    external = false;\r\n\r\n    // At what precision to perform the division to ensure exact conversion?\r\n    // maxDecimalIntegerPartDigitCount = ceil(log[10](b) * otherBaseIntegerPartDigitCount)\r\n    // log[10](2) = 0.30103, log[10](8) = 0.90309, log[10](16) = 1.20412\r\n    // E.g. ceil(1.2 * 3) = 4, so up to 4 decimal digits are needed to represent 3 hex int digits.\r\n    // maxDecimalFractionPartDigitCount = {Hex:4|Oct:3|Bin:1} * otherBaseFractionPartDigitCount\r\n    // Therefore using 4 * the number of digits of str will always be enough.\r\n    if (isFloat) x = divide(x, divisor, len * 4);\r\n\r\n    // Multiply by the binary exponent part if present.\r\n    if (p) x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));\r\n    external = true;\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * sin(x) = x - x^3/3! + x^5/5! - ...\r\n   * |x| < pi/2\r\n   *\r\n   */\r\n  function sine(Ctor, x) {\r\n    var k,\r\n      len = x.d.length;\r\n\r\n    if (len < 3) {\r\n      return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);\r\n    }\r\n\r\n    // Argument reduction: sin(5x) = 16*sin^5(x) - 20*sin^3(x) + 5*sin(x)\r\n    // i.e. sin(x) = 16*sin^5(x/5) - 20*sin^3(x/5) + 5*sin(x/5)\r\n    // and  sin(x) = sin(x/5)(5 + sin^2(x/5)(16sin^2(x/5) - 20))\r\n\r\n    // Estimate the optimum number of times to use the argument reduction.\r\n    k = 1.4 * Math.sqrt(len);\r\n    k = k > 16 ? 16 : k | 0;\r\n\r\n    x = x.times(1 / tinyPow(5, k));\r\n    x = taylorSeries(Ctor, 2, x, x);\r\n\r\n    // Reverse argument reduction\r\n    var sin2_x,\r\n      d5 = new Ctor(5),\r\n      d16 = new Ctor(16),\r\n      d20 = new Ctor(20);\r\n    for (; k--;) {\r\n      sin2_x = x.times(x);\r\n      x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  // Calculate Taylor series for `cos`, `cosh`, `sin` and `sinh`.\r\n  function taylorSeries(Ctor, n, x, y, isHyperbolic) {\r\n    var j, t, u, x2,\r\n      i = 1,\r\n      pr = Ctor.precision,\r\n      k = Math.ceil(pr / LOG_BASE);\r\n\r\n    external = false;\r\n    x2 = x.times(x);\r\n    u = new Ctor(y);\r\n\r\n    for (;;) {\r\n      t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);\r\n      u = isHyperbolic ? y.plus(t) : y.minus(t);\r\n      y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);\r\n      t = u.plus(y);\r\n\r\n      if (t.d[k] !== void 0) {\r\n        for (j = k; t.d[j] === u.d[j] && j--;);\r\n        if (j == -1) break;\r\n      }\r\n\r\n      j = u;\r\n      u = y;\r\n      y = t;\r\n      t = j;\r\n      i++;\r\n    }\r\n\r\n    external = true;\r\n    t.d.length = k + 1;\r\n\r\n    return t;\r\n  }\r\n\r\n\r\n  // Exponent e must be positive and non-zero.\r\n  function tinyPow(b, e) {\r\n    var n = b;\r\n    while (--e) n *= b;\r\n    return n;\r\n  }\r\n\r\n\r\n  // Return the absolute value of `x` reduced to less than or equal to half pi.\r\n  function toLessThanHalfPi(Ctor, x) {\r\n    var t,\r\n      isNeg = x.s < 0,\r\n      pi = getPi(Ctor, Ctor.precision, 1),\r\n      halfPi = pi.times(0.5);\r\n\r\n    x = x.abs();\r\n\r\n    if (x.lte(halfPi)) {\r\n      quadrant = isNeg ? 4 : 1;\r\n      return x;\r\n    }\r\n\r\n    t = x.divToInt(pi);\r\n\r\n    if (t.isZero()) {\r\n      quadrant = isNeg ? 3 : 2;\r\n    } else {\r\n      x = x.minus(t.times(pi));\r\n\r\n      // 0 <= x < pi\r\n      if (x.lte(halfPi)) {\r\n        quadrant = isOdd(t) ? (isNeg ? 2 : 3) : (isNeg ? 4 : 1);\r\n        return x;\r\n      }\r\n\r\n      quadrant = isOdd(t) ? (isNeg ? 1 : 4) : (isNeg ? 3 : 2);\r\n    }\r\n\r\n    return x.minus(pi).abs();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return the value of Decimal `x` as a string in base `baseOut`.\r\n   *\r\n   * If the optional `sd` argument is present include a binary exponent suffix.\r\n   */\r\n  function toStringBinary(x, baseOut, sd, rm) {\r\n    var base, e, i, k, len, roundUp, str, xd, y,\r\n      Ctor = x.constructor,\r\n      isExp = sd !== void 0;\r\n\r\n    if (isExp) {\r\n      checkInt32(sd, 1, MAX_DIGITS);\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n    } else {\r\n      sd = Ctor.precision;\r\n      rm = Ctor.rounding;\r\n    }\r\n\r\n    if (!x.isFinite()) {\r\n      str = nonFiniteToString(x);\r\n    } else {\r\n      str = finiteToString(x);\r\n      i = str.indexOf('.');\r\n\r\n      // Use exponential notation according to `toExpPos` and `toExpNeg`? No, but if required:\r\n      // maxBinaryExponent = floor((decimalExponent + 1) * log[2](10))\r\n      // minBinaryExponent = floor(decimalExponent * log[2](10))\r\n      // log[2](10) = 3.321928094887362347870319429489390175864\r\n\r\n      if (isExp) {\r\n        base = 2;\r\n        if (baseOut == 16) {\r\n          sd = sd * 4 - 3;\r\n        } else if (baseOut == 8) {\r\n          sd = sd * 3 - 2;\r\n        }\r\n      } else {\r\n        base = baseOut;\r\n      }\r\n\r\n      // Convert the number as an integer then divide the result by its base raised to a power such\r\n      // that the fraction part will be restored.\r\n\r\n      // Non-integer.\r\n      if (i >= 0) {\r\n        str = str.replace('.', '');\r\n        y = new Ctor(1);\r\n        y.e = str.length - i;\r\n        y.d = convertBase(finiteToString(y), 10, base);\r\n        y.e = y.d.length;\r\n      }\r\n\r\n      xd = convertBase(str, 10, base);\r\n      e = len = xd.length;\r\n\r\n      // Remove trailing zeros.\r\n      for (; xd[--len] == 0;) xd.pop();\r\n\r\n      if (!xd[0]) {\r\n        str = isExp ? '0p+0' : '0';\r\n      } else {\r\n        if (i < 0) {\r\n          e--;\r\n        } else {\r\n          x = new Ctor(x);\r\n          x.d = xd;\r\n          x.e = e;\r\n          x = divide(x, y, sd, rm, 0, base);\r\n          xd = x.d;\r\n          e = x.e;\r\n          roundUp = inexact;\r\n        }\r\n\r\n        // The rounding digit, i.e. the digit after the digit that may be rounded up.\r\n        i = xd[sd];\r\n        k = base / 2;\r\n        roundUp = roundUp || xd[sd + 1] !== void 0;\r\n\r\n        roundUp = rm < 4\r\n          ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2))\r\n          : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 ||\r\n            rm === (x.s < 0 ? 8 : 7));\r\n\r\n        xd.length = sd;\r\n\r\n        if (roundUp) {\r\n\r\n          // Rounding up may mean the previous digit has to be rounded up and so on.\r\n          for (; ++xd[--sd] > base - 1;) {\r\n            xd[sd] = 0;\r\n            if (!sd) {\r\n              ++e;\r\n              xd.unshift(1);\r\n            }\r\n          }\r\n        }\r\n\r\n        // Determine trailing zeros.\r\n        for (len = xd.length; !xd[len - 1]; --len);\r\n\r\n        // E.g. [4, 11, 15] becomes 4bf.\r\n        for (i = 0, str = ''; i < len; i++) str += NUMERALS.charAt(xd[i]);\r\n\r\n        // Add binary exponent suffix?\r\n        if (isExp) {\r\n          if (len > 1) {\r\n            if (baseOut == 16 || baseOut == 8) {\r\n              i = baseOut == 16 ? 4 : 3;\r\n              for (--len; len % i; len++) str += '0';\r\n              xd = convertBase(str, base, baseOut);\r\n              for (len = xd.length; !xd[len - 1]; --len);\r\n\r\n              // xd[0] will always be be 1\r\n              for (i = 1, str = '1.'; i < len; i++) str += NUMERALS.charAt(xd[i]);\r\n            } else {\r\n              str = str.charAt(0) + '.' + str.slice(1);\r\n            }\r\n          }\r\n\r\n          str =  str + (e < 0 ? 'p' : 'p+') + e;\r\n        } else if (e < 0) {\r\n          for (; ++e;) str = '0' + str;\r\n          str = '0.' + str;\r\n        } else {\r\n          if (++e > len) for (e -= len; e-- ;) str += '0';\r\n          else if (e < len) str = str.slice(0, e) + '.' + str.slice(e);\r\n        }\r\n      }\r\n\r\n      str = (baseOut == 16 ? '0x' : baseOut == 2 ? '0b' : baseOut == 8 ? '0o' : '') + str;\r\n    }\r\n\r\n    return x.s < 0 ? '-' + str : str;\r\n  }\r\n\r\n\r\n  // Does not strip trailing zeros.\r\n  function truncate(arr, len) {\r\n    if (arr.length > len) {\r\n      arr.length = len;\r\n      return true;\r\n    }\r\n  }\r\n\r\n\r\n  // Decimal methods\r\n\r\n\r\n  /*\r\n   *  abs\r\n   *  acos\r\n   *  acosh\r\n   *  add\r\n   *  asin\r\n   *  asinh\r\n   *  atan\r\n   *  atanh\r\n   *  atan2\r\n   *  cbrt\r\n   *  ceil\r\n   *  clamp\r\n   *  clone\r\n   *  config\r\n   *  cos\r\n   *  cosh\r\n   *  div\r\n   *  exp\r\n   *  floor\r\n   *  hypot\r\n   *  ln\r\n   *  log\r\n   *  log2\r\n   *  log10\r\n   *  max\r\n   *  min\r\n   *  mod\r\n   *  mul\r\n   *  pow\r\n   *  random\r\n   *  round\r\n   *  set\r\n   *  sign\r\n   *  sin\r\n   *  sinh\r\n   *  sqrt\r\n   *  sub\r\n   *  sum\r\n   *  tan\r\n   *  tanh\r\n   *  trunc\r\n   */\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the absolute value of `x`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function abs(x) {\r\n    return new this(x).abs();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arccosine in radians of `x`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function acos(x) {\r\n    return new this(x).acos();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic cosine of `x`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function acosh(x) {\r\n    return new this(x).acosh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the sum of `x` and `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function add(x, y) {\r\n    return new this(x).plus(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arcsine in radians of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function asin(x) {\r\n    return new this(x).asin();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic sine of `x`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function asinh(x) {\r\n    return new this(x).asinh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arctangent in radians of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function atan(x) {\r\n    return new this(x).atan();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic tangent of `x`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function atanh(x) {\r\n    return new this(x).atanh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arctangent in radians of `y/x` in the range -pi to pi\r\n   * (inclusive), rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-pi, pi]\r\n   *\r\n   * y {number|string|Decimal} The y-coordinate.\r\n   * x {number|string|Decimal} The x-coordinate.\r\n   *\r\n   * atan2(0, -0)               = pi\r\n   * atan2(0, +0)               = 0\r\n   * atan2(0, -x)               = pi for x > 0\r\n   * atan2(0, x)                = 0 for x > 0\r\n   * atan2(-y, 0)               = -pi/2 for y > 0\r\n   * atan2(y, 0)                = pi/2 for y > 0\r\n   * atan2(y, -Infinity)        = pi for finite y > 0\r\n   * atan2(y, +Infinity)        = 0 for finite y > 0\r\n   * atan2(Infinity, x)         = pi/2 for finite x\r\n   * atan2(Infinity, -Infinity) = 3*pi/4\r\n   * atan2(Infinity, +Infinity) = pi/4\r\n   * atan2(NaN, x) = NaN\r\n   * atan2(y, NaN) = NaN\r\n   *\r\n   */\r\n  function atan2(y, x) {\r\n    y = new this(y);\r\n    x = new this(x);\r\n    var r,\r\n      pr = this.precision,\r\n      rm = this.rounding,\r\n      wpr = pr + 4;\r\n\r\n    // Either NaN\r\n    if (!y.s || !x.s) {\r\n      r = new this(NaN);\r\n\r\n    // Both Infinity\r\n    } else if (!y.d && !x.d) {\r\n      r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);\r\n      r.s = y.s;\r\n\r\n    // x is Infinity or y is 0\r\n    } else if (!x.d || y.isZero()) {\r\n      r = x.s < 0 ? getPi(this, pr, rm) : new this(0);\r\n      r.s = y.s;\r\n\r\n    // y is Infinity or x is 0\r\n    } else if (!y.d || x.isZero()) {\r\n      r = getPi(this, wpr, 1).times(0.5);\r\n      r.s = y.s;\r\n\r\n    // Both non-zero and finite\r\n    } else if (x.s < 0) {\r\n      this.precision = wpr;\r\n      this.rounding = 1;\r\n      r = this.atan(divide(y, x, wpr, 1));\r\n      x = getPi(this, wpr, 1);\r\n      this.precision = pr;\r\n      this.rounding = rm;\r\n      r = y.s < 0 ? r.minus(x) : r.plus(x);\r\n    } else {\r\n      r = this.atan(divide(y, x, wpr, 1));\r\n    }\r\n\r\n    return r;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the cube root of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function cbrt(x) {\r\n    return new this(x).cbrt();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` rounded to an integer using `ROUND_CEIL`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function ceil(x) {\r\n    return finalise(x = new this(x), x.e + 1, 2);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` clamped to the range delineated by `min` and `max`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * min {number|string|Decimal}\r\n   * max {number|string|Decimal}\r\n   *\r\n   */\r\n  function clamp(x, min, max) {\r\n    return new this(x).clamp(min, max);\r\n  }\r\n\r\n\r\n  /*\r\n   * Configure global settings for a Decimal constructor.\r\n   *\r\n   * `obj` is an object with one or more of the following properties,\r\n   *\r\n   *   precision  {number}\r\n   *   rounding   {number}\r\n   *   toExpNeg   {number}\r\n   *   toExpPos   {number}\r\n   *   maxE       {number}\r\n   *   minE       {number}\r\n   *   modulo     {number}\r\n   *   crypto     {boolean|number}\r\n   *   defaults   {true}\r\n   *\r\n   * E.g. Decimal.config({ precision: 20, rounding: 4 })\r\n   *\r\n   */\r\n  function config(obj) {\r\n    if (!obj || typeof obj !== 'object') throw Error(decimalError + 'Object expected');\r\n    var i, p, v,\r\n      useDefaults = obj.defaults === true,\r\n      ps = [\r\n        'precision', 1, MAX_DIGITS,\r\n        'rounding', 0, 8,\r\n        'toExpNeg', -EXP_LIMIT, 0,\r\n        'toExpPos', 0, EXP_LIMIT,\r\n        'maxE', 0, EXP_LIMIT,\r\n        'minE', -EXP_LIMIT, 0,\r\n        'modulo', 0, 9\r\n      ];\r\n\r\n    for (i = 0; i < ps.length; i += 3) {\r\n      if (p = ps[i], useDefaults) this[p] = DEFAULTS[p];\r\n      if ((v = obj[p]) !== void 0) {\r\n        if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;\r\n        else throw Error(invalidArgument + p + ': ' + v);\r\n      }\r\n    }\r\n\r\n    if (p = 'crypto', useDefaults) this[p] = DEFAULTS[p];\r\n    if ((v = obj[p]) !== void 0) {\r\n      if (v === true || v === false || v === 0 || v === 1) {\r\n        if (v) {\r\n          if (typeof crypto != 'undefined' && crypto &&\r\n            (crypto.getRandomValues || crypto.randomBytes)) {\r\n            this[p] = true;\r\n          } else {\r\n            throw Error(cryptoUnavailable);\r\n          }\r\n        } else {\r\n          this[p] = false;\r\n        }\r\n      } else {\r\n        throw Error(invalidArgument + p + ': ' + v);\r\n      }\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the cosine of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function cos(x) {\r\n    return new this(x).cos();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic cosine of `x`, rounded to precision\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function cosh(x) {\r\n    return new this(x).cosh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Create and return a Decimal constructor with the same configuration properties as this Decimal\r\n   * constructor.\r\n   *\r\n   */\r\n  function clone(obj) {\r\n    var i, p, ps;\r\n\r\n    /*\r\n     * The Decimal constructor and exported function.\r\n     * Return a new Decimal instance.\r\n     *\r\n     * v {number|string|Decimal} A numeric value.\r\n     *\r\n     */\r\n    function Decimal(v) {\r\n      var e, i, t,\r\n        x = this;\r\n\r\n      // Decimal called without new.\r\n      if (!(x instanceof Decimal)) return new Decimal(v);\r\n\r\n      // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor\r\n      // which points to Object.\r\n      x.constructor = Decimal;\r\n\r\n      // Duplicate.\r\n      if (isDecimalInstance(v)) {\r\n        x.s = v.s;\r\n\r\n        if (external) {\r\n          if (!v.d || v.e > Decimal.maxE) {\r\n\r\n            // Infinity.\r\n            x.e = NaN;\r\n            x.d = null;\r\n          } else if (v.e < Decimal.minE) {\r\n\r\n            // Zero.\r\n            x.e = 0;\r\n            x.d = [0];\r\n          } else {\r\n            x.e = v.e;\r\n            x.d = v.d.slice();\r\n          }\r\n        } else {\r\n          x.e = v.e;\r\n          x.d = v.d ? v.d.slice() : v.d;\r\n        }\r\n\r\n        return;\r\n      }\r\n\r\n      t = typeof v;\r\n\r\n      if (t === 'number') {\r\n        if (v === 0) {\r\n          x.s = 1 / v < 0 ? -1 : 1;\r\n          x.e = 0;\r\n          x.d = [0];\r\n          return;\r\n        }\r\n\r\n        if (v < 0) {\r\n          v = -v;\r\n          x.s = -1;\r\n        } else {\r\n          x.s = 1;\r\n        }\r\n\r\n        // Fast path for small integers.\r\n        if (v === ~~v && v < 1e7) {\r\n          for (e = 0, i = v; i >= 10; i /= 10) e++;\r\n\r\n          if (external) {\r\n            if (e > Decimal.maxE) {\r\n              x.e = NaN;\r\n              x.d = null;\r\n            } else if (e < Decimal.minE) {\r\n              x.e = 0;\r\n              x.d = [0];\r\n            } else {\r\n              x.e = e;\r\n              x.d = [v];\r\n            }\r\n          } else {\r\n            x.e = e;\r\n            x.d = [v];\r\n          }\r\n\r\n          return;\r\n\r\n        // Infinity, NaN.\r\n        } else if (v * 0 !== 0) {\r\n          if (!v) x.s = NaN;\r\n          x.e = NaN;\r\n          x.d = null;\r\n          return;\r\n        }\r\n\r\n        return parseDecimal(x, v.toString());\r\n\r\n      } else if (t !== 'string') {\r\n        throw Error(invalidArgument + v);\r\n      }\r\n\r\n      // Minus sign?\r\n      if ((i = v.charCodeAt(0)) === 45) {\r\n        v = v.slice(1);\r\n        x.s = -1;\r\n      } else {\r\n        // Plus sign?\r\n        if (i === 43) v = v.slice(1);\r\n        x.s = 1;\r\n      }\r\n\r\n      return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);\r\n    }\r\n\r\n    Decimal.prototype = P;\r\n\r\n    Decimal.ROUND_UP = 0;\r\n    Decimal.ROUND_DOWN = 1;\r\n    Decimal.ROUND_CEIL = 2;\r\n    Decimal.ROUND_FLOOR = 3;\r\n    Decimal.ROUND_HALF_UP = 4;\r\n    Decimal.ROUND_HALF_DOWN = 5;\r\n    Decimal.ROUND_HALF_EVEN = 6;\r\n    Decimal.ROUND_HALF_CEIL = 7;\r\n    Decimal.ROUND_HALF_FLOOR = 8;\r\n    Decimal.EUCLID = 9;\r\n\r\n    Decimal.config = Decimal.set = config;\r\n    Decimal.clone = clone;\r\n    Decimal.isDecimal = isDecimalInstance;\r\n\r\n    Decimal.abs = abs;\r\n    Decimal.acos = acos;\r\n    Decimal.acosh = acosh;        // ES6\r\n    Decimal.add = add;\r\n    Decimal.asin = asin;\r\n    Decimal.asinh = asinh;        // ES6\r\n    Decimal.atan = atan;\r\n    Decimal.atanh = atanh;        // ES6\r\n    Decimal.atan2 = atan2;\r\n    Decimal.cbrt = cbrt;          // ES6\r\n    Decimal.ceil = ceil;\r\n    Decimal.clamp = clamp;\r\n    Decimal.cos = cos;\r\n    Decimal.cosh = cosh;          // ES6\r\n    Decimal.div = div;\r\n    Decimal.exp = exp;\r\n    Decimal.floor = floor;\r\n    Decimal.hypot = hypot;        // ES6\r\n    Decimal.ln = ln;\r\n    Decimal.log = log;\r\n    Decimal.log10 = log10;        // ES6\r\n    Decimal.log2 = log2;          // ES6\r\n    Decimal.max = max;\r\n    Decimal.min = min;\r\n    Decimal.mod = mod;\r\n    Decimal.mul = mul;\r\n    Decimal.pow = pow;\r\n    Decimal.random = random;\r\n    Decimal.round = round;\r\n    Decimal.sign = sign;          // ES6\r\n    Decimal.sin = sin;\r\n    Decimal.sinh = sinh;          // ES6\r\n    Decimal.sqrt = sqrt;\r\n    Decimal.sub = sub;\r\n    Decimal.sum = sum;\r\n    Decimal.tan = tan;\r\n    Decimal.tanh = tanh;          // ES6\r\n    Decimal.trunc = trunc;        // ES6\r\n\r\n    if (obj === void 0) obj = {};\r\n    if (obj) {\r\n      if (obj.defaults !== true) {\r\n        ps = ['precision', 'rounding', 'toExpNeg', 'toExpPos', 'maxE', 'minE', 'modulo', 'crypto'];\r\n        for (i = 0; i < ps.length;) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];\r\n      }\r\n    }\r\n\r\n    Decimal.config(obj);\r\n\r\n    return Decimal;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` divided by `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function div(x, y) {\r\n    return new this(x).div(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural exponential of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} The power to which to raise the base of the natural log.\r\n   *\r\n   */\r\n  function exp(x) {\r\n    return new this(x).exp();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` round to an integer using `ROUND_FLOOR`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function floor(x) {\r\n    return finalise(x = new this(x), x.e + 1, 3);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the square root of the sum of the squares of the arguments,\r\n   * rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * hypot(a, b, ...) = sqrt(a^2 + b^2 + ...)\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n   */\r\n  function hypot() {\r\n    var i, n,\r\n      t = new this(0);\r\n\r\n    external = false;\r\n\r\n    for (i = 0; i < arguments.length;) {\r\n      n = new this(arguments[i++]);\r\n      if (!n.d) {\r\n        if (n.s) {\r\n          external = true;\r\n          return new this(1 / 0);\r\n        }\r\n        t = n;\r\n      } else if (t.d) {\r\n        t = t.plus(n.times(n));\r\n      }\r\n    }\r\n\r\n    external = true;\r\n\r\n    return t.sqrt();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return true if object is a Decimal instance (where Decimal is any Decimal constructor),\r\n   * otherwise return false.\r\n   *\r\n   */\r\n  function isDecimalInstance(obj) {\r\n    return obj instanceof Decimal || obj && obj.toStringTag === tag || false;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural logarithm of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function ln(x) {\r\n    return new this(x).ln();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the log of `x` to the base `y`, or to base 10 if no base\r\n   * is specified, rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * log[y](x)\r\n   *\r\n   * x {number|string|Decimal} The argument of the logarithm.\r\n   * y {number|string|Decimal} The base of the logarithm.\r\n   *\r\n   */\r\n  function log(x, y) {\r\n    return new this(x).log(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the base 2 logarithm of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function log2(x) {\r\n    return new this(x).log(2);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the base 10 logarithm of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function log10(x) {\r\n    return new this(x).log(10);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the maximum of the arguments.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n   */\r\n  function max() {\r\n    return maxOrMin(this, arguments, 'lt');\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the minimum of the arguments.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n   */\r\n  function min() {\r\n    return maxOrMin(this, arguments, 'gt');\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` modulo `y`, rounded to `precision` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function mod(x, y) {\r\n    return new this(x).mod(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` multiplied by `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function mul(x, y) {\r\n    return new this(x).mul(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` raised to the power `y`, rounded to precision\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} The base.\r\n   * y {number|string|Decimal} The exponent.\r\n   *\r\n   */\r\n  function pow(x, y) {\r\n    return new this(x).pow(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Returns a new Decimal with a random value equal to or greater than 0 and less than 1, and with\r\n   * `sd`, or `Decimal.precision` if `sd` is omitted, significant digits (or less if trailing zeros\r\n   * are produced).\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 0 to MAX_DIGITS inclusive.\r\n   *\r\n   */\r\n  function random(sd) {\r\n    var d, e, k, n,\r\n      i = 0,\r\n      r = new this(1),\r\n      rd = [];\r\n\r\n    if (sd === void 0) sd = this.precision;\r\n    else checkInt32(sd, 1, MAX_DIGITS);\r\n\r\n    k = Math.ceil(sd / LOG_BASE);\r\n\r\n    if (!this.crypto) {\r\n      for (; i < k;) rd[i++] = Math.random() * 1e7 | 0;\r\n\r\n    // Browsers supporting crypto.getRandomValues.\r\n    } else if (crypto.getRandomValues) {\r\n      d = crypto.getRandomValues(new Uint32Array(k));\r\n\r\n      for (; i < k;) {\r\n        n = d[i];\r\n\r\n        // 0 <= n < 4294967296\r\n        // Probability n >= 4.29e9, is 4967296 / 4294967296 = 0.00116 (1 in 865).\r\n        if (n >= 4.29e9) {\r\n          d[i] = crypto.getRandomValues(new Uint32Array(1))[0];\r\n        } else {\r\n\r\n          // 0 <= n <= 4289999999\r\n          // 0 <= (n % 1e7) <= 9999999\r\n          rd[i++] = n % 1e7;\r\n        }\r\n      }\r\n\r\n    // Node.js supporting crypto.randomBytes.\r\n    } else if (crypto.randomBytes) {\r\n\r\n      // buffer\r\n      d = crypto.randomBytes(k *= 4);\r\n\r\n      for (; i < k;) {\r\n\r\n        // 0 <= n < 2147483648\r\n        n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 0x7f) << 24);\r\n\r\n        // Probability n >= 2.14e9, is 7483648 / 2147483648 = 0.0035 (1 in 286).\r\n        if (n >= 2.14e9) {\r\n          crypto.randomBytes(4).copy(d, i);\r\n        } else {\r\n\r\n          // 0 <= n <= 2139999999\r\n          // 0 <= (n % 1e7) <= 9999999\r\n          rd.push(n % 1e7);\r\n          i += 4;\r\n        }\r\n      }\r\n\r\n      i = k / 4;\r\n    } else {\r\n      throw Error(cryptoUnavailable);\r\n    }\r\n\r\n    k = rd[--i];\r\n    sd %= LOG_BASE;\r\n\r\n    // Convert trailing digits to zeros according to sd.\r\n    if (k && sd) {\r\n      n = mathpow(10, LOG_BASE - sd);\r\n      rd[i] = (k / n | 0) * n;\r\n    }\r\n\r\n    // Remove trailing words which are zero.\r\n    for (; rd[i] === 0; i--) rd.pop();\r\n\r\n    // Zero?\r\n    if (i < 0) {\r\n      e = 0;\r\n      rd = [0];\r\n    } else {\r\n      e = -1;\r\n\r\n      // Remove leading words which are zero and adjust exponent accordingly.\r\n      for (; rd[0] === 0; e -= LOG_BASE) rd.shift();\r\n\r\n      // Count the digits of the first word of rd to determine leading zeros.\r\n      for (k = 1, n = rd[0]; n >= 10; n /= 10) k++;\r\n\r\n      // Adjust the exponent for leading zeros of the first word of rd.\r\n      if (k < LOG_BASE) e -= LOG_BASE - k;\r\n    }\r\n\r\n    r.e = e;\r\n    r.d = rd;\r\n\r\n    return r;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` rounded to an integer using rounding mode `rounding`.\r\n   *\r\n   * To emulate `Math.round`, set rounding to 7 (ROUND_HALF_CEIL).\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function round(x) {\r\n    return finalise(x = new this(x), x.e + 1, this.rounding);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return\r\n   *   1    if x > 0,\r\n   *  -1    if x < 0,\r\n   *   0    if x is 0,\r\n   *  -0    if x is -0,\r\n   *   NaN  otherwise\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function sign(x) {\r\n    x = new this(x);\r\n    return x.d ? (x.d[0] ? x.s : 0 * x.s) : x.s || NaN;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the sine of `x`, rounded to `precision` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function sin(x) {\r\n    return new this(x).sin();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic sine of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function sinh(x) {\r\n    return new this(x).sinh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the square root of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function sqrt(x) {\r\n    return new this(x).sqrt();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` minus `y`, rounded to `precision` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function sub(x, y) {\r\n    return new this(x).sub(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the sum of the arguments, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * Only the result is rounded, not the intermediate calculations.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n   */\r\n  function sum() {\r\n    var i = 0,\r\n      args = arguments,\r\n      x = new this(args[i]);\r\n\r\n    external = false;\r\n    for (; x.s && ++i < args.length;) x = x.plus(args[i]);\r\n    external = true;\r\n\r\n    return finalise(x, this.precision, this.rounding);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the tangent of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function tan(x) {\r\n    return new this(x).tan();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic tangent of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function tanh(x) {\r\n    return new this(x).tanh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` truncated to an integer.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function trunc(x) {\r\n    return finalise(x = new this(x), x.e + 1, 1);\r\n  }\r\n\r\n\r\n  // Create and configure initial Decimal constructor.\r\n  Decimal = clone(DEFAULTS);\r\n  Decimal.prototype.constructor = Decimal;\r\n  Decimal['default'] = Decimal.Decimal = Decimal;\r\n\r\n  // Create the internal constants from their string values.\r\n  LN10 = new Decimal(LN10);\r\n  PI = new Decimal(PI);\r\n\r\n\r\n  // Export.\r\n\r\n\r\n  // AMD.\r\n  if (typeof define == 'function' && define.amd) {\r\n    define(function () {\r\n      return Decimal;\r\n    });\r\n\r\n  // Node and other environments that support module.exports.\r\n  } else if (typeof module != 'undefined' && module.exports) {\r\n    if (typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol') {\r\n      P[Symbol['for']('nodejs.util.inspect.custom')] = P.toString;\r\n      P[Symbol.toStringTag] = 'Decimal';\r\n    }\r\n\r\n    module.exports = Decimal;\r\n\r\n  // Browser.\r\n  } else {\r\n    if (!globalScope) {\r\n      globalScope = typeof self != 'undefined' && self && self.self == self ? self : window;\r\n    }\r\n\r\n    noConflict = globalScope.Decimal;\r\n    Decimal.noConflict = function () {\r\n      globalScope.Decimal = noConflict;\r\n      return Decimal;\r\n    };\r\n\r\n    globalScope.Decimal = Decimal;\r\n  }\r\n})(this);\r\n",null,"/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\n/**\n* Instruction Set Bace Class.\n*\n* @class ElucidatorInstructionSet\n*/\nclass ElucidatorInstructionSet\n{\n    constructor(pElucidator)\n    {\n        this.elucidator = pElucidator;\n\n        this.namespace = 'default';\n    }\n\n    // Create an empty namespace for instructions and operations if either one doesn't exist\n    initializeNamespace(pNamespace)\n    {\n        if (typeof(pNamespace) == 'string')\n        {\n            this.namespace = pNamespace;\n        }\n        if (!this.elucidator.instructionSets.hasOwnProperty(this.namespace))\n        {\n            this.elucidator.instructionSets[this.namespace.toLowerCase()] = {};\n        }\n        if (!this.elucidator.operationSets.hasOwnProperty(this.namespace))\n        {\n            this.elucidator.operationSets[this.namespace.toLowerCase()] = {};\n        }\n    }\n\n    // Add an instruction to the set\n    addInstruction(pInstructionHash, fInstructionFunction)\n    {\n        if (typeof(pInstructionHash) != 'string')\n        {\n            this.elucidator.logError(`Attempted to add an instruction with an invalid hash; expected a string but the instruction hash type was ${typeof(pInstructionHash)}`);\n            return false;\n        }\n        if (typeof(fInstructionFunction) != 'function')\n        {\n            this.elucidator.logError(`Attempted to add an instruction with an invalid function; expected a function but type was ${typeof(fInstructionFunction)}`);\n            return false;\n        }\n\n        this.elucidator.instructionSets[this.namespace.toLowerCase()][pInstructionHash] = fInstructionFunction;\n        return true;\n    }\n\n    initializeInstructions()\n    {\n        // This is where we map in the instructions.\n        // If the extending class calls super it will inject a harmless noop into the scope.\n        // It isn't recommended to do these inline as lambdas, but this code is generally not expected to be called.\n        // Unless the developer wants a noop in their instruction set...........\n        this.addInstruction('noop', \n            (pOperation) =>\n            {\n                pOperation.logInfo('Executing a no-operation operation.');\n                return true;\n            });\n\n        return true;\n    }\n\n    // Add an operation to the set\n    addOperation(pOperationHash, pOperation)\n    {\n        if (typeof(pOperationHash) != 'string')\n        {\n            this.elucidator.logError(`Attempted to add an operation with an invalid hash; expected a string but the operation hash type was ${typeof(pOperationHash)}`, pOperation);\n            return false;\n        }\n        if (typeof(pOperation) != 'object')\n        {\n            this.elucidator.logError(`Attempted to add an invalid operation; expected an object data type but the type was ${typeof(pOperation)}`, pOperation);\n            return false;\n        }\n        // Validate the Description subobject, which is key to functioning.\n        if (!pOperation.hasOwnProperty(\"Description\"))\n        {\n            this.elucidator.logError(`Attempted to add an operation with an invalid description; no Description subobject set.`, pOperation);\n            return false;\n        }\n        if (typeof(pOperation.Description) != 'object')\n        {\n            this.elucidator.logError(`Attempted to add an operation with an invalid description; Description subobject was not an object.  The type was ${typeof(pOperation.Description)}.`, pOperation);\n            return false;\n        }\n        if (typeof(pOperation.Description.Hash) != 'string')\n        {\n            if (typeof(pOperation.Description.Operation) == 'string')\n            {\n                // Use the \"Operation\" as the \"Hash\"\n                pOperation.Description.Hash = pOperation.Description.Operation;\n            }\n            else\n            {\n                this.elucidator.logError(`Attempted to add an operation with an invalid description; Description subobject did not contain a valid Hash which is required to call the operation.`, pOperation);\n                return false;\n            }\n        }\n\n        // Now auto create data if it is missing or wrong in the Description\n        if ((typeof(pOperation.Description.Namespace) != 'string') || (pOperation.Description.Namespace != this.namespace))\n        {\n            pOperation.Description.Namespace = this.namespace;\n        }\n        if (typeof(pOperation.Description.Summary) != 'string')\n        {\n            pOperation.Description.Summary = `[${pOperation.Description.Namespace}] [${pOperation.Description.Hash}] operation.`;\n        }\n\n        // If there are no inputs, or outputs, or steps, add them.\n        if (!pOperation.hasOwnProperty('Inputs'))\n        {\n            pOperation.Inputs = {};\n        }\n        if (!pOperation.hasOwnProperty('Outputs'))\n        {\n            pOperation.Outputs = {};\n        }\n        if (!pOperation.hasOwnProperty('Steps'))\n        {\n            pOperation.Steps = [];\n        }\n\n        // If there are no inputs, or outputs, or steps, add them.\n        // TODO: Add a step where we try to load this into Manyfest and see that it's valid.\n        if (typeof(pOperation.Inputs) !== 'object')\n        {\n            this.elucidator.logError(`Attempted to add an operation with an invalid Inputs object.`, pOperation);\n            return false;\n        }\n        // If there are no inputs, or outputs, or steps, add them.\n        // TODO: Add a step where we try to load this into Manyfest and see that it's valid.\n        if (typeof(pOperation.Outputs) !== 'object')\n        {\n            this.elucidator.logError(`Attempted to add an operation with an invalid Outputs object.`, pOperation);\n            return false;\n        }\n        if (!Array.isArray(pOperation.Steps))\n        {\n            this.elucidator.logError(`Attempted to add an operation with an invalid Steps array.`, pOperation);\n            return false;\n        }\n\n\n        this.elucidator.operationSets[this.namespace.toLowerCase()][pOperationHash.toLowerCase()] = pOperation;\n        return true;\n    }\n\n    initializeOperations()\n    {\n        this.addOperation('noop', \n            {\n                \"Description\":\n                {\n                    \"Operation\": \"noop\",\n                    \"Description\": \"No operation - no affect on any data.\"\n                }\n            });\n\n        return true;\n    }\n};\n\nmodule.exports = ElucidatorInstructionSet;","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\n/**\n* Elucidator simple logging shim (for browser and dependency-free running)\n*/\n\nconst logToConsole = (pLogLine, pLogObject, pLogLevel) =>\n{\n    let tmpLogLine = (typeof(pLogLine) === 'string') ? pLogLine : '';\n    let tmpLogLevel = (typeof(pLogLevel) === 'string') ? pLogLevel : 'INFO';\n\n    console.log(`[Elucidator:${tmpLogLevel}] ${tmpLogLine}`);\n\n    if (pLogObject) console.log(JSON.stringify(pLogObject,null,4)+\"\\n\");\n};\n\nconst logInfo = (pLogLine, pLogObject) =>\n{\n    logToConsole(pLogLine, pLogObject, 'Info');\n};\n\n\nconst logWarning = (pLogLine, pLogObject) =>\n{\n    logToConsole(pLogLine, pLogObject, 'Warning');\n};\n\n\nconst logError = (pLogLine, pLogObject) =>\n{\n    logToConsole(pLogLine, pLogObject, 'Error');\n};\n\nmodule.exports = (\n{\n    logToConsole: logToConsole,\n    info: logInfo,\n    warning: logWarning,\n    error: logError\n});","// Solution providers are meant to be stateless, and not classes.\n// These solution providers are akin to drivers, connecting code libraries or \n// other types of behavior to mapping operations.\n\nlet libElucidatorInstructionSet = require('../Elucidator-InstructionSet.js');\n\nclass Geometry extends libElucidatorInstructionSet\n{\n    constructor(pElucidator)\n    {\n        super(pElucidator);\n        this.namespace = 'Geometry';\n    }\n\n    // Geometry provides no instructions\n    initializeInstructions()\n    {\n        return true;\n    }\n\n    initializeOperations()\n    {\n        this.addOperation('rectanglearea', require(`./Operations/Geometry-RectangleArea.json`));\n\n        return true;\n    }\n}\n\nmodule.exports = Geometry;","// Solution providers are meant to be stateless, and not classes.\n// These solution providers are akin to drivers, connecting code libraries or \n// other types of behavior to mapping operations.\n\nlet libElucidatorInstructionSet = require('../Elucidator-InstructionSet.js');\n\nconst ifInstruction = (pOperation) =>\n{\n    let tmpLeftValue = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'leftValue');\n    let tmpRightValue = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'rightValue');\n    let tmpComparator = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'comparator').toString().toLowerCase();\n\n    let tmpComparisonOperator = 'equal';\n\n    // This may eventually come from configuration; for now just leave it here.\n    let tmpComparisonOperatorMapping = (\n        {\n            '==':'equal',\n            'eq':'equal',\n            'equal':'equal',\n\n            '!=':'notequal',\n            'noteq':'notequal',\n            'notequal':'notequal',\n\n            '===':'identity',\n            'id':'identity',\n            'identity':'identity',\n\n            '>':'greaterthan',\n            'gt':'greaterthan',\n            'greaterthan':'greaterthan',\n\n            '>=':'greaterthanorequal',\n            'gte':'greaterthanorequal',\n            'greaterthanorequal':'greaterthanorequal',\n\n            '<':'lessthan',\n            'lt':'lessthan',\n            'lessthan':'lessthan',\n\n            '<=':'lessthanorequal',\n            'lte':'lessthanorequal',\n            'lessthanorequal':'lessthanorequal'\n        });\n\n    if (tmpComparisonOperatorMapping.hasOwnProperty(tmpComparator))\n    {\n        tmpComparisonOperator = tmpComparisonOperatorMapping[tmpComparator];\n    }\n\n    let tmpTrueNamespace = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'trueNamespace');\n    let tmpTrueOperation = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'trueOperation');\n\n    let tmpFalseNamespace = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'falseNamespace');\n    let tmpFalseOperation = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'falseOperation');\n\n    let tmpTruthiness = null;\n\n    switch(tmpComparisonOperator)\n    {\n        case 'equal':\n            tmpTruthiness = (tmpLeftValue == tmpRightValue);\n            break;\n        case 'identity':\n            tmpTruthiness = (tmpLeftValue === tmpRightValue);\n            break;\n        case 'notequal':\n            tmpTruthiness = (tmpLeftValue != tmpRightValue);\n            break;\n        case 'greaterthan':\n            tmpTruthiness = (tmpLeftValue > tmpRightValue);\n            break;\n        case 'greaterthanorequal':\n            tmpTruthiness = (tmpLeftValue >= tmpRightValue);\n            break;\n        case 'lessthan':\n            tmpTruthiness = (tmpLeftValue < tmpRightValue);\n            break;\n        case 'lessthanorequal':\n            tmpTruthiness = (tmpLeftValue <= tmpRightValue);\n            break;\n    }\n\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'truthinessResult', tmpTruthiness);\n\n    // Now execute the operations (unless it is a noop or a bunk operation)\n    // This is, frankly, kindof a mind-blowing amount of recursion possibility.\n    // Both of these are falling back on the base solution hash mapping.\n    // --> Not certain if this is the correct approach and the only way to tell will be through exercise of this\n    if (tmpTruthiness && (typeof(tmpTrueNamespace) == 'string') && (typeof(tmpTrueOperation) == 'string') && (tmpTrueOperation != 'noop'))\n    {\n        pOperation.Elucidator.solveInternalOperation(tmpTrueNamespace, tmpTrueOperation, pOperation.InputObject, pOperation.OutputObject, pOperation.DescriptionManyfest, pOperation.SolutionContext.InputHashMapping, pOperation.SolutionContext.OutputHashMapping, pOperation.SolutionContext);\n    }\n    else if ((typeof(tmpFalseNamespace) == 'string') &&  (typeof(tmpFalseOperation) == 'string') && (tmpFalseOperation != 'noop'))\n    {\n        pOperation.Elucidator.solveInternalOperation(tmpFalseNamespace, tmpFalseOperation, pOperation.InputObject, pOperation.OutputObject, pOperation.DescriptionManyfest, pOperation.SolutionContext.InputHashMapping, pOperation.SolutionContext.OutputHashMapping, pOperation.SolutionContext);\n    }\n\n    return true;\n};\n\nconst executeOperation = (pOperation) =>\n{\n    let tmpNamespace = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'namespace');\n    let tmpOperation = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'operation');\n\n    pOperation.Elucidator.solveInternalOperation(tmpNamespace, tmpOperation, pOperation.InputObject, pOperation.OutputObject, pOperation.DescriptionManyfest, pOperation.SolutionContext.InputHashMapping, pOperation.SolutionContext.OutputHashMapping, pOperation.SolutionContext);\n\n    return true;\n}\n\nclass Logic extends libElucidatorInstructionSet\n{\n    constructor(pElucidator)\n    {\n        super(pElucidator);\n        this.namespace = 'Logic';\n    }\n\n    initializeInstructions()\n    {\n        // Logic actually wants a noop instruction!\n        super.initializeInstructions();\n\n        this.addInstruction('if', ifInstruction);\n        this.addInstruction('execute', executeOperation);\n\n        return true;\n    }\n\n    initializeOperations()\n    {\n        this.addOperation('if', require(`./Operations/Logic-If.json`));\n        this.addOperation('execute', require(`./Operations/Logic-Execute.json`));\n\n        return true;\n    }\n}\n\nmodule.exports = Logic;","// Solution providers are meant to be stateless, and not classes.\n// These solution providers are akin to drivers, connecting code libraries or \n// other types of behavior to mapping operations.\n\nlet libElucidatorInstructionSet = require('../Elucidator-InstructionSet.js');\n\nlet add = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a');\n    let tmpB = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b');\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA + tmpB);\n    return true;\n};\n\nlet subtract = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a');\n    let tmpB = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b');\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA - tmpB);\n    return true;\n};\n\nlet multiply = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a');\n    let tmpB = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b');\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA * tmpB);\n    return true;\n};\n\nlet divide = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a');\n    let tmpB = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b');\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA / tmpB);\n    return true;\n};\n\nlet aggregate = (pOperation) =>\n{\n    let tmpA = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a');\n\n    let tmpObjectType = typeof(tmpA);\n\n    let tmpAggregationValue = 0;\n\n    if (tmpObjectType == 'object')\n    {\n        if (Array.isArray(tmpA))\n        {\n            for (let i = 0; i < tmpA.length; i++)\n            {\n                // If this is an array, enumerate it and try to aggregate each number\n                let tmpValue = parseInt(tmpA[i]);\n\n                if (isNaN(tmpValue))\n                {\n                    pOperation.logError(`Array element index [${i}] could not be parsed as a number; skipping.  (${tmpA[i]})`);\n                }\n                else\n                {\n                    tmpAggregationValue += tmpValue;\n                    pOperation.logInfo(`Adding element [${i}] value ${tmpValue} totaling: ${tmpAggregationValue}`)\n                }\n            }\n        }\n        else\n        {\n            let tmpObjectKeys = Object.keys(tmpA);\n            for (let i = 0; i < tmpObjectKeys.length; i++)\n            {\n                let tmpValue = parseInt(tmpA[tmpObjectKeys[i]]);\n\n                if (isNaN(tmpValue))\n                {\n                    pOperation.logError(`Object property [${tmpObjectKeys[i]}] could not be parsed as a number; skipping.  (${tmpA[tmpObjectKeys[i]]})`);\n                }\n                else\n                {\n                    tmpAggregationValue += tmpValue;\n                    pOperation.logInfo(`Adding object property [${tmpObjectKeys[i]}] value ${tmpValue} totaling: ${tmpAggregationValue}`)\n                }\n            }\n        }\n    }\n    else\n    {\n        let tmpValue = parseInt(tmpA);\n\n        if (isNaN(tmpValue))\n        {\n            pOperation.logError(`Direct value could not be parsed as a number; skipping.  (${tmpA})`);\n        }\n        else\n        {\n            tmpAggregationValue += tmpValue;\n        }\n    }\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpAggregationValue);\n    return true;\n};\n\nclass MathJavascript extends libElucidatorInstructionSet\n{\n    constructor(pElucidator)\n    {\n        super(pElucidator);\n        this.namespace = 'Math';\n    }\n\n    initializeInstructions()\n    {\n        this.addInstruction('add', add);\n\n        this.addInstruction('subtract', subtract);\n        this.addInstruction('sub', subtract);\n\n        this.addInstruction('multiply', multiply);\n        this.addInstruction('mul', multiply);\n\n        this.addInstruction('divide', divide);\n        this.addInstruction('div', divide);\n\n        this.addInstruction('aggregate', aggregate);\n\n        return true;\n    }\n\n    initializeOperations()\n    {\n        this.addOperation('add', require(`./Operations/Math-Add.json`));\n        this.addOperation('subtract', require(`./Operations/Math-Subtract.json`));\n        this.addOperation('multiply', require(`./Operations/Math-Multiply.json`));\n        this.addOperation('divide', require(`./Operations/Math-Divide.json`));\n\n        this.addOperation('aggregate', require(`./Operations/Math-Aggregate.json`));\n\n        return true;\n    }\n}\n\nmodule.exports = MathJavascript;","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Geometry\",\n\t\t\"Operation\": \"RectangleArea\",\n\t\t\"Synopsis\": \"Solve for the area of a rectangle:  Area = Width * Height\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"Width\": { \"Hash\":\"Width\", \"Type\":\"Number\" },\n\t\t\"Height\": { \"Hash\":\"Height\", \"Type\":\"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"Area\": { \"Hash\":\"Area\", \"Name\": \"Area of the Rectangle\"},\n\t\t\"Ratio\": { \"Hash\":\"Ratio\", \"Name\": \"The Ratio between the Width and the Height\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Solve for [ {{Name:Area}} ] based on [ {{Name:Width}} ] and [ {{Name:Height}} ].\",\n\t\t\"PostOperation\": \"Operation complete; [ {{Name:Area}} ] = {{InputValue:Width}} * {{InputValue:Height}} = {{OutputValue:Area}}\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"multiply\",\n\t\t\t\"InputHashAddressMap\": \n\t\t\t\t{\n\t\t\t\t\t\"a\": \"Width\",\n\t\t\t\t\t\"b\": \"Height\"\n\t\t\t\t},\n\t\t\t\"OutputHashAddressMap\":\n\t\t\t\t{\n\t\t\t\t\t\"x\": \"Area\"\n\t\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"divide\",\n\t\t\t\"InputHashAddressMap\": \n\t\t\t\t{\n\t\t\t\t\t\"a\": \"Width\",\n\t\t\t\t\t\"b\": \"Height\"\n\t\t\t\t},\n\t\t\t\"OutputHashAddressMap\":\n\t\t\t\t{\n\t\t\t\t\t\"x\": \"Ratio\"\n\t\t\t\t}\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Logic\",\n\t\t\"Operation\": \"Execute\",\n\t\t\"Synopsis\": \"Execute an operation based on namespace and operation.\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"namespace\": { \"Hash\": \"namespace\", \"Type\": \"string\", \"Default\":\"logic\" },\n\t\t\"operation\": { \"Hash\": \"operation\", \"Type\": \"string\", \"Default\":\"noop\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Execute the {{InputValue:operation}} operation in namespace {{InputValue:namespace}}.\",\n\t\t\"PostOperation\": \"Operation [{{InputValue:namespace}}:{{InputValue:operation}}] execution complete.\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Logic\",\n\t\t\t\"Instruction\": \"execute\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Logic\",\n\t\t\"Operation\": \"If\",\n\t\t\"Synopsis\": \"Comparison-based if of leftValue and RightValue based on comparator.  Executes trueNamespace:trueOperation or falseNamespace:falseOperation based on truthiness of result.  Also outputs a true or false to truthinessResult.\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"leftValue\": { \"Hash\":\"leftValue\", \"Type\":\"Any\" },\n\t\t\"rightValue\": { \"Hash\":\"rightValue\", \"Type\":\"Any\", \"Default\": true },\n\t\t\"comparator\": { \"Hash\":\"comparator\", \"Type\":\"String\", \"Default\":\"==\" },\n\n\t\t\"trueNamespace\": {\"Hash\":\"trueNamespace\", \"Type\":\"String\", \"Default\":\"logic\" },\n\t\t\"trueOperation\": {\"Hash\":\"trueOperation\", \"Type\":\"String\", \"Default\":\"noop\" },\n\n\t\t\"falseNamespace\": {\"Hash\":\"falseNamespace\", \"Type\":\"String\", \"Default\":\"logic\" },\n\t\t\"falseOperation\": {\"Hash\":\"falseOperation\", \"Type\":\"String\", \"Default\":\"noop\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"truthinessResult\": { \"Hash\": \"truthinessResult\", \"Type\": \"Boolean\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Compare {{Name:leftValue}} and {{Name:rightValue}} with the {{InputValue:comparator}} operator, storing the truthiness in {{Name:truthinessResult}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{InputValue:leftValue}} {{InputValue:comparator}} {{InputValue:rightValue}} evaluated to {{OutputValue:truthinessResult}}\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Logic\",\n\t\t\t\"Instruction\": \"If\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Math\",\n\t\t\"Operation\": \"Add\",\n\t\t\"Synopsis\": \"Add two numbers:  x = a + b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Add {{Name:a}} and {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} + {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Math\",\n\t\t\t\"Instruction\": \"add\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Math\",\n\t\t\"Operation\": \"Aggregate\",\n\t\t\"Synopsis\": \"Aggregate a set of numbers (from array or object address):  x = a + b + ... + z\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Aggregate all numeric values in {{Name:a}}, storing the resultant in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Math\",\n\t\t\t\"Instruction\": \"aggregate\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Math\",\n\t\t\"Operation\": \"Divide\",\n\t\t\"Synopsis\": \"Divide two numbers:  x = a / b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Divide {{Name:a}} over {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} / {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Math\",\n\t\t\t\"Instruction\": \"divide\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Math\",\n\t\t\"Operation\": \"Multiply\",\n\t\t\"Synopsis\": \"Multiply two numbers:  x = a * b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Multiply {{Name:a}} and {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} * {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Math\",\n\t\t\t\"Instruction\": \"multiply\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Math\",\n\t\t\"Operation\": \"Subtract\",\n\t\t\"Synopsis\": \"Subtract two numbers:  x = a - b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Subtract {{Name:a}} and {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} - {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Math\",\n\t\t\t\"Instruction\": \"subtract\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"Add\",\n\t\t\"Synopsis\": \"Precisely add two numbers:  x = a + b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Add {{Name:a}} and {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} + {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"add\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"Aggregate\",\n\t\t\"Synopsis\": \"Precisely aggregate a set of numbers (from array or object address):  x = a + b + ... + z\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Aggregate all numeric values in {{Name:a}}, storing the resultant in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"aggregate\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"Divide\",\n\t\t\"Synopsis\": \"Precisely divide two numbers:  x = a / b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Divide {{Name:a}} over {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} / {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"divide\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"Multiply\",\n\t\t\"Synopsis\": \"Precisely multiply two numbers:  x = a * b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Multiply {{Name:a}} and {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} * {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"multiply\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"Subtract\",\n\t\t\"Synopsis\": \"Precisely subtract two numbers:  x = a - b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Subtract {{Name:a}} and {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} - {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"subtract\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"String\",\n\t\t\"Operation\": \"Replace\",\n\t\t\"Synopsis\": \"Replace all instances of searchFor with replaceWith in inputString\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"inputString\": { \"Hash\": \"inputString\", \"Type\": \"String\" },\n\t\t\"searchFor\": { \"Hash\": \"searchFor\", \"Type\": \"String\" },\n\t\t\"replaceWith\": { \"Hash\": \"replaceWith\", \"Type\": \"String\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"outputString\": { \"Hash\": \"outputString\", \"Type\": \"String\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Search for [{{InputValue:searchFor}}] and replace it with [{{InputValue:replaceWith}}] in [{{InputValue:inputString}}].\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:outputString}} = [{{OutputValue:outputString}}] from [{{InputValue:inputString}}] replacing [{{InputValue:searchFor}}] with [{{InputValue:replaceWith}}].\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"String\",\n\t\t\t\"Instruction\": \"replace\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"String\",\n\t\t\"Operation\": \"Substring\",\n\t\t\"Synopsis\": \"Get all characters between indexStart and indexEnd (optional) for a given inputString.\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"inputString\": { \"Hash\": \"inputString\", \"Type\": \"String\" },\n\t\t\"indexStart\": { \"Hash\": \"indexStart\", \"Type\": \"Number\", \"Default\":0 },\n\t\t\"indexEnd\": { \"Hash\": \"indexEnd\", \"Type\": \"String\", \"Default\":null }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"outputString\": { \"Hash\": \"outputString\", \"Type\": \"String\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Get all characters between {{InputValue:indexStart}} and {{InputValue:indexEnd}} in [{{InputValue:inputString}}].\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:outputString}} = [{{OutputValue:outputString}}] from [{{InputValue:inputString}}] between {{InputValue:indexStart}} and {{InputValue:indexEnd}}.\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"String\",\n\t\t\t\"Instruction\": \"substring\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"String\",\n\t\t\"Operation\": \"Trim\",\n\t\t\"Synopsis\": \"Trim whitespace off the end of string in inputString, putting the result in outputString\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"inputString\": { \"Hash\": \"inputString\", \"Type\": \"String\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"outputString\": { \"Hash\": \"outputString\", \"Type\": \"String\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Trim the whitespace from value [{{InputValue:inputString}}].\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:outputString}} = [{{OutputValue:outputString}}] from [{{InputValue:inputString}}]\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"String\",\n\t\t\t\"Instruction\": \"trim\"\n\t\t}\n\t]\n}","let libElucidatorInstructionSet = require('../Elucidator-InstructionSet.js');\n\nconst libDecimal = require('decimal.js');\n\nlet add = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a'));\n    let tmpB = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b'));\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA.plus(tmpB).toString());\n    return true;\n};\n\nlet subtract = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a'));\n    let tmpB = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b'));\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA.sub(tmpB).toString());\n    return true;\n};\n\nlet multiply = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a'));\n    let tmpB = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b'));\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA.mul(tmpB).toString());\n    return true;\n};\n\nlet divide = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a'));\n    let tmpB = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b'));\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA.div(tmpB).toString());\n    return true;\n};\n\nlet aggregate = (pOperation) =>\n{\n    let tmpA = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a');\n\n    let tmpObjectType = typeof(tmpA);\n\n    let tmpAggregationValue = new libDecimal(0);\n\n    if (tmpObjectType == 'object')\n    {\n        if (Array.isArray(tmpA))\n        {\n            for (let i = 0; i < tmpA.length; i++)\n            {\n                // If this is an array, enumerate it and try to aggregate each number\n                let tmpValue = new libDecimal(tmpA[i]);\n\n                if (isNaN(tmpValue))\n                {\n                    pOperation.logError(`Array element index [${i}] could not be parsed as a number by Decimal.js; skipping.  (${tmpA[i]})`);\n                }\n                else\n                {\n                    tmpAggregationValue = tmpAggregationValue.plus(tmpValue);\n                    pOperation.logInfo(`Adding element [${i}] value ${tmpValue} totaling: ${tmpAggregationValue}`)\n                }\n            }\n        }\n        else\n        {\n            let tmpObjectKeys = Object.keys(tmpA);\n            for (let i = 0; i < tmpObjectKeys.length; i++)\n            {\n                let tmpValue = new libDecimal(tmpA[tmpObjectKeys[i]]);\n\n                if (isNaN(tmpValue))\n                {\n                    pOperation.logError(`Object property [${tmpObjectKeys[i]}] could not be parsed as a number; skipping.  (${tmpA[tmpObjectKeys[i]]})`);\n                }\n                else\n                {\n                    tmpAggregationValue = tmpAggregationValue.plus(tmpValue);\n                    pOperation.logInfo(`Adding object property [${tmpObjectKeys[i]}] value ${tmpValue} totaling: ${tmpAggregationValue}`)\n                }\n            }\n        }\n    }\n    else\n    {\n        let tmpValue = new libDecimal(tmpA);\n\n        if (isNaN(tmpValue))\n        {\n            pOperation.logError(`Direct value could not be parsed as a number; skipping.  (${tmpA})`);\n        }\n        else\n        {\n            tmpAggregationValue = tmpValue;\n        }\n    }\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpAggregationValue.toString());\n    return true;\n};\n\nlet toFraction = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a'));\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA.toFraction().toString());\n    return true;\n};\n\n\nclass PreciseMath extends libElucidatorInstructionSet\n{\n    constructor(pElucidator)\n    {\n        super(pElucidator);\n        this.namespace = 'PreciseMath';\n    }\n\n    initializeInstructions()\n    {\n        this.addInstruction('add', add);\n\n        this.addInstruction('subtract', subtract);\n        this.addInstruction('sub', subtract);\n\n        this.addInstruction('multiply', multiply);\n        this.addInstruction('mul', multiply);\n\n        this.addInstruction('divide', divide);\n        this.addInstruction('div', divide);\n\n        this.addInstruction('aggregate', aggregate);\n\n\t\tthis.addInstruction('tofraction', toFraction);\n\n        return true;\n    }\n\n    initializeOperations()\n    {\n        this.addOperation('add', require(`./Operations/PreciseMath-Add.json`));\n        this.addOperation('subtract', require(`./Operations/PreciseMath-Subtract.json`));\n        this.addOperation('multiply', require(`./Operations/PreciseMath-Multiply.json`));\n        this.addOperation('divide', require(`./Operations/PreciseMath-Divide.json`));\n        this.addOperation('aggregate', require('./Operations/PreciseMath-Aggregate.json'));\n\n        return true;\n    }\n}\n\nmodule.exports = PreciseMath;","// Solution providers are meant to be stateless, and not classes.\n// These solution providers are akin to drivers, connecting code libraries or \n// other types of behavior to mapping operations.\n\nlet libElucidatorInstructionSet = require('../Elucidator-InstructionSet.js');\n\nlet trim = (pOperation) =>\n{\n    let tmpInputString = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'inputString');\n\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'outputString', tmpInputString.trim());\n\n    return true;\n};\n\nlet replace = (pOperation) =>\n{\n    let tmpInputString = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'inputString');\n    let tmpSearchFor = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'searchFor');\n    let tmpReplaceWith = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'replaceWith');\n\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'outputString', tmpInputString.replace(tmpSearchFor, tmpReplaceWith));\n\n    return true;\n};\n\nlet substring = (pOperation) =>\n{\n    let tmpInputString = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'inputString');\n    let indexStart = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'indexStart');\n    let indexEnd = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'indexEnd');\n\n    if (indexEnd != null)\n    {\n        pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'outputString', tmpInputString.substring(indexStart, indexEnd));\n    }\n    else\n    {\n        pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'outputString', tmpInputString.substring(indexStart));\n    }\n\n    return true;\n};\n\nclass StringOperations extends libElucidatorInstructionSet\n{\n    constructor(pElucidator)\n    {\n        super(pElucidator);\n        this.namespace = 'String';\n    }\n\n    initializeInstructions()\n    {\n        this.addInstruction('trim', trim);\n        this.addInstruction('replace', replace);\n        this.addInstruction('substring', substring);\n\n        return true;\n    }\n\n    initializeOperations()\n    {\n        this.addOperation('trim', require(`./Operations/String-Trim.json`));\n        this.addOperation('replace', require(`./Operations/String-Replace.json`));\n        this.addOperation('substring', require(`./Operations/String-Substring.json`));\n\n        return true;\n    }\n}\n\nmodule.exports = StringOperations;","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nconst libSimpleLog = require('./Elucidator-LogToConsole.js');\nconst libManyfest = require('manyfest');\nconst libPrecedent = require('precedent');\n\nconst libElucidatorInstructionSet = require('./Elucidator-InstructionSet.js');\n\n/**\n* Elucidator object address-based descriptions and manipulations.\n*\n* @class Elucidator\n*/\nclass Elucidator\n{\n    constructor(pOperations, fInfoLog, fErrorLog)\n    {\n        // Wire in logging\n        this.logInfo = (typeof(fInfoLog) === 'function') ? fInfoLog : libSimpleLog.info;\n        this.logWarning = (typeof(fWarningLog) === 'function') ? fWarningLog : libSimpleLog.warning;\n        this.logError = (typeof(fErrorLog) === 'function') ? fErrorLog : libSimpleLog.error;\n\n\t\t// Instructions are the basic building blocks for operations\n\t\tthis.instructionSets = {};\n\n\t\t// Operations are the solvers that can be called (instructions can't be called directly)\n\t\t// These can be added at run-time as well\n\t\tthis.operationSets = {};\n\n\t\t// Decide later how to make this truly unique.\n\t\tthis.UUID = 0;\n\n\t\tthis.loadDefaultInstructionSets();\n\n\t\tif (pOperations)\n\t\t{\n\t\t\tlet tmpSolverHashes = Object.keys(pOperations);\n\t\t\tfor (let i = 0; i < tmpSolverHashes.length; i++)\n\t\t\t{\n\t\t\t\tthis.addOperation('Custom',tmpSolverHashes[i], pOperations[tmpSolverHashes[i]]);\n\t\t\t}\n\t\t}\n    }\n\n\t// Load an instruction set\n\tloadInstructionSet(cInstructionSet)\n\t{\n\t\tlet tmpInstructionSet = new cInstructionSet(this);\n\t\t// Setup the namespace\n\t\ttmpInstructionSet.initializeNamespace();\n\t\ttmpInstructionSet.initializeInstructions();\n\t\ttmpInstructionSet.initializeOperations();\n\t}\n\n\tloadDefaultInstructionSets()\n\t{\n\t\t// The javascript math instructions and operations\n\t\t// These provide the \"Math\" namespace\n\t\tthis.loadInstructionSet(require(`./InstructionSets/Math-Javascript.js`));\n\n\t\t// A precision javascript math library that is consistent across browsers, stable and without mantissa issues\n\t\t// Uses Decimal.js\n\t\t// These provide the \"PreciseMath\" namespace\n\t\tthis.loadInstructionSet(require(`./InstructionSets/PreciseMath-Decimal.js`));\n\n\t\t// The abstract geometry instructions and operations (rectangle area, circle area, etc.)\n\t\t// These provide the \"Geometry\" namespace\n\t\tthis.loadInstructionSet(require(`./InstructionSets/Geometry.js`));\n\n\t\t// The logic operations (if, execution of instructions, etc.)\n\t\t// These provide the \"Logic\" namespace\n\t\tthis.loadInstructionSet(require(`./InstructionSets/Logic.js`));\n\n\t\t// Basic string manipulation instructions and operations\n\t\t// These provide the \"String\" namespace\n\t\tthis.loadInstructionSet(require(`./InstructionSets/String.js`));\n\t}\n\n\toperationExists(pNamespace, pOperationHash)\n\t{\n\t\tif ((typeof(pNamespace) != 'string') || (typeof(pOperationHash) != 'string'))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpNamespace = pNamespace.toLowerCase();\n\t\treturn (this.operationSets.hasOwnProperty(tmpNamespace) && this.operationSets[tmpNamespace].hasOwnProperty(pOperationHash.toLowerCase()));\n\t}\n\n\taddOperation(pNamespace, pOperationHash, pOperation)\n\t{\n        if (typeof(pNamespace) != 'string')\n        {\n            this.logError(`Attempted to add an operation at runtime via Elucidator.addOperation with an invalid namespace; expected a string but the type was ${typeof(pNamespace)}`, pOperation);\n            return false;\n        }\n\n\t\tlet tmpOperationInjector = new libElucidatorInstructionSet(this);\n\t\ttmpOperationInjector.initializeNamespace(pNamespace);\n\n\t\treturn tmpOperationInjector.addOperation(pOperationHash, pOperation);\n\t}\n\n\tsolveInternalOperation(pNamespace, pOperationHash, pInputObject, pOutputObject, pDescriptionManyfest, pInputAddressMapping, pOutputAddressMapping, pSolutionContext)\n\t{\n\t\tif (!this.operationExists(pNamespace, pOperationHash))\n\t\t{\n\t\t\tthis.logError(`Attempted to solveInternalOperation for namespace ${pNamespace} operationHash ${pOperationHash} but the operation was not found.`);\n\t\t\t// TODO: Should this return something with an error log populated?\n\t\t\treturn false;\n\t\t}\n\t\tlet tmpOperation = this.operationSets[pNamespace.toLowerCase()][pOperationHash.toLowerCase()];\n\t\treturn this.solveOperation(tmpOperation, pInputObject, pOutputObject, pDescriptionManyfest, pInputAddressMapping, pOutputAddressMapping, pSolutionContext);\n\t}\n\n\tsolveOperation(pOperationObject, pInputObject, pOutputObject, pDescriptionManyfest, pInputAddressMapping, pOutputAddressMapping, pSolutionContext)\n\t{\n\t\tlet tmpOperation = JSON.parse(JSON.stringify(pOperationObject));\n\n\t\tif (typeof(pInputObject) != 'object')\n\t\t{\n            this.logError(`Attempted to run a solve but the passed in Input was not an object.  The type was ${typeof(pInputObject)}.`);\n\t\t\treturn false;\n\t\t}\n\t\tlet tmpInputObject = pInputObject;\n\n\t\t// Default to reusing the input object as the output object.\n\t\tlet tmpOutputObject = tmpInputObject;\n\n\t\t// This is how recursive solutions bind their context together.\n\t\tlet tmpSolutionContext = pSolutionContext;\n\t\tif (typeof(tmpSolutionContext) === 'undefined')\n\t\t{\n\t\t\ttmpSolutionContext = (\n\t\t\t\t{\n\t\t\t\t\t\"SolutionGUID\": `Solution-${this.UUID++}`, \n\t\t\t\t\t\"SolutionBaseNamespace\": pOperationObject.Description.Namespace,\n\t\t\t\t\t\"SolutionBaseOperation\": pOperationObject.Description.Operation,\n\t\t\t\t\t\"SolutionLog\": []\n\t\t\t\t});\n\t\t\t\n\t\t\t// This is the root operation, see if there are Inputs and Outputs created ... if not, create them.\n\t\t\tif (!tmpOperation.hasOwnProperty('Inputs'))\n\t\t\t{\n\t\t\t\ttmpOperation.Inputs = {};\n\t\t\t}\n\t\t\tif (!tmpOperation.hasOwnProperty('Outputs'))\n\t\t\t{\n\t\t\t\ttmpOperation.Outputs = {};\n\t\t\t}\n\n\t\t\t// This is the root Operation, see if there is a hash translation available for either side (input or output)\n\t\t\tif (tmpOperation.hasOwnProperty('InputHashTranslationTable'))\n\t\t\t{\n\t\t\t\ttmpSolutionContext.InputHashMapping = JSON.parse(JSON.stringify(tmpOperation.InputHashTranslationTable));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmpSolutionContext.InputHashMapping = {};\n\t\t\t}\n\n\t\t\tif (tmpOperation.hasOwnProperty('OutputHashTranslationTable'))\n\t\t\t{\n\t\t\t\ttmpSolutionContext.OutputHashMapping = JSON.parse(JSON.stringify(tmpOperation.OutputHashTranslationTable));\n\t\t\t}\n\n\t\t\tif ((typeof(pOutputObject) != 'object')\n\t\t\t\t&& (typeof(tmpOutputHashMapping) == 'undefined') \n\t\t\t\t&& (typeof(tmpInputHashMapping) != 'undefined'))\n\t\t\t{\n\t\t\t\t// Reuse the input hash mapping if:\n\t\t\t\t//   1) we auto-mapped the input hash mapping to the output because only an input object was supplied\n\t\t\t\t//   2) there *was not* an output hash mapping supplied\n\t\t\t\t//   3) there *was* an input hash mapping supplied\n\t\t\t\t//\n\t\t\t\t// This seems simple at first but exposes some really interesting behaviors in terms of\n\t\t\t\t// reusing the same object and schema for input and output, but having different hash\n\t\t\t\t// mappings for each of them.\n\t\t\t\ttmpSolutionContext.OutputHashMapping = tmpSolutionContext.InputHashMapping;\n\t\t\t}\n\t\t}\n\n\t\tif (typeof(pOutputObject) == 'object')\n\t\t{\n\t\t\t// If the call defined an explicit, different output object from the input object use that instead.\n\t\t\ttmpOutputObject = pOutputObject;\n\t\t}\n\n\t\tlet tmpDescriptionManyfest = false;\n\t\tif (typeof(pDescriptionManyfest) === 'undefined')\n\t\t{\n\t\t\t// We are going to use this for some clever schema manipulations, then recreate the object\n\t\t\ttmpDescriptionManyfest = new libManyfest();\n\t\t\t// Synthesize a manyfest from the Input and Output properties\n\t\t\tlet tmpManyfestSchema = (\n\t\t\t\t{\n\t\t\t\t\tScope: 'Solver Data Part Descriptions',\n\t\t\t\t\tDescriptors: tmpDescriptionManyfest.schemaManipulations.mergeAddressMappings(tmpOperation.Inputs, tmpOperation.Outputs)\n\t\t\t\t});\n\t\t\t}\n\t\telse\n\t\t{\n\t\t\t// Clone the passed-in manyfest, so mutations do not alter the upstream version\n\t\t\ttmpDescriptionManyfest = pDescriptionManyfest.clone();\n\t\t}\n\t\t// Now that the operation object has been created uniquely, apply any passed-in address-hash and hash-hash remappings\n\t\tif (pInputAddressMapping)\n\t\t{\n\t\t\ttmpDescriptionManyfest.schemaManipulations.resolveAddressMappings(tmpOperation.Inputs, pInputAddressMapping);\n\t\t}\n\t\tif (pOutputAddressMapping)\n\t\t{\n\t\t\ttmpDescriptionManyfest.schemaManipulations.resolveAddressMappings(tmpOperation.Inputs, pOutputAddressMapping);\n\t\t}\n\t\tif (tmpSolutionContext.InputHashMapping)\n\t\t{\n\t\t\ttmpDescriptionManyfest.hashTranslations.addTranslation(tmpSolutionContext.InputHashMapping);\n\t\t}\n\t\tif (tmpSolutionContext.OutputHashMapping)\n\t\t{\n\t\t\ttmpDescriptionManyfest.hashTranslations.addTranslation(tmpSolutionContext.OutputHashMapping);\t\t\t\n\t\t}\n\n\n\t\t// Set some kind of unique identifier for the operation\n\t\ttmpOperation.UUID = this.UUID++;\n\t\ttmpOperation.SolutionContext = tmpSolutionContext;\n\n\t\tif (tmpOperation.Description.Synopsys)\n\t\t{\n\t\t\ttmpSolutionContext.SolutionLog.push(`[${tmpOperation.UUID}]: Solver running operation ${tmpOperation.Description.Synopsys}`);\n\t\t}\n\n\t\tlet tmpPrecedent = new libPrecedent();\n\t\ttmpPrecedent.addPattern('{{Name:', '}}',\n\t\t\t(pHash)=>\n\t\t\t{\n\t\t\t\tlet tmpHash = pHash.trim();\n\t\t\t\tlet tmpDescriptor = tmpDescriptionManyfest.getDescriptorByHash(tmpHash)\n\n\t\t\t\t// Return a human readable value\n\t\t\t\tif ((typeof(tmpDescriptor) == 'object')  && tmpDescriptor.hasOwnProperty('Name'))\n\t\t\t\t{\n\t\t\t\t\treturn tmpDescriptor.Name;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn tmpHash;\n\t\t\t\t}\n\t\t\t});\n\t\ttmpPrecedent.addPattern('{{InputValue:', '}}',\n\t\t\t(pHash)=>\n\t\t\t{\n\t\t\t\tlet tmpHash = pHash.trim();\n\t\t\t\treturn tmpDescriptionManyfest.getValueByHash(tmpInputObject,tmpHash);\n\t\t\t});\n\t\ttmpPrecedent.addPattern('{{OutputValue:', '}}',\n\t\t\t(pHash)=>\n\t\t\t{\n\t\t\t\tlet tmpHash = pHash.trim();\n\t\t\t\treturn tmpDescriptionManyfest.getValueByHash(tmpOutputObject,tmpHash);\n\t\t\t});\n\n\t\tif (tmpOperation.hasOwnProperty('Log') && tmpOperation.Log.hasOwnProperty('PreOperation'))\n\t\t{\n\t\t\tif (typeof(tmpOperation.Log.PreOperation) == 'string')\n\t\t\t{\n\t\t\t\ttmpOperation.SolutionContext.SolutionLog.push(tmpPrecedent.parseString(tmpOperation.Log.PreOperation));\n\t\t\t}\n\t\t\telse if (Array.isArray(tmpOperation.Log.PreOperation))\n\t\t\t{\n\t\t\t\tfor (let i = 0; i < tmpOperation.Log.PreOperation.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif ((typeof(tmpOperation.Log.PreOperation[i]) == 'string'))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpOperation.SolutionContext.SolutionLog.push(tmpPrecedent.parseString(tmpOperation.Log.PreOperation[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Now step through each operation and solve\n\t\tfor (let i = 0; i < tmpOperation.Steps.length; i++)\n\t\t{\n\t\t\tlet tmpStep = tmpOperation.Steps[i];\n\n\t\t\t// Instructions are always endpoints -- they *do not* recurse.\n\t\t\tif (tmpStep.hasOwnProperty('Instruction'))\n\t\t\t{\n\t\t\t\tlet tmpInputSchema = (\n\t\t\t\t\t{\n\t\t\t\t\t\t\"Scope\": \"InputObject\",\n\t\t\t\t\t\t\"Descriptors\": JSON.parse(JSON.stringify(tmpOperation.Inputs))\n\t\t\t\t\t});\n\t\t\t\t// Perform step-specific address mappings.\n\t\t\t\ttmpDescriptionManyfest.schemaManipulations.resolveAddressMappings(tmpInputSchema.Descriptors, tmpStep.InputHashAddressMap);\n\t\t\t\tlet tmpInputManyfest = new libManyfest(tmpInputSchema);\n\t\t\t\tif (tmpSolutionContext.InputHashMapping)\n\t\t\t\t{\n\t\t\t\t\ttmpInputManyfest.hashTranslations.addTranslation(tmpSolutionContext.InputHashMapping);\n\t\t\t\t}\n\n\t\t\t\tlet tmpOutputSchema = (\n\t\t\t\t\t{\n\t\t\t\t\t\t\"Scope\": \"OutputObject\",\n\t\t\t\t\t\t\"Descriptors\": JSON.parse(JSON.stringify(tmpOperation.Outputs))\n\t\t\t\t\t});\n\t\t\t\t\ttmpDescriptionManyfest.schemaManipulations.resolveAddressMappings(tmpOutputSchema.Descriptors, tmpStep.OutputHashAddressMap);\n\t\t\t\tlet tmpOutputManyfest = new libManyfest(tmpOutputSchema);\n\t\t\t\tif (tmpSolutionContext.OutputHashMapping)\n\t\t\t\t{\n\t\t\t\t\ttmpOutputManyfest.hashTranslations.addTranslation(tmpSolutionContext.OutputHashMapping);\n\t\t\t\t}\n\t\n\t\t\t\t// Construct the instruction state object\n\t\t\t\tlet tmpInstructionState = (\n\t\t\t\t{\n\t\t\t\t\tElucidator: this,\n\n\t\t\t\t\tNamespace: tmpStep.Namespace.toLowerCase(),\n\t\t\t\t\tInstruction: tmpStep.Instruction.toLowerCase(),\n\n\t\t\t\t\tOperation: tmpOperation,\n\n\t\t\t\t\tSolutionContext: tmpSolutionContext,\n\n\t\t\t\t\tDescriptionManyfest: tmpDescriptionManyfest,\n\n\t\t\t\t\tInputObject: tmpInputObject,\n\t\t\t\t\tInputManyfest: tmpInputManyfest,\n\n\t\t\t\t\tOutputObject: tmpOutputObject,\n\t\t\t\t\tOutputManyfest: tmpOutputManyfest\n\t\t\t\t});\n\n\t\t\t\ttmpInstructionState.logError = \n\t\t\t\t\t(pMessage) => \n\t\t\t\t\t{\n\t\t\t\t\t\ttmpSolutionContext.SolutionLog.push(`[ERROR][Operation ${tmpInstructionState.Operation.Description.Namespace}:${tmpInstructionState.Operation.Description.Hash} - Step #${i}:${tmpStep.Namespace}:${tmpStep.Instruction}] ${pMessage}`)\n\t\t\t\t\t};\n\n\t\t\t\ttmpInstructionState.logInfo = \n\t\t\t\t\t(pMessage) => \n\t\t\t\t\t{\n\t\t\t\t\t\ttmpSolutionContext.SolutionLog.push(`[INFO][Operation ${tmpInstructionState.Operation.Description.Namespace}:${tmpInstructionState.Operation.Description.Hash} - Step #${i}:${tmpStep.Namespace}:${tmpStep.Instruction}] ${pMessage}`)\n\t\t\t\t\t};\n\n\t\t\t\tif (this.instructionSets[tmpInstructionState.Namespace].hasOwnProperty(tmpInstructionState.Instruction))\n\t\t\t\t{\n\t\t\t\t\tlet fInstruction = this.instructionSets[tmpInstructionState.Namespace][tmpInstructionState.Instruction];\n\t\t\t\t\tfInstruction(tmpInstructionState);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Operations recurse.\n\t\t\tif (tmpStep.hasOwnProperty('Operation'))\n\t\t\t{\n\t\t\t\tif (typeof(tmpStep.Operation) == 'string')\n\t\t\t\t{\n\t\t\t\t\tthis.solveInternalOperation(tmpStep.Namespace, tmpStep.Operation, tmpInputObject, tmpOutputObject, tmpDescriptionManyfest, tmpStep.InputHashAddressMap, tmpStep.OutputHashAddressMap, tmpSolutionContext);\n\t\t\t\t}\n\t\t\t\telse if (typeof(tmpStep.Operation) == 'object')\n\t\t\t\t{\n\t\t\t\t\t// You can even define an inline object operation!  This gets crazy fast\n\t\t\t\t\tthis.solveOperation(tmpStep.Operation, tmpInputObject, tmpOutputObject, tmpDescriptionManyfest, tmpStep.InputHashAddressMap, tmpStep.OutputHashAddressMap, tmpSolutionContext);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (tmpOperation.hasOwnProperty('Log') && tmpOperation.Log.hasOwnProperty('PostOperation'))\n\t\t{\n\t\t\tif (typeof(tmpOperation.Log.PostOperation) == 'string')\n\t\t\t{\n\t\t\t\ttmpOperation.SolutionContext.SolutionLog.push(tmpPrecedent.parseString(tmpOperation.Log.PostOperation));\n\t\t\t}\n\t\t\telse if (Array.isArray(tmpOperation.Log.PreOperation))\n\t\t\t{\n\t\t\t\tfor (let i = 0; i < tmpOperation.Log.PostOperation.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif ((typeof(tmpOperation.Log.PostOperation[i]) == 'string'))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpOperation.SolutionContext.SolutionLog.push(tmpPrecedent.parseString(tmpOperation.Log.PostOperation[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn tmpSolutionContext;\n\t}\n};\n\nmodule.exports = Elucidator;","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\n/**\n* Hash Translation\n*\n* This is a very simple translation table for hashes, which allows the same schema to resolve \n* differently based on a loaded translation table.\n*\n* This is to prevent the requirement for mutating schemas over and over again when we want to\n* reuse the structure but look up data elements by different addresses.\n*\n* One side-effect of this is that a translation table can \"override\" the built-in hashes, since\n* this is always used to resolve hashes before any of the functionCallByHash(pHash, ...) perform\n* their lookups by hash.\n*\n* @class ManyfestHashTranslation\n*/\nclass ManyfestHashTranslation\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) === 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) === 'function') ? pErrorLog : libSimpleLog;\n\n        this.translationTable = {};\n\t}\n\n    translationCount()\n    {\n        return Object.keys(this.translationTable).length;\n    }\n\n    addTranslation(pTranslation)\n    {\n        // This adds a translation in the form of:\n        // { \"SourceHash\": \"DestinationHash\", \"SecondSourceHash\":\"SecondDestinationHash\" }\n        if (typeof(pTranslation) != 'object')\n        {\n            this.logError(`Hash translation addTranslation expected a translation be type object but was passed in ${typeof(pTranslation)}`);\n            return false;\n        }\n\n        let tmpTranslationSources = Object.keys(pTranslation)\n\n        tmpTranslationSources.forEach(\n            (pTranslationSource) =>\n            {\n                if (typeof(pTranslation[pTranslationSource]) != 'string')\n                {\n                    this.logError(`Hash translation addTranslation expected a translation destination hash for [${pTranslationSource}] to be a string but the referrant was a ${typeof(pTranslation[pTranslationSource])}`);\n                }\n                else\n                {\n                    this.translationTable[pTranslationSource] = pTranslation[pTranslationSource];\n                }\n            });\n    }\n\n    removeTranslationHash(pTranslationHash)\n    {\n        if (this.translationTable.hasOwnProperty(pTranslationHash))\n        {\n            delete this.translationTable[pTranslationHash];\n        }\n    }\n\n    // This removes translations.\n    // If passed a string, just removes the single one.\n    // If passed an object, it does all the source keys.\n    removeTranslation(pTranslation)\n    {\n        if (typeof(pTranslation) == 'string')\n        {\n            this.removeTranslationHash(pTranslation);\n            return true;\n        }\n        else if (typeof(pTranslation) == 'object')\n        {\n            let tmpTranslationSources = Object.keys(pTranslation)\n\n            tmpTranslationSources.forEach(\n                (pTranslationSource) =>\n                {\n                    this.removeTranslation(pTranslationSource);\n                });\n            return true;\n        }\n        else\n        {\n            this.logError(`Hash translation removeTranslation expected either a string or an object but the passed-in translation was type ${typeof(pTranslation)}`);\n            return false;\n        }\n    }\n\n    clearTranslations()\n    {\n        this.translationTable = {};\n    }\n\n    translate(pTranslation)\n    {\n        if (this.translationTable.hasOwnProperty(pTranslation))\n        {\n            return this.translationTable[pTranslation];\n        }\n        else\n        {\n            return pTranslation;\n        }\n    }\n}\n\nmodule.exports = ManyfestHashTranslation;","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\n/**\n* Manyfest simple logging shim (for browser and dependency-free running)\n*/\n\nconst logToConsole = (pLogLine, pLogObject) =>\n{\n    let tmpLogLine = (typeof(pLogLine) === 'string') ? pLogLine : '';\n\n    console.log(`[Manyfest] ${tmpLogLine}`);\n\n    if (pLogObject) console.log(JSON.stringify(pLogObject));\n};\n\nmodule.exports = logToConsole;","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\n/**\n* Object Address Generation\n*\n* Automagically generate addresses and properties based on a passed-in object, \n* to be used for easy creation of schemas.  Meant to simplify the lives of\n* developers wanting to create schemas without typing a bunch of stuff.\n* \n* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to\n*                 be extremely clear what is going on in the recursion for\n*                 each of the three address resolution functions.\n* \n*                 Although there is some opportunity to repeat ourselves a\n*                 bit less in this codebase (e.g. with detection of arrays\n*                 versus objects versus direct properties), it can make\n*                 debugging.. challenging.  The minified version of the code\n*                 optimizes out almost anything repeated in here.  So please\n*                 be kind and rewind... meaning please keep the codebase less\n*                 terse and more verbose so humans can comprehend it.\n*                 \n*\n* @class ManyfestObjectAddressGeneration\n*/\nclass ManyfestObjectAddressGeneration\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) == 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) == 'function') ? pErrorLog : libSimpleLog;\n\t}\n\n\t// generateAddressses\n\t//\n\t// This flattens an object into a set of key:value pairs for *EVERY SINGLE\n\t// POSSIBLE ADDRESS* in the object.  It can get ... really insane really\n\t// quickly.  This is not meant to be used directly to generate schemas, but\n\t// instead as a starting point for scripts or UIs.\n\t//\n\t// This will return a mega set of key:value pairs with all possible schema \n\t// permutations and default values (when not an object) and everything else.\n\tgenerateAddressses (pObject, pBaseAddress, pSchema)\n\t{\n\t\tlet tmpBaseAddress = (typeof(pBaseAddress) == 'string') ? pBaseAddress : '';\n\t\tlet tmpSchema = (typeof(pSchema) == 'object') ? pSchema : {};\n\n\t\tlet tmpObjectType = typeof(pObject);\n\n\t\tlet tmpSchemaObjectEntry = (\n\t\t\t{\n\t\t\t\tAddress: tmpBaseAddress,\n\t\t\t\tHash: tmpBaseAddress,\n\t\t\t\tName: tmpBaseAddress,\n\t\t\t\t// This is so scripts and UI controls can force a developer to opt-in.\n\t\t\t\tInSchema: false\n\t\t\t}\n\t\t)\n\n\t\tswitch(tmpObjectType)\n\t\t{\n\t\t\tcase 'string':\n\t\t\t\ttmpSchemaObjectEntry.DataType = 'String';\n\t\t\t\ttmpSchemaObjectEntry.Default = pObject;\n\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\tbreak;\n\t\t\tcase 'number':\n\t\t\tcase 'bigint':\n\t\t\t\ttmpSchemaObjectEntry.DataType = 'Number';\n\t\t\t\ttmpSchemaObjectEntry.Default = pObject;\n\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\tbreak;\n\t\t\tcase 'undefined':\n\t\t\t\ttmpSchemaObjectEntry.DataType = 'Any';\n\t\t\t\ttmpSchemaObjectEntry.Default = pObject;\n\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\tbreak;\n\t\t\tcase 'object':\n\t\t\t\tif (Array.isArray(pObject))\n\t\t\t\t{\n\t\t\t\t\ttmpSchemaObjectEntry.DataType = 'Array';\n\t\t\t\t\tif (tmpBaseAddress != '')\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor (let i = 0; i < pObject.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.generateAddressses(pObject[i], `${tmpBaseAddress}[${i}]`, tmpSchema);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttmpSchemaObjectEntry.DataType = 'Object';\n\t\t\t\t\tif (tmpBaseAddress != '')\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\t\t\ttmpBaseAddress += '.';\n\t\t\t\t\t}\n\t\n\t\t\t\t\tlet tmpObjectProperties = Object.keys(pObject);\n\n\t\t\t\t\tfor (let i = 0; i < tmpObjectProperties.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.generateAddressses(pObject[tmpObjectProperties[i]], `${tmpBaseAddress}${tmpObjectProperties[i]}`, tmpSchema);\n\t\t\t\t\t}\t\t\t\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'symbol':\n\t\t\tcase 'function':\n\t\t\t\t// Symbols and functions neither recurse nor get added to the schema\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn tmpSchema;\n\t}\n};\n\nmodule.exports = ManyfestObjectAddressGeneration;","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\n/**\n* Object Address Resolver\n* \n* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to\n*                 be extremely clear what is going on in the recursion for\n*                 each of the three address resolution functions.\n* \n*                 Although there is some opportunity to repeat ourselves a\n*                 bit less in this codebase (e.g. with detection of arrays\n*                 versus objects versus direct properties), it can make\n*                 debugging.. challenging.  The minified version of the code\n*                 optimizes out almost anything repeated in here.  So please\n*                 be kind and rewind... meaning please keep the codebase less\n*                 terse and more verbose so humans can comprehend it.\n*                 \n*\n* @class ManyfestObjectAddressResolver\n*/\nclass ManyfestObjectAddressResolver\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) == 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) == 'function') ? pErrorLog : libSimpleLog;\n\t}\n\n\t// When a boxed property is passed in, it should have quotes of some\n\t// kind around it.\n\t//\n\t// For instance:\n\t// \t\tMyValues['Name']\n\t// \t\tMyValues[\"Age\"]\n\t// \t\tMyValues[`Cost`]\n\t//\n\t// This function removes the wrapping quotes.\n\t//\n\t// Please note it *DOES NOT PARSE* template literals, so backticks just\n\t// end up doing the same thing as other quote types.\n\t//\n\t// TODO: Should template literals be processed?  If so what state do they have access to?\n\tcleanWrapCharacters (pCharacter, pString)\n\t{\n\t\tif (pString.startsWith(pCharacter) && pString.endsWith(pCharacter))\n\t\t{\n\t\t\treturn pString.substring(1, pString.length - 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn pString;\n\t\t}\n\t}\n\n\t// Check if an address exists.\n\t//\n\t// This is necessary because the getValueAtAddress function is ambiguous on \n\t// whether the element/property is actually there or not (it returns \n\t// undefined whether the property exists or not).  This function checks for\n\t// existance and returns true or false dependent.\n\tcheckAddressExists (pObject, pAddress)\n\t{\n\t\t// TODO: Should these throw an error?\n\t\t// Make sure pObject is an object\n\t\tif (typeof(pObject) != 'object') return false;\n\t\t// Make sure pAddress is a string\n\t\tif (typeof(pAddress) != 'string') return false;\n\n\t\t// TODO: Make this work for things like SomeRootObject.Metadata[\"Some.People.Use.Bad.Object.Property.Names\"]\n\t\tlet tmpSeparatorIndex = pAddress.indexOf('.');\n\n\t\t// This is the terminal address string (no more dots so the RECUSION ENDS IN HERE somehow)\n\t\tif (tmpSeparatorIndex == -1)\n\t\t{\n\t\t\t// Check if the address refers to a boxed property\n\t\t\tlet tmpBracketStartIndex = pAddress.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = pAddress.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[10]\n\t\t\t// \t\tMyValues['Name']\n\t\t\t// \t\tMyValues[\"Age\"]\n\t\t\t// \t\tMyValues[`Cost`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is data \n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\t// The \"Name\" of the Object contained too the left of the bracket\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\t// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.\n\t\t\t\t// This is a rare case where Arrays testing as Objects is useful\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// The \"Reference\" to the property within it, either an array element or object property\n\t\t\t\tlet tmpBoxedPropertyReference = pAddress.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\t\t\t\t// Attempt to parse the reference as a number, which will be used as an array element\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to treat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynamic object property.\n\t\t\t\t\t// We would expect the property to be wrapped in some kind of quotes so strip them\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Check if the property exists.\n\t\t\t\t\treturn pObject[tmpBoxedPropertyName].hasOwnProperty(tmpBoxedPropertyReference);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Use the new in operator to see if the element is in the array\n\t\t\t\t\treturn (tmpBoxedPropertyNumber in pObject[tmpBoxedPropertyName]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Check if the property exists\n\t\t\t\treturn pObject.hasOwnProperty(pAddress);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpSubObjectName = pAddress.substring(0, tmpSeparatorIndex);\n\t\t\tlet tmpNewAddress = pAddress.substring(tmpSeparatorIndex+1);\n\n\t\t\t// Test if the tmpNewAddress is an array or object\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = tmpSubObjectName.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = tmpSubObjectName.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[42]\n\t\t\t// \t\tMyValues['Color']\n\t\t\t// \t\tMyValues[\"Weight\"]\n\t\t\t// \t\tMyValues[`Diameter`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is data \n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = tmpSubObjectName.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyReference = tmpSubObjectName.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[1].Tardy\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[\"JaneDoe\"].Grade\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an array, so the [\"JaneDoe\"].Grade is not possible to access\n\t\t\t\t// TODO: Should this be an error or something?  Should we keep a log of failures like this?\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// Because this is an impossible address, the property doesn't exist\n\t\t\t\t\t// TODO: Should we throw an error in this condition?\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//This is a bracketed value\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to reat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynanmic object property.\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Recurse directly into the subobject\n\t\t\t\t\treturn this.checkAddressExists(pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference], tmpNewAddress);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// We parsed a valid number out of the boxed property name, so recurse into the array\n\t\t\t\t\treturn this.checkAddressExists(pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber], tmpNewAddress);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there is an object property already named for the sub object, but it isn't an object\n\t\t\t// then the system can't set the value in there.  Error and abort!\n\t\t\tif (pObject.hasOwnProperty(tmpSubObjectName) && typeof(pObject[tmpSubObjectName]) !== 'object')\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (pObject.hasOwnProperty(tmpSubObjectName))\n\t\t\t{\n\t\t\t\t// If there is already a subobject pass that to the recursive thingy\n\t\t\t\treturn this.checkAddressExists(pObject[tmpSubObjectName], tmpNewAddress);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Create a subobject and then pass that\n\t\t\t\tpObject[tmpSubObjectName] = {};\n\t\t\t\treturn this.checkAddressExists(pObject[tmpSubObjectName], tmpNewAddress);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Get the value of an element at an address\n\tgetValueAtAddress (pObject, pAddress, pParentAddress)\n\t{\n\t\t// Make sure pObject is an object\n\t\tif (typeof(pObject) != 'object') return undefined;\n\t\t// Make sure pAddress is a string\n\t\tif (typeof(pAddress) != 'string') return undefined;\n\t\tlet tmpParentAddress = \"\";\n\t\tif (typeof(pParentAddress) == 'string')\n\t\t{\n\t\t\ttmpParentAddress = pParentAddress;\n\t\t}\n\n\t\t// TODO: Make this work for things like SomeRootObject.Metadata[\"Some.People.Use.Bad.Object.Property.Names\"]\n\t\tlet tmpSeparatorIndex = pAddress.indexOf('.');\n\n\t\t// This is the terminal address string (no more dots so the RECUSION ENDS IN HERE somehow)\n\t\tif (tmpSeparatorIndex == -1)\n\t\t{\n\t\t\t// Check if the address refers to a boxed property\n\t\t\tlet tmpBracketStartIndex = pAddress.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = pAddress.indexOf(']');\n\n\t\t\t// Check for the Object Set Type marker.\n\t\t\t// Note this will not work with a bracket in the same address box set\n\t\t\tlet tmpObjectTypeMarkerIndex = pAddress.indexOf('{}');\n\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[10]\n\t\t\t// \t\tMyValues['Name']\n\t\t\t// \t\tMyValues[\"Age\"]\n\t\t\t// \t\tMyValues[`Cost`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is data \n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\t// The \"Name\" of the Object contained too the left of the bracket\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\t// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.\n\t\t\t\t// This is a rare case where Arrays testing as Objects is useful\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\t// The \"Reference\" to the property within it, either an array element or object property\n\t\t\t\tlet tmpBoxedPropertyReference = pAddress.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\t\t\t\t// Attempt to parse the reference as a number, which will be used as an array element\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to treat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynamic object property.\n\t\t\t\t\t// We would expect the property to be wrapped in some kind of quotes so strip them\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Return the value in the property\n\t\t\t\t\treturn pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// The requirements to detect a boxed set element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is nothing in the brackets\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex == 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tif (!Array.isArray(pObject[tmpBoxedPropertyName]))\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\treturn pObject[tmpBoxedPropertyName];\n\t\t\t}\n\t\t\t// The object has been flagged as an object set, so treat it as such\n\t\t\telse if (tmpObjectTypeMarkerIndex > 0)\n\t\t\t{\n\t\t\t\tlet tmpObjectPropertyName = pAddress.substring(0, tmpObjectTypeMarkerIndex).trim();\n\n\t\t\t\tif (typeof(pObject[tmpObjectPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\treturn pObject[tmpObjectPropertyName];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Now is the point in recursion to return the value in the address\n\t\t\t\treturn pObject[pAddress];\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpSubObjectName = pAddress.substring(0, tmpSeparatorIndex);\n\t\t\tlet tmpNewAddress = pAddress.substring(tmpSeparatorIndex+1);\n\n\t\t\t// BOXED ELEMENTS\n\t\t\t// Test if the tmpNewAddress is an array or object\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = tmpSubObjectName.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = tmpSubObjectName.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[42]\n\t\t\t// \t\tMyValues['Color']\n\t\t\t// \t\tMyValues[\"Weight\"]\n\t\t\t// \t\tMyValues[`Diameter`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is data \n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = tmpSubObjectName.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyReference = tmpSubObjectName.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[1].Tardy\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[\"JaneDoe\"].Grade\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an array, so the [\"JaneDoe\"].Grade is not possible to access\n\t\t\t\t// TODO: Should this be an error or something?  Should we keep a log of failures like this?\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\t//This is a bracketed value\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to reat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynanmic object property.\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\t\t// Recurse directly into the subobject\n\t\t\t\t\treturn this.getValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference], tmpNewAddress, tmpParentAddress);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\t\t// We parsed a valid number out of the boxed property name, so recurse into the array\n\t\t\t\t\treturn this.getValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber], tmpNewAddress, tmpParentAddress);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// The requirements to detect a boxed set element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is nothing in the brackets\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex == 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tif (!Array.isArray(pObject[tmpBoxedPropertyName]))\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// We need to enumerate the array and grab the addresses from there.\n\t\t\t\tlet tmpArrayProperty = pObject[tmpBoxedPropertyName];\n\t\t\t\t// Managing the parent address is a bit more complex here -- the box will be added for each element.\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpBoxedPropertyName}`;\n\t\t\t\t// The container object is where we have the \"Address\":SOMEVALUE pairs\n\t\t\t\tlet tmpContainerObject = {};\n\t\t\t\tfor (let i = 0; i < tmpArrayProperty.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpPropertyParentAddress = `${tmpParentAddress}[${i}]`;\n\t\t\t\t\tlet tmpValue = this.getValueAtAddress(pObject[tmpBoxedPropertyName][i], tmpNewAddress, tmpPropertyParentAddress);;\n\t\t\t\t\ttmpContainerObject[`${tmpPropertyParentAddress}.${tmpNewAddress}`] = tmpValue;\n\t\t\t\t}\n\n\t\t\t\treturn tmpContainerObject;\n\t\t\t}\n\n\t\t\t// OBJECT SET\n\t\t\t// Note this will not work with a bracket in the same address box set\n\t\t\tlet tmpObjectTypeMarkerIndex = pAddress.indexOf('{}');\n\t\t\tif (tmpObjectTypeMarkerIndex > 0)\n\t\t\t{\n\t\t\t\tlet tmpObjectPropertyName = pAddress.substring(0, tmpObjectTypeMarkerIndex).trim();\n\n\t\t\t\tif (typeof(pObject[tmpObjectPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// We need to enumerate the Object and grab the addresses from there.\n\t\t\t\tlet tmpObjectProperty = pObject[tmpObjectPropertyName];\n\t\t\t\tlet tmpObjectPropertyKeys = Object.keys(tmpObjectProperty);\n\t\t\t\t// Managing the parent address is a bit more complex here -- the box will be added for each element.\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpObjectPropertyName}`;\n\t\t\t\t// The container object is where we have the \"Address\":SOMEVALUE pairs\n\t\t\t\tlet tmpContainerObject = {};\n\t\t\t\tfor (let i = 0; i < tmpObjectPropertyKeys.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpPropertyParentAddress = `${tmpParentAddress}.${tmpObjectPropertyKeys[i]}`;\n\t\t\t\t\tlet tmpValue = this.getValueAtAddress(pObject[tmpObjectPropertyName][tmpObjectPropertyKeys[i]], tmpNewAddress, tmpPropertyParentAddress);;\n\t\t\t\t\ttmpContainerObject[`${tmpPropertyParentAddress}.${tmpNewAddress}`] = tmpValue;\n\t\t\t\t}\n\n\t\t\t\treturn tmpContainerObject;\n\t\t\t}\n\n\t\t\t// If there is an object property already named for the sub object, but it isn't an object\n\t\t\t// then the system can't set the value in there.  Error and abort!\n\t\t\tif (pObject.hasOwnProperty(tmpSubObjectName) && typeof(pObject[tmpSubObjectName]) !== 'object')\n\t\t\t{\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\telse if (pObject.hasOwnProperty(tmpSubObjectName))\n\t\t\t{\n\t\t\t\t// If there is already a subobject pass that to the recursive thingy\n\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\treturn this.getValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, tmpParentAddress);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Create a subobject and then pass that\n\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\tpObject[tmpSubObjectName] = {};\n\t\t\t\treturn this.getValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, tmpParentAddress);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the value of an element at an address\n\tsetValueAtAddress (pObject, pAddress, pValue)\n\t{\n\t\t// Make sure pObject is an object\n\t\tif (typeof(pObject) != 'object') return false;\n\t\t// Make sure pAddress is a string\n\t\tif (typeof(pAddress) != 'string') return false;\n\n\t\tlet tmpSeparatorIndex = pAddress.indexOf('.');\n\n\t\tif (tmpSeparatorIndex == -1)\n\t\t{\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = pAddress.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = pAddress.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[10]\n\t\t\t// \t\tMyValues['Name']\n\t\t\t// \t\tMyValues[\"Age\"]\n\t\t\t// \t\tMyValues[`Cost`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is data \n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\t// The \"Name\" of the Object contained too the left of the bracket\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\t// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.\n\t\t\t\t// This is a rare case where Arrays testing as Objects is useful\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// The \"Reference\" to the property within it, either an array element or object property\n\t\t\t\tlet tmpBoxedPropertyReference = pAddress.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\t\t\t\t// Attempt to parse the reference as a number, which will be used as an array element\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to treat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynamic object property.\n\t\t\t\t\t// We would expect the property to be wrapped in some kind of quotes so strip them\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Return the value in the property\n\t\t\t\t\tpObject[tmpBoxedPropertyName][tmpBoxedPropertyReference] = pValue;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber] = pValue;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Now is the time in recursion to set the value in the object\n\t\t\t\tpObject[pAddress] = pValue;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpSubObjectName = pAddress.substring(0, tmpSeparatorIndex);\n\t\t\tlet tmpNewAddress = pAddress.substring(tmpSeparatorIndex+1);\n\n\t\t\t// Test if the tmpNewAddress is an array or object\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = tmpSubObjectName.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = tmpSubObjectName.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[42]\n\t\t\t// \t\tMyValues['Color']\n\t\t\t// \t\tMyValues[\"Weight\"]\n\t\t\t// \t\tMyValues[`Diameter`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is data \n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = tmpSubObjectName.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyReference = tmpSubObjectName.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[1].Tardy\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[\"JaneDoe\"].Grade\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an array, so the [\"JaneDoe\"].Grade is not possible to access\n\t\t\t\t// TODO: Should this be an error or something?  Should we keep a log of failures like this?\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//This is a bracketed value\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to reat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynanmic object property.\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Recurse directly into the subobject\n\t\t\t\t\treturn this.setValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference], tmpNewAddress, pValue);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// We parsed a valid number out of the boxed property name, so recurse into the array\n\t\t\t\t\treturn this.setValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber], tmpNewAddress, pValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there is an object property already named for the sub object, but it isn't an object\n\t\t\t// then the system can't set the value in there.  Error and abort!\n\t\t\tif (pObject.hasOwnProperty(tmpSubObjectName) && typeof(pObject[tmpSubObjectName]) !== 'object')\n\t\t\t{\n\t\t\t\tif (!pObject.hasOwnProperty('__ERROR'))\n\t\t\t\t\tpObject['__ERROR'] = {};\n\t\t\t\t// Put it in an error object so data isn't lost\n\t\t\t\tpObject['__ERROR'][pAddress] = pValue;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (pObject.hasOwnProperty(tmpSubObjectName))\n\t\t\t{\n\t\t\t\t// If there is already a subobject pass that to the recursive thingy\n\t\t\t\treturn this.setValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, pValue);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Create a subobject and then pass that\n\t\t\t\tpObject[tmpSubObjectName] = {};\n\t\t\t\treturn this.setValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, pValue);\n\t\t\t}\n\t\t}\n\t}\n};\n\nmodule.exports = ManyfestObjectAddressResolver;","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\n/**\n* Schema Manipulation Functions\n*\n* @class ManyfestSchemaManipulation\n*/\nclass ManyfestSchemaManipulation\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) === 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) === 'function') ? pErrorLog : libSimpleLog;\n\t}\n\n    // This translates the default address mappings to something different.\n    //\n    // For instance you can pass in manyfest schema descriptor object:\n    // \t{\n\t//\t  \"Address.Of.a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t//\t  \"Address.Of.b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t//  }\n    //\n    //\n    // And then an address mapping (basically a Hash->Address map)\n    //  {\n    //    \"a\": \"New.Address.Of.a\",\n    //    \"b\": \"New.Address.Of.b\"  \n    //  }\n    //\n    // NOTE: This mutates the schema object permanently, altering the base hash.\n    //       If there is a collision with an existing address, it can lead to overwrites.\n    // TODO: Discuss what should happen on collisions.\n\tresolveAddressMappings(pManyfestSchemaDescriptors, pAddressMapping)\n\t{\n\t\tif (typeof(pManyfestSchemaDescriptors) != 'object')\n\t\t{\n\t\t\tthis.logError(`Attempted to resolve address mapping but the descriptor was not an object.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (typeof(pAddressMapping) != 'object')\n\t\t{\n\t\t\t// No mappings were passed in\n\t\t\treturn true;\n\t\t}\n\n\t\t// Get the arrays of both the schema definition and the hash mapping\n\t\tlet tmpManyfestAddresses = Object.keys(pManyfestSchemaDescriptors);\n\t\tlet tmpHashMapping = {};\n\t\ttmpManyfestAddresses.forEach(\n\t\t\t(pAddress) =>\n\t\t\t{\n\t\t\t\tif (pManyfestSchemaDescriptors[pAddress].hasOwnProperty('Hash'))\n\t\t\t\t{\n\t\t\t\t\ttmpHashMapping[pManyfestSchemaDescriptors[pAddress].Hash] = pAddress;\n\t\t\t\t}\n\t\t\t});\n\n\t\tlet tmpAddressMappingSet = Object.keys(pAddressMapping);\n\n\t\ttmpAddressMappingSet.forEach(\n\t\t\t(pInputAddress) =>\n\t\t\t{\n\t\t\t\tlet tmpNewDescriptorAddress = pAddressMapping[pInputAddress];\n\t\t\t\tlet tmpOldDescriptorAddress = false;\n\t\t\t\tlet tmpDescriptor = false;\n\n\t\t\t\t// See if there is a matching descriptor either by Address directly or Hash\n\t\t\t\tif (pManyfestSchemaDescriptors.hasOwnProperty(pInputAddress))\n\t\t\t\t{\n\t\t\t\t\ttmpOldDescriptorAddress = pInputAddress;\n\t\t\t\t}\n\t\t\t\telse if (tmpHashMapping.hasOwnProperty(pInputAddress))\n\t\t\t\t{\n\t\t\t\t\ttmpOldDescriptorAddress = tmpHashMapping[pInputAddress];\n\t\t\t\t}\n\n\t\t\t\t// If there was a matching descriptor in the manifest, store it in the temporary descriptor\n\t\t\t\tif (tmpOldDescriptorAddress)\n\t\t\t\t{\n\t\t\t\t\ttmpDescriptor = pManyfestSchemaDescriptors[tmpOldDescriptorAddress];\n\t\t\t\t\tdelete pManyfestSchemaDescriptors[tmpOldDescriptorAddress];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Create a new descriptor!  Map it to the input address.\n\t\t\t\t\ttmpDescriptor = { Hash:pInputAddress };\n\t\t\t\t}\n\n\t\t\t\t// Now re-add the descriptor to the manyfest schema\n\t\t\t\tpManyfestSchemaDescriptors[tmpNewDescriptorAddress] = tmpDescriptor;\n\t\t\t});\n\n\t\treturn true;\n\t}\n\n\tsafeResolveAddressMappings(pManyfestSchemaDescriptors, pAddressMapping)\n\t{\n\t\t// This returns the descriptors as a new object, safely remapping without mutating the original schema Descriptors\n\t\tlet tmpManyfestSchemaDescriptors = JSON.parse(JSON.stringify(pManyfestSchemaDescriptors));\n\t\tthis.resolveAddressMappings(tmpManyfestSchemaDescriptors, pAddressMapping);\n\t\treturn tmpManyfestSchemaDescriptors;\n\t}\n\n\tmergeAddressMappings(pManyfestSchemaDescriptorsDestination, pManyfestSchemaDescriptorsSource)\n\t{\n\t\tif ((typeof(pManyfestSchemaDescriptorsSource) != 'object') || (typeof(pManyfestSchemaDescriptorsDestination) != 'object'))\n\t\t{\n\t\t\tthis.logError(`Attempted to merge two schema descriptors but both were not objects.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpSource = JSON.parse(JSON.stringify(pManyfestSchemaDescriptorsSource));\n\t\tlet tmpNewManyfestSchemaDescriptors = JSON.parse(JSON.stringify(pManyfestSchemaDescriptorsDestination));\n\n\t\t// The first passed-in set of descriptors takes precedence.\n\t\tlet tmpDescriptorAddresses = Object.keys(tmpSource);\n\n\t\ttmpDescriptorAddresses.forEach(\n\t\t\t(pDescriptorAddress) => \n\t\t\t{\n\t\t\t\tif (!tmpNewManyfestSchemaDescriptors.hasOwnProperty(pDescriptorAddress))\n\t\t\t\t{\n\t\t\t\t\ttmpNewManyfestSchemaDescriptors[pDescriptorAddress] = tmpSource[pDescriptorAddress];\n\t\t\t\t}\n\t\t\t});\n\t\t\n\t\treturn tmpNewManyfestSchemaDescriptors;\n\t}\n}\n\nmodule.exports = ManyfestSchemaManipulation;","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\nlet libHashTranslation = require('./Manyfest-HashTranslation.js');\nlet libObjectAddressResolver = require('./Manyfest-ObjectAddressResolver.js');\nlet libObjectAddressGeneration = require('./Manyfest-ObjectAddressGeneration.js');\nlet libSchemaManipulation = require('./Manyfest-SchemaManipulation.js');\n\n\n/**\n* Manyfest object address-based descriptions and manipulations.\n*\n* @class Manyfest\n*/\nclass Manyfest\n{\n\tconstructor(pManifest, pInfoLog, pErrorLog, pOptions)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) === 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) === 'function') ? pErrorLog : libSimpleLog;\n\n\t\t// Create an object address resolver and map in the functions\n\t\tthis.objectAddressResolver = new libObjectAddressResolver(this.logInfo, this.logError);\n\n\t\tthis.options = (\n\t\t\t{\n\t\t\t\tstrict: false,\n\t\t\t\tdefaultValues: \n\t\t\t\t\t{\n\t\t\t\t\t\t\"String\": \"\",\n\t\t\t\t\t\t\"Number\": 0,\n\t\t\t\t\t\t\"Float\": 0.0,\n\t\t\t\t\t\t\"Integer\": 0,\n\t\t\t\t\t\t\"Boolean\": false,\n\t\t\t\t\t\t\"Binary\": 0,\n\t\t\t\t\t\t\"DateTime\": 0,\n\t\t\t\t\t\t\"Array\": [],\n\t\t\t\t\t\t\"Object\": {},\n\t\t\t\t\t\t\"Null\": null\n\t\t\t\t\t}\n\t\t\t});\n\n\t\tthis.scope = undefined;\n\t\tthis.elementAddresses = undefined;\n\t\tthis.elementHashes = undefined;\n\t\tthis.elementDescriptors = undefined;\n\n\t\tthis.reset();\n\n\t\tif (typeof(pManifest) === 'object')\n\t\t{\n\t\t\tthis.loadManifest(pManifest);\n\t\t}\n\n\t\tthis.schemaManipulations = new libSchemaManipulation(this.logInfo, this.logError);\n\t\tthis.objectAddressGeneration = new libObjectAddressGeneration(this.logInfo, this.logError);\n\n\t\tthis.hashTranslations = new libHashTranslation(this.logInfo, this.logError);\n\t}\n\n\t/*************************************************************************\n\t * Schema Manifest Loading, Reading, Manipulation and Serialization Functions\n\t */\n\n\t// Reset critical manifest properties\n\treset()\n\t{\n\t\tthis.scope = 'DEFAULT';\n\t\tthis.elementAddresses = [];\n\t\tthis.elementHashes = {};\n\t\tthis.elementDescriptors = {};\n\t}\n\n\tclone()\n\t{\n\t\t// Make a copy of the options in-place\n\t\tlet tmpNewOptions = JSON.parse(JSON.stringify(this.options));\n\n\t\tlet tmpNewManyfest = new Manyfest(this.getManifest(), this.logInfo, this.logError, tmpNewOptions);\n\n\t\t// Import the hash translations\n\t\ttmpNewManyfest.hashTranslations.addTranslation(this.hashTranslations.translationTable);\n\n\t\treturn tmpNewManyfest;\n\t}\n\n\t// Deserialize a Manifest from a string\n\tdeserialize(pManifestString)\n\t{\n\t\t// TODO: Add guards for bad manifest string\n\t\treturn this.loadManifest(JSON.parse(pManifestString));\n\t}\n\n\t// Load a manifest from an object\n\tloadManifest(pManifest)\n\t{\n\t\tif (typeof(pManifest) !== 'object')\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading manifest; expecting an object but parameter was type ${typeof(pManifest)}.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (pManifest.hasOwnProperty('Scope'))\n\t\t{\n\t\t\tif (typeof(pManifest.Scope) === 'string')\n\t\t\t{\n\t\t\t\tthis.scope = pManifest.Scope;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.logError(`(${this.scope}) Error loading scope from manifest; expecting a string but property was type ${typeof(pManifest.Scope)}.`, pManifest);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading scope from manifest object.  Property \"Scope\" does not exist in the root of the object.`, pManifest);\n\t\t}\n\n\t\tif (pManifest.hasOwnProperty('Descriptors'))\n\t\t{\n\t\t\tif (typeof(pManifest.Descriptors) === 'object')\n\t\t\t{\n\t\t\t\tlet tmpDescriptionAddresses = Object.keys(pManifest.Descriptors);\n\t\t\t\tfor (let i = 0; i < tmpDescriptionAddresses.length; i++)\n\t\t\t\t{\n\t\t\t\t\tthis.addDescriptor(tmpDescriptionAddresses[i], pManifest.Descriptors[tmpDescriptionAddresses[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.logError(`(${this.scope}) Error loading description object from manifest object.  Expecting an object in 'Manifest.Descriptors' but the property was type ${typeof(pManifest.Descriptors)}.`, pManifest);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading object description from manifest object.  Property \"Descriptors\" does not exist in the root of the Manifest object.`, pManifest);\n\t\t}\n\t}\n\n\t// Serialize the Manifest to a string\n\t// TODO: Should this also serialize the translation table?\n\tserialize()\n\t{\n\t\treturn JSON.stringify(this.getManifest());\n\t}\n\n\tgetManifest()\n\t{\n\t\treturn (\n\t\t\t{\n\t\t\t\tScope: this.scope,\n\t\t\t\tDescriptors: JSON.parse(JSON.stringify(this.elementDescriptors))\n\t\t\t});\n\t}\n\n\t// Add a descriptor to the manifest\n\taddDescriptor(pAddress, pDescriptor)\n\t{\n\t\tif (typeof(pDescriptor) === 'object')\n\t\t{\n\t\t\t// Add the Address into the Descriptor if it doesn't exist:\n\t\t\tif (!pDescriptor.hasOwnProperty('Address'))\n\t\t\t{\n\t\t\t\tpDescriptor.Address = pAddress;\n\t\t\t}\n\n\t\t\tif (!this.elementDescriptors.hasOwnProperty(pAddress))\n\t\t\t{\n\t\t\t\tthis.elementAddresses.push(pAddress);\n\t\t\t}\n\n\t\t\t// Add the element descriptor to the schema\n\t\t\tthis.elementDescriptors[pAddress] = pDescriptor;\n\n\t\t\t// Always add the address as a hash\n\t\t\tthis.elementHashes[pAddress] = pAddress;\n\n\t\t\tif (pDescriptor.hasOwnProperty('Hash'))\n\t\t\t{\n\t\t\t\t// TODO: Check if this is a good idea or not..\n\t\t\t\t//       Collisions are bound to happen with both representations of the address/hash in here and developers being able to create their own hashes.\n\t\t\t\tthis.elementHashes[pDescriptor.Hash] = pAddress;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpDescriptor.Hash = pAddress;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading object descriptor for address '${pAddress}' from manifest object.  Expecting an object but property was type ${typeof(pDescriptor)}.`);\n\t\t\treturn false;\n\t\t}\t\n\t}\n\n\tgetDescriptorByHash(pHash)\n\t{\n\t\treturn this.getDescriptor(this.resolveHashAddress(pHash));\n\t}\n\n\tgetDescriptor(pAddress)\n\t{\n\t\treturn this.elementDescriptors[pAddress];\n\t}\n\n\t/*************************************************************************\n\t * Beginning of Object Manipulation (read & write) Functions\n\t */\n\t// Check if an element exists by its hash\n\tcheckAddressExistsByHash (pObject, pHash)\n\t{\n\t\treturn this.checkAddressExists(pObject,this.resolveHashAddress(pHash));\n\t}\n\n\t// Check if an element exists at an address\n\tcheckAddressExists (pObject, pAddress)\n\t{\n\t\treturn this.objectAddressResolver.checkAddressExists(pObject, pAddress);\n\t}\n\n\t// Turn a hash into an address, factoring in the translation table.\n\tresolveHashAddress(pHash)\n\t{\n\t\tlet tmpAddress = undefined;\n\n\t\tlet tmpInElementHashTable = this.elementHashes.hasOwnProperty(pHash);\n\t\tlet tmpInTranslationTable = this.hashTranslations.translationTable.hasOwnProperty(pHash);\n\n\t\t// The most straightforward: the hash exists, no translations.\n\t\tif (tmpInElementHashTable && !tmpInTranslationTable)\n\t\t{\n\t\t\ttmpAddress = this.elementHashes[pHash];\n\t\t}\n\t\t// There is a translation from one hash to another, and, the elementHashes contains the pointer end\n\t\telse if (tmpInTranslationTable && this.elementHashes.hasOwnProperty(this.hashTranslations.translate(pHash)))\n\t\t{\n\t\t\ttmpAddress = this.elementHashes[this.hashTranslations.translate(pHash)];\n\t\t}\n\t\t// Use the level of indirection only in the Translation Table \n\t\telse if (tmpInTranslationTable)\n\t\t{\n\t\t\ttmpAddress = this.hashTranslations.translate(pHash);\n\t\t}\n\t\t// Just treat the hash as an address.\n\t\t// TODO: Discuss this ... it is magic but controversial\n\t\telse\n\t\t{\n\t\t\ttmpAddress = pHash;\n\t\t}\n\n\t\treturn tmpAddress;\n\t}\n\n\t// Get the value of an element by its hash\n\tgetValueByHash (pObject, pHash)\n\t{\n\t\tlet tmpValue = this.getValueAtAddress(pObject, this.resolveHashAddress(pHash));\n\n\t\tif (typeof(tmpValue) == 'undefined')\n\t\t{\n\t\t\t// Try to get a default if it exists\n\t\t\ttmpValue = this.getDefaultValue(this.getDescriptorByHash(pHash));\n\t\t}\n\n\t\treturn tmpValue;\n\t}\n\n\t// Get the value of an element at an address\n\tgetValueAtAddress (pObject, pAddress)\n\t{\n\t\tlet tmpValue = this.objectAddressResolver.getValueAtAddress(pObject, pAddress);\n\n\t\tif (typeof(tmpValue) == 'undefined')\n\t\t{\n\t\t\t// Try to get a default if it exists\n\t\t\ttmpValue = this.getDefaultValue(this.getDescriptor(pAddress));\n\t\t}\n\n\t\treturn tmpValue;\n\t}\n\n\t// Set the value of an element by its hash\n\tsetValueByHash(pObject, pHash, pValue)\n\t{\n\t\treturn this.setValueAtAddress(pObject, this.resolveHashAddress(pHash), pValue);\n\t}\n\n\n\t// Set the value of an element at an address\n\tsetValueAtAddress (pObject, pAddress, pValue)\n\t{\n\t\treturn this.objectAddressResolver.setValueAtAddress(pObject, pAddress, pValue);\n\t}\n\n\t// Validate the consistency of an object against the schema\n\tvalidate(pObject)\n\t{\n\t\tlet tmpValidationData =\n\t\t{\n\t\t\tError: null,\n\t\t\tErrors: [],\n\t\t\tMissingElements:[]\n\t\t};\n\n\t\tif (typeof(pObject) !== 'object')\n\t\t{\n\t\t\ttmpValidationData.Error = true;\n\t\t\ttmpValidationData.Errors.push(`Expected passed in object to be type object but was passed in ${typeof(pObject)}`);\n\t\t}\n\n\t\tlet addValidationError = (pAddress, pErrorMessage) =>\n\t\t{\n\t\t\ttmpValidationData.Error = true;\n\t\t\ttmpValidationData.Errors.push(`Element at address \"${pAddress}\" ${pErrorMessage}.`);\n\t\t};\n\n\t\t// Now enumerate through the values and check for anomalies based on the schema\n\t\tfor (let i = 0; i < this.elementAddresses.length; i++)\n\t\t{\n\t\t\tlet tmpDescriptor = this.getDescriptor(this.elementAddresses[i]);\n\t\t\tlet tmpValueExists = this.checkAddressExists(pObject, tmpDescriptor.Address);\n\t\t\tlet tmpValue = this.getValueAtAddress(pObject, tmpDescriptor.Address);\n\n\t\t\tif ((typeof(tmpValue) == 'undefined') || !tmpValueExists)\n\t\t\t{\n\t\t\t\t// This will technically mean that `Object.Some.Value = undefined` will end up showing as \"missing\"\n\t\t\t\t// TODO: Do we want to do a different message based on if the property exists but is undefined?\n\t\t\t\ttmpValidationData.MissingElements.push(tmpDescriptor.Address);\n\t\t\t\tif (tmpDescriptor.Required || this.options.strict)\n\t\t\t\t{\n\t\t\t\t\taddValidationError(tmpDescriptor.Address, 'is flagged REQUIRED but is not set in the object');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Now see if there is a data type specified for this element\n\t\t\tif (tmpDescriptor.DataType)\n\t\t\t{\n\t\t\t\tlet tmpElementType = typeof(tmpValue);\n\t\t\t\tswitch(tmpDescriptor.DataType.toString().trim().toLowerCase())\n\t\t\t\t{\n\t\t\t\t\tcase 'string':\n\t\t\t\t\t\tif (tmpElementType != 'string')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'number':\n\t\t\t\t\t\tif (tmpElementType != 'number')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'integer':\n\t\t\t\t\t\tif (tmpElementType != 'number')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlet tmpValueString = tmpValue.toString();\n\t\t\t\t\t\t\tif (tmpValueString.indexOf('.') > -1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// TODO: Is this an error?\n\t\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but has a decimal point in the number.`);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'float':\n\t\t\t\t\t\tif (tmpElementType != 'number')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'DateTime':\n\t\t\t\t\t\tlet tmpValueDate = new Date(tmpValue);\n\t\t\t\t\t\tif (tmpValueDate.toString() == 'Invalid Date')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is not parsable as a Date by Javascript`);\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// Check if this is a string, in the default case\n\t\t\t\t\t\t// Note this is only when a DataType is specified and it is an unrecognized data type.\n\t\t\t\t\t\tif (tmpElementType != 'string')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} (which auto-converted to String because it was unrecognized) but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn tmpValidationData;\n\t}\n\n\t// Returns a default value, or, the default value for the data type (which is overridable with configuration)\n\tgetDefaultValue(pDescriptor)\n\t{\n\t\tif (typeof(pDescriptor) != 'object')\n\t\t{\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (pDescriptor.hasOwnProperty('Default'))\n\t\t{\n\t\t\treturn pDescriptor.Default;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Default to a null if it doesn't have a type specified.\n\t\t\t// This will ensure a placeholder is created but isn't misinterpreted.\n\t\t\tlet tmpDataType = (pDescriptor.hasOwnProperty('DataType')) ? pDescriptor.DataType : 'String';\n\t\t\tif (this.options.defaultValues.hasOwnProperty(tmpDataType))\n\t\t\t{\n\t\t\t\treturn this.options.defaultValues[tmpDataType];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// give up and return null\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Enumerate through the schema and populate default values if they don't exist.\n\tpopulateDefaults(pObject, pOverwriteProperties)\n\t{\n\t\treturn this.populateObject(pObject, pOverwriteProperties,\n\t\t\t// This just sets up a simple filter to see if there is a default set.\n\t\t\t(pDescriptor) =>\n\t\t\t{\n\t\t\t\treturn pDescriptor.hasOwnProperty('Default');\n\t\t\t});\n\t}\n\n\t// Forcefully populate all values even if they don't have defaults.\n\t// Based on type, this can do unexpected things.\n\tpopulateObject(pObject, pOverwriteProperties, fFilter)\n\t{\n\t\t// Automatically create an object if one isn't passed in.\n\t\tlet tmpObject = (typeof(pObject) === 'object') ? pObject : {};\n\t\t// Default to *NOT OVERWRITING* properties\n\t\tlet tmpOverwriteProperties = (typeof(pOverwriteProperties) == 'undefined') ? false : pOverwriteProperties;\n\t\t// This is a filter function, which is passed the schema and allows complex filtering of population\n\t\t// The default filter function just returns true, populating everything.\n\t\tlet tmpFilterFunction = (typeof(fFilter) == 'function') ? fFilter : (pDescriptor) => { return true; };\n\n\t\tthis.elementAddresses.forEach(\n\t\t\t(pAddress) =>\n\t\t\t{\n\t\t\t\tlet tmpDescriptor = this.getDescriptor(pAddress);\n\t\t\t\t// Check the filter function to see if this is an address we want to set the value for.\n\t\t\t\tif (tmpFilterFunction(tmpDescriptor))\n\t\t\t\t{\n\t\t\t\t\t// If we are overwriting properties OR the property does not exist\n\t\t\t\t\tif (tmpOverwriteProperties || !this.checkAddressExists(tmpObject, pAddress))\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.setValueAtAddress(tmpObject, pAddress, this.getDefaultValue(tmpDescriptor));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn tmpObject;\n\t}\n};\n\nmodule.exports = Manyfest;","/**\n* Precedent Meta-Templating\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Process text streams, parsing out meta-template expressions.\n*/\nvar libWordTree = require(`./WordTree.js`);\nvar libStringParser = require(`./StringParser.js`);\n\nclass Precedent\n{\n\t/**\n\t * Precedent Constructor\n\t */\n\tconstructor()\n\t{\n\t\tthis.WordTree = new libWordTree();\n\t\t\n\t\tthis.StringParser = new libStringParser();\n\n\t\tthis.ParseTree = this.WordTree.ParseTree;\n\t}\n\t\n\t/**\n\t * Add a Pattern to the Parse Tree\n\t * @method addPattern\n\t * @param {Object} pTree - A node on the parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @param {number} pIndex - callback function\n\t * @return {bool} True if adding the pattern was successful\n\t */\n\taddPattern(pPatternStart, pPatternEnd, pParser)\n\t{\n\t\treturn this.WordTree.addPattern(pPatternStart, pPatternEnd, pParser);\n\t}\n\t\n\t/**\n\t * Parse a string with the existing parse tree\n\t * @method parseString\n\t * @param {string} pString - The string to parse\n\t * @return {string} The result from the parser\n\t */\n\tparseString(pString)\n\t{\n\t\treturn this.StringParser.parseString(pString, this.ParseTree);\n\t}\n}\n\nmodule.exports = Precedent;\n","/**\n* String Parser\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Parse a string, properly processing each matched token in the word tree.\n*/\n\nclass StringParser\n{\n\t/**\n\t * StringParser Constructor\n\t */\n\tconstructor()\n\t{\n\t}\n\t\n\t/**\n\t * Create a fresh parsing state object to work with.\n\t * @method newParserState\n\t * @param {Object} pParseTree - A node on the parse tree to begin parsing from (usually root)\n\t * @return {Object} A new parser state object for running a character parser on\n\t * @private\n\t */\n\tnewParserState (pParseTree)\n\t{\n\t\treturn (\n\t\t{\n\t\t    ParseTree: pParseTree,\n\n\t\t\tOutput: '',\n\t\t\tOutputBuffer: '',\n\n\t\t\tPattern: false,\n\n\t\t\tPatternMatch: false,\n\t\t\tPatternMatchOutputBuffer: ''\n\t\t});\n\t}\n\t\t\n\t/**\n\t * Assign a node of the parser tree to be the next potential match.\n\t * If the node has a PatternEnd property, it is a valid match and supercedes the last valid match (or becomes the initial match).\n\t * @method assignNode\n\t * @param {Object} pNode - A node on the parse tree to assign\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tassignNode (pNode, pParserState)\n\t{\n\t\tpParserState.PatternMatch = pNode;\n\n\t\t// If the pattern has a END we can assume it has a parse function...\n\t\tif (pParserState.PatternMatch.hasOwnProperty('PatternEnd'))\n\t\t{\n\t\t\t// ... this is the legitimate start of a pattern.\n\t\t\tpParserState.Pattern = pParserState.PatternMatch;\n\t\t}\n\t}\n\t\n\t/**\n\t * Append a character to the output buffer in the parser state.\n\t * This output buffer is used when a potential match is being explored, or a match is being explored.\n\t * @method appendOutputBuffer\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tappendOutputBuffer (pCharacter, pParserState)\n\t{\n\t\tpParserState.OutputBuffer += pCharacter;\n\t}\n\t\n\t/**\n\t * Flush the output buffer to the output and clear it.\n\t * @method flushOutputBuffer\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tflushOutputBuffer (pParserState)\n\t{\n\t\tpParserState.Output += pParserState.OutputBuffer;\n\t\tpParserState.OutputBuffer = '';\n\t}\n\n\t\n\t/**\n\t * Check if the pattern has ended.  If it has, properly flush the buffer and start looking for new patterns.\n\t * @method checkPatternEnd\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tcheckPatternEnd (pParserState)\n\t{\n\t\tif ((pParserState.OutputBuffer.length >= pParserState.Pattern.PatternEnd.length+pParserState.Pattern.PatternStart.length) && \n\t\t\t(pParserState.OutputBuffer.substr(-pParserState.Pattern.PatternEnd.length) === pParserState.Pattern.PatternEnd))\n\t\t{\n\t\t\t// ... this is the end of a pattern, cut off the end tag and parse it.\n\t\t\t// Trim the start and end tags off the output buffer now\n\t\t\tpParserState.OutputBuffer = pParserState.Pattern.Parse(pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStart.length, pParserState.OutputBuffer.length - (pParserState.Pattern.PatternStart.length+pParserState.Pattern.PatternEnd.length)));\n\t\t\t// Flush the output buffer.\n\t\t\tthis.flushOutputBuffer(pParserState);\n\t\t\t// End pattern mode\n\t\t\tpParserState.Pattern = false;\n\t\t\tpParserState.PatternMatch = false;\n\t\t}\n\t}\n\t\n\t/**\n\t * Parse a character in the buffer.\n\t * @method parseCharacter\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tparseCharacter (pCharacter, pParserState)\n\t{\n\t\t// (1) If we aren't in a pattern match, and we aren't potentially matching, and this may be the start of a new pattern....\n\t\tif (!pParserState.PatternMatch && pParserState.ParseTree.hasOwnProperty(pCharacter))\n\t\t{\n\t\t\t// ... assign the node as the matched node.\n\t\t\tthis.assignNode(pParserState.ParseTree[pCharacter], pParserState);\n\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t}\n\t\t// (2) If we are in a pattern match (actively seeing if this is part of a new pattern token)\n\t\telse if (pParserState.PatternMatch)\n\t\t{\n\t\t\t// If the pattern has a subpattern with this key\n\t\t\tif (pParserState.PatternMatch.hasOwnProperty(pCharacter))\n\t\t\t{\n\t\t\t\t// Continue matching patterns.\n\t\t\t\tthis.assignNode(pParserState.PatternMatch[pCharacter], pParserState);\n\t\t\t}\n\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\tif (pParserState.Pattern)\n\t\t\t{\n\t\t\t\t// ... Check if this is the end of the pattern (if we are matching a valid pattern)...\n\t\t\t\tthis.checkPatternEnd(pParserState);\n\t\t\t}\n\t\t}\n\t\t// (3) If we aren't in a pattern match or pattern, and this isn't the start of a new pattern (RAW mode)....\n\t\telse\n\t\t{\n\t\t\tpParserState.Output += pCharacter;\n\t\t}\n\t}\n\t\n\t/**\n\t * Parse a string for matches, and process any template segments that occur.\n\t * @method parseString\n\t * @param {string} pString - The string to parse.\n\t * @param {Object} pParseTree - The parse tree to begin parsing from (usually root)\n\t */\n\tparseString (pString, pParseTree)\n\t{\n\t\tlet tmpParserState = this.newParserState(pParseTree);\n\n\t\tfor (var i = 0; i < pString.length; i++)\n\t\t{\n\t\t\t// TODO: This is not fast.\n\t\t\tthis.parseCharacter(pString[i], tmpParserState);\n\t\t}\n\t\t\n\t\tthis.flushOutputBuffer(tmpParserState);\n\t\t\n\t\treturn tmpParserState.Output;\n\t}\n}\n\nmodule.exports = StringParser;\n","/**\n* Word Tree\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Create a tree (directed graph) of Javascript objects, one character per object.\n*/\n\nclass WordTree\n{\n\t/**\n\t * WordTree Constructor\n\t */\n\tconstructor()\n\t{\n\t\tthis.ParseTree = {};\n\t}\n\t\n\t/** \n\t * Add a child character to a Parse Tree node\n\t * @method addChild\n\t * @param {Object} pTree - A parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @param {number} pIndex - callback function\n\t * @returns {Object} The resulting leaf node that was added (or found)\n\t * @private\n\t */\n\taddChild (pTree, pPattern, pIndex)\n\t{\n\t\tif (pIndex > pPattern.length)\n\t\t\treturn pTree;\n\t\t\n\t\tif (!pTree.hasOwnProperty(pPattern[pIndex]))\n\t\t\tpTree[pPattern[pIndex]] = {};\n\t\t\n\t\treturn pTree[pPattern[pIndex]];\n\t}\n\t\n\t/** Add a Pattern to the Parse Tree\n\t * @method addPattern\n\t * @param {Object} pTree - A node on the parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @param {number} pIndex - callback function\n\t * @return {bool} True if adding the pattern was successful\n\t */\n\taddPattern (pPatternStart, pPatternEnd, pParser)\n\t{\n\t\tif (pPatternStart.length < 1)\n\t\t\treturn false;\n\n\t\tlet tmpLeaf = this.ParseTree;\n\n\t\t// Add the tree of leaves iteratively\n\t\tfor (var i = 0; i < pPatternStart.length; i++)\n\t\t\ttmpLeaf = this.addChild(tmpLeaf, pPatternStart, i);\n\n\t\ttmpLeaf.PatternStart = pPatternStart;\n\t\ttmpLeaf.PatternEnd = ((typeof(pPatternEnd) === 'string') && (pPatternEnd.length > 0)) ? pPatternEnd : pPatternStart;\n\t\ttmpLeaf.Parse = (typeof(pParser) === 'function') ? pParser : \n\t\t\t\t\t\t(typeof(pParser) === 'string') ? () => { return pParser; } :\n\t\t\t\t\t\t(pData) => { return pData; };\n\n\t\treturn true;\n\t}\n}\n\nmodule.exports = WordTree;\n","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\n/**\n* Manyfest browser shim loader\n*/\n\n// Load the manyfest module into the browser global automatically.\nvar libManyfest = require('./Manyfest.js');\n\nif (typeof(window) === 'object') window.Manyfest = libManyfest;\n\nmodule.exports = libManyfest;","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\nlet libPrecedent = require('precedent');\n\n/**\n* Object Address Resolver\n* \n* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to\n*                 be extremely clear what is going on in the recursion for\n*                 each of the three address resolution functions.\n* \n*                 Although there is some opportunity to repeat ourselves a\n*                 bit less in this codebase (e.g. with detection of arrays\n*                 versus objects versus direct properties), it can make\n*                 debugging.. challenging.  The minified version of the code\n*                 optimizes out almost anything repeated in here.  So please\n*                 be kind and rewind... meaning please keep the codebase less\n*                 terse and more verbose so humans can comprehend it.\n*                 \n* TODO: Once we validate this pattern is good to go, break these out into \n*       three separate modules.\n*\n* @class ManyfestObjectAddressResolver\n*/\nclass ManyfestObjectAddressResolver\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) == 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) == 'function') ? pErrorLog : libSimpleLog;\n\n\t\tthis.elucidatorSolver = false;\n\t\tthis.elucidatorSolverState = {};\n\t}\n\n\t// When a boxed property is passed in, it should have quotes of some\n\t// kind around it.\n\t//\n\t// For instance:\n\t// \t\tMyValues['Name']\n\t// \t\tMyValues[\"Age\"]\n\t// \t\tMyValues[`Cost`]\n\t//\n\t// This function removes the wrapping quotes.\n\t//\n\t// Please note it *DOES NOT PARSE* template literals, so backticks just\n\t// end up doing the same thing as other quote types.\n\t//\n\t// TODO: Should template literals be processed?  If so what state do they have access to?\n\tcleanWrapCharacters (pCharacter, pString)\n\t{\n\t\tif (pString.startsWith(pCharacter) && pString.endsWith(pCharacter))\n\t\t{\n\t\t\treturn pString.substring(1, pString.length - 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn pString;\n\t\t}\n\t}\n\n\t// Check if an address exists.\n\t//\n\t// This is necessary because the getValueAtAddress function is ambiguous on \n\t// whether the element/property is actually there or not (it returns \n\t// undefined whether the property exists or not).  This function checks for\n\t// existance and returns true or false dependent.\n\tcheckAddressExists (pObject, pAddress)\n\t{\n\t\t// TODO: Should these throw an error?\n\t\t// Make sure pObject is an object\n\t\tif (typeof(pObject) != 'object') return false;\n\t\t// Make sure pAddress is a string\n\t\tif (typeof(pAddress) != 'string') return false;\n\n\t\t// TODO: Make this work for things like SomeRootObject.Metadata[\"Some.People.Use.Bad.Object.Property.Names\"]\n\t\tlet tmpSeparatorIndex = pAddress.indexOf('.');\n\n\t\t// This is the terminal address string (no more dots so the RECUSION ENDS IN HERE somehow)\n\t\tif (tmpSeparatorIndex == -1)\n\t\t{\n\t\t\t// Check if the address refers to a boxed property\n\t\t\tlet tmpBracketStartIndex = pAddress.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = pAddress.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[10]\n\t\t\t// \t\tMyValues['Name']\n\t\t\t// \t\tMyValues[\"Age\"]\n\t\t\t// \t\tMyValues[`Cost`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is data \n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\t// The \"Name\" of the Object contained too the left of the bracket\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\t// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.\n\t\t\t\t// This is a rare case where Arrays testing as Objects is useful\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// The \"Reference\" to the property within it, either an array element or object property\n\t\t\t\tlet tmpBoxedPropertyReference = pAddress.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\t\t\t\t// Attempt to parse the reference as a number, which will be used as an array element\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to treat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynamic object property.\n\t\t\t\t\t// We would expect the property to be wrapped in some kind of quotes so strip them\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Check if the property exists.\n\t\t\t\t\treturn pObject[tmpBoxedPropertyName].hasOwnProperty(tmpBoxedPropertyReference);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Use the new in operator to see if the element is in the array\n\t\t\t\t\treturn (tmpBoxedPropertyNumber in pObject[tmpBoxedPropertyName]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Check if the property exists\n\t\t\t\treturn pObject.hasOwnProperty(pAddress);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpSubObjectName = pAddress.substring(0, tmpSeparatorIndex);\n\t\t\tlet tmpNewAddress = pAddress.substring(tmpSeparatorIndex+1);\n\n\t\t\t// Test if the tmpNewAddress is an array or object\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = tmpSubObjectName.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = tmpSubObjectName.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[42]\n\t\t\t// \t\tMyValues['Color']\n\t\t\t// \t\tMyValues[\"Weight\"]\n\t\t\t// \t\tMyValues[`Diameter`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is data \n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = tmpSubObjectName.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyReference = tmpSubObjectName.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[1].Tardy\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[\"JaneDoe\"].Grade\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an array, so the [\"JaneDoe\"].Grade is not possible to access\n\t\t\t\t// TODO: Should this be an error or something?  Should we keep a log of failures like this?\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// Because this is an impossible address, the property doesn't exist\n\t\t\t\t\t// TODO: Should we throw an error in this condition?\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//This is a bracketed value\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to reat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynanmic object property.\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Recurse directly into the subobject\n\t\t\t\t\treturn this.checkAddressExists(pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference], tmpNewAddress);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// We parsed a valid number out of the boxed property name, so recurse into the array\n\t\t\t\t\treturn this.checkAddressExists(pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber], tmpNewAddress);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there is an object property already named for the sub object, but it isn't an object\n\t\t\t// then the system can't set the value in there.  Error and abort!\n\t\t\tif (pObject.hasOwnProperty(tmpSubObjectName) && typeof(pObject[tmpSubObjectName]) !== 'object')\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (pObject.hasOwnProperty(tmpSubObjectName))\n\t\t\t{\n\t\t\t\t// If there is already a subobject pass that to the recursive thingy\n\t\t\t\treturn this.checkAddressExists(pObject[tmpSubObjectName], tmpNewAddress);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Create a subobject and then pass that\n\t\t\t\tpObject[tmpSubObjectName] = {};\n\t\t\t\treturn this.checkAddressExists(pObject[tmpSubObjectName], tmpNewAddress);\n\t\t\t}\n\t\t}\n\t}\n\n\tcheckFilters(pAddress, pRecord)\n\t{\n\t\tlet tmpPrecedent = new libPrecedent();\n\t\t// If we don't copy the string, precedent takes it out for good.\n\t\t// TODO: Consider adding a \"don't replace\" option for precedent\n\t\tlet tmpAddress = pAddress;\n\n\t\tif (!this.elucidatorSolver)\n\t\t{\n\t\t\t// Again, manage against circular dependencies\n\t\t\tlet libElucidator = require('elucidator');\n\t\t\tthis.elucidatorSolver = new libElucidator({}, this.logInfo, this.logError);\n\t\t}\n\n\t\tif (this.elucidatorSolver)\n\t\t{\n\t\t\t// This allows the magic filtration with elucidator configuration\n\t\t\t// TODO: We could pass more state in (e.g. parent address, object, etc.)\n\t\t\t// TODO: Discuss this metaprogramming AT LENGTH\n\t\t\tlet tmpFilterState = (\n\t\t\t\t{\n\t\t\t\t\tRecord: pRecord,\n\t\t\t\t\tkeepRecord: true \n\t\t\t\t});\n\n\t\t\t// This is about as complex as it gets.\n\t\t\t// TODO: Optimize this so it is only initialized once.\n\t\t\t// TODO: That means figuring out a healthy pattern for passing in state to this\n\t\t\ttmpPrecedent.addPattern('<<~~', '~~>>',\n\t\t\t\t(pInstructionHash) => \n\t\t\t\t{\n\t\t\t\t\t// This is for internal config on the solution steps.  Right now config is not shared across steps.\n\t\t\t\t\tif (this.elucidatorSolverState.hasOwnProperty(pInstructionHash))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpFilterState.SolutionState = this.elucidatorSolverState[pInstructionHash];\n\t\t\t\t\t}\n\t\t\t\t\tthis.elucidatorSolver.solveInternalOperation('Custom', pInstructionHash, tmpFilterState);\n\t\t\t\t});\n\t\t\ttmpPrecedent.addPattern('<<~?', '?~>>',\n\t\t\t\t(pMagicSearchExpression) => \n\t\t\t\t{\n\t\t\t\t\tif (typeof(pMagicSearchExpression) !== 'string')\n\t\t\t\t\t{\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t// This expects a comma separated expression:\n\t\t\t\t\t//     Some.Address.In.The.Object,==,Search Term to Match\n\t\t\t\t\tlet tmpMagicComparisonPatternSet = pMagicSearchExpression.split(',');\n\n\t\t\t\t\tlet tmpSearchAddress = tmpMagicComparisonPatternSet[0];\n\t\t\t\t\tlet tmpSearchComparator = tmpMagicComparisonPatternSet[1];\n\t\t\t\t\tlet tmpSearchValue = tmpMagicComparisonPatternSet[2];\n\n\t\t\t\t\ttmpFilterState.ComparisonState = (\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSearchAddress: tmpSearchAddress,\n\t\t\t\t\t\t\tComparator: tmpSearchComparator,\n\t\t\t\t\t\t\tSearchTerm: tmpSearchValue\n\t\t\t\t\t\t});\n\n\t\t\t\t\tthis.elucidatorSolver.solveOperation(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"Description\":\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"Operation\": \"Simple_If\",\n\t\t\t\t\t\t\t\t\"Synopsis\": \"Test for \"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"Steps\":\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"Namespace\": \"Logic\",\n\t\t\t\t\t\t\t\t\t\"Instruction\": \"if\",\n\t\t\n\t\t\t\t\t\t\t\t\t\"InputHashAddressMap\": \n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t// This is ... dynamically assigning the address in the instruction\n\t\t\t\t\t\t\t\t\t\t\t// The complexity is astounding.\n\t\t\t\t\t\t\t\t\t\t\t\"leftValue\": `Record.${tmpSearchAddress}`,\n\t\t\t\t\t\t\t\t\t\t\t\"rightValue\": \"ComparisonState.SearchTerm\",\n\t\t\t\t\t\t\t\t\t\t\t\"comparator\": \"ComparisonState.Comparator\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\"OutputHashAddressMap\": { \"truthinessResult\":\"keepRecord\" }\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t}, tmpFilterState);\n\t\t\t\t});\n\t\t\ttmpPrecedent.parseString(tmpAddress);\n\n\t\t\t// It is expected that the operation will mutate this to some truthy value\n\t\t\treturn tmpFilterState.keepRecord;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// Get the value of an element at an address\n\tgetValueAtAddress (pObject, pAddress, pParentAddress)\n\t{\n\t\t// Make sure pObject (the object we are meant to be recursing) is an object (which could be an array or object)\n\t\tif (typeof(pObject) != 'object') return undefined;\n\t\t// Make sure pAddress (the address we are resolving) is a string\n\t\tif (typeof(pAddress) != 'string') return undefined;\n\t\t// Stash the parent address for later resolution\n\t\tlet tmpParentAddress = \"\";\n\t\tif (typeof(pParentAddress) == 'string')\n\t\t{\n\t\t\ttmpParentAddress = pParentAddress;\n\t\t}\n\n\t\t// TODO: Make this work for things like SomeRootObject.Metadata[\"Some.People.Use.Bad.Object.Property.Names\"]\n\t\tlet tmpSeparatorIndex = pAddress.indexOf('.');\n\n\t\t// This is the terminal address string (no more dots so the RECUSION ENDS IN HERE somehow)\n\t\tif (tmpSeparatorIndex == -1)\n\t\t{\n\t\t\t// Check if the address refers to a boxed property\n\t\t\tlet tmpBracketStartIndex = pAddress.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = pAddress.indexOf(']');\n\n\t\t\t// Check for the Object Set Type marker.\n\t\t\t// Note this will not work with a bracket in the same address box set\n\t\t\tlet tmpObjectTypeMarkerIndex = pAddress.indexOf('{}');\n\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[10]\n\t\t\t// \t\tMyValues['Name']\n\t\t\t// \t\tMyValues[\"Age\"]\n\t\t\t// \t\tMyValues[`Cost`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is data \n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\t// The \"Name\" of the Object contained too the left of the bracket\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\t// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.\n\t\t\t\t// This is a rare case where Arrays testing as Objects is useful\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\t// The \"Reference\" to the property within it, either an array element or object property\n\t\t\t\tlet tmpBoxedPropertyReference = pAddress.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\t\t\t\t// Attempt to parse the reference as a number, which will be used as an array element\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to treat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynamic object property.\n\t\t\t\t\t// We would expect the property to be wrapped in some kind of quotes so strip them\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Return the value in the property\n\t\t\t\t\treturn pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// The requirements to detect a boxed set element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is nothing in the brackets\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex == 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tif (!Array.isArray(pObject[tmpBoxedPropertyName]))\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tlet tmpInputArray = pObject[tmpBoxedPropertyName];\n\t\t\t\tlet tmpOutputArray = [];\n\t\t\t\tfor (let i = 0; i < tmpInputArray.length; i++)\n\t\t\t\t{\n\t\t\t\t\t// The filtering is complex but allows config-based metaprogramming directly from schema\n\t\t\t\t\tlet tmpKeepRecord = this.checkFilters(pAddress, tmpInputArray[i]);\n\t\t\t\t\tif (tmpKeepRecord)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpOutputArray.push(tmpInputArray[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmpOutputArray;\n\t\t\t}\n\t\t\t// The object has been flagged as an object set, so treat it as such\n\t\t\telse if (tmpObjectTypeMarkerIndex > 0)\n\t\t\t{\n\t\t\t\tlet tmpObjectPropertyName = pAddress.substring(0, tmpObjectTypeMarkerIndex).trim();\n\n\t\t\t\tif (typeof(pObject[tmpObjectPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\treturn pObject[tmpObjectPropertyName];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Now is the point in recursion to return the value in the address\n\t\t\t\treturn pObject[pAddress];\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpSubObjectName = pAddress.substring(0, tmpSeparatorIndex);\n\t\t\tlet tmpNewAddress = pAddress.substring(tmpSeparatorIndex+1);\n\n\t\t\t// BOXED ELEMENTS\n\t\t\t// Test if the tmpNewAddress is an array or object\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = tmpSubObjectName.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = tmpSubObjectName.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[42]\n\t\t\t// \t\tMyValues['Color']\n\t\t\t// \t\tMyValues[\"Weight\"]\n\t\t\t// \t\tMyValues[`Diameter`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is data \n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = tmpSubObjectName.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyReference = tmpSubObjectName.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[1].Tardy\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[\"JaneDoe\"].Grade\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an array, so the [\"JaneDoe\"].Grade is not possible to access\n\t\t\t\t// TODO: Should this be an error or something?  Should we keep a log of failures like this?\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\t//This is a bracketed value\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to reat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynanmic object property.\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\t\t// Recurse directly into the subobject\n\t\t\t\t\treturn this.getValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference], tmpNewAddress, tmpParentAddress);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\t\t// We parsed a valid number out of the boxed property name, so recurse into the array\n\t\t\t\t\treturn this.getValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber], tmpNewAddress, tmpParentAddress);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// The requirements to detect a boxed set element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is nothing in the brackets\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex == 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tif (!Array.isArray(pObject[tmpBoxedPropertyName]))\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// We need to enumerate the array and grab the addresses from there.\n\t\t\t\tlet tmpArrayProperty = pObject[tmpBoxedPropertyName];\n\t\t\t\t// Managing the parent address is a bit more complex here -- the box will be added for each element.\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpBoxedPropertyName}`;\n\t\t\t\t// The container object is where we have the \"Address\":SOMEVALUE pairs\n\t\t\t\tlet tmpContainerObject = {};\n\t\t\t\tfor (let i = 0; i < tmpArrayProperty.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpPropertyParentAddress = `${tmpParentAddress}[${i}]`;\n\t\t\t\t\tlet tmpValue = this.getValueAtAddress(pObject[tmpBoxedPropertyName][i], tmpNewAddress, tmpPropertyParentAddress);\n\t\t\t\t\t\n\t\t\t\t\ttmpContainerObject[`${tmpPropertyParentAddress}.${tmpNewAddress}`] = tmpValue;\n\t\t\t\t}\n\n\t\t\t\treturn tmpContainerObject;\n\t\t\t}\n\n\t\t\t// OBJECT SET\n\t\t\t// Note this will not work with a bracket in the same address box set\n\t\t\tlet tmpObjectTypeMarkerIndex = pAddress.indexOf('{}');\n\t\t\tif (tmpObjectTypeMarkerIndex > 0)\n\t\t\t{\n\t\t\t\tlet tmpObjectPropertyName = pAddress.substring(0, tmpObjectTypeMarkerIndex).trim();\n\n\t\t\t\tif (typeof(pObject[tmpObjectPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// We need to enumerate the Object and grab the addresses from there.\n\t\t\t\tlet tmpObjectProperty = pObject[tmpObjectPropertyName];\n\t\t\t\tlet tmpObjectPropertyKeys = Object.keys(tmpObjectProperty);\n\t\t\t\t// Managing the parent address is a bit more complex here -- the box will be added for each element.\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpObjectPropertyName}`;\n\t\t\t\t// The container object is where we have the \"Address\":SOMEVALUE pairs\n\t\t\t\tlet tmpContainerObject = {};\n\t\t\t\tfor (let i = 0; i < tmpObjectPropertyKeys.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpPropertyParentAddress = `${tmpParentAddress}.${tmpObjectPropertyKeys[i]}`;\n\t\t\t\t\tlet tmpValue = this.getValueAtAddress(pObject[tmpObjectPropertyName][tmpObjectPropertyKeys[i]], tmpNewAddress, tmpPropertyParentAddress);\n\t\n\t\t\t\t\t// The filtering is complex but allows config-based metaprogramming directly from schema\n\t\t\t\t\tlet tmpKeepRecord = this.checkFilters(pAddress, tmpValue);\n\t\t\t\t\tif (tmpKeepRecord)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpContainerObject[`${tmpPropertyParentAddress}.${tmpNewAddress}`] = tmpValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmpContainerObject;\n\t\t\t}\n\n\t\t\t// If there is an object property already named for the sub object, but it isn't an object\n\t\t\t// then the system can't set the value in there.  Error and abort!\n\t\t\tif (pObject.hasOwnProperty(tmpSubObjectName) && typeof(pObject[tmpSubObjectName]) !== 'object')\n\t\t\t{\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\telse if (pObject.hasOwnProperty(tmpSubObjectName))\n\t\t\t{\n\t\t\t\t// If there is already a subobject pass that to the recursive thingy\n\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\treturn this.getValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, tmpParentAddress);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Create a subobject and then pass that\n\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\tpObject[tmpSubObjectName] = {};\n\t\t\t\treturn this.getValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, tmpParentAddress);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the value of an element at an address\n\tsetValueAtAddress (pObject, pAddress, pValue)\n\t{\n\t\t// Make sure pObject is an object\n\t\tif (typeof(pObject) != 'object') return false;\n\t\t// Make sure pAddress is a string\n\t\tif (typeof(pAddress) != 'string') return false;\n\n\t\tlet tmpSeparatorIndex = pAddress.indexOf('.');\n\n\t\tif (tmpSeparatorIndex == -1)\n\t\t{\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = pAddress.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = pAddress.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[10]\n\t\t\t// \t\tMyValues['Name']\n\t\t\t// \t\tMyValues[\"Age\"]\n\t\t\t// \t\tMyValues[`Cost`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is data \n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\t// The \"Name\" of the Object contained too the left of the bracket\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\t// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.\n\t\t\t\t// This is a rare case where Arrays testing as Objects is useful\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// The \"Reference\" to the property within it, either an array element or object property\n\t\t\t\tlet tmpBoxedPropertyReference = pAddress.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\t\t\t\t// Attempt to parse the reference as a number, which will be used as an array element\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to treat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynamic object property.\n\t\t\t\t\t// We would expect the property to be wrapped in some kind of quotes so strip them\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Return the value in the property\n\t\t\t\t\tpObject[tmpBoxedPropertyName][tmpBoxedPropertyReference] = pValue;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber] = pValue;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Now is the time in recursion to set the value in the object\n\t\t\t\tpObject[pAddress] = pValue;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpSubObjectName = pAddress.substring(0, tmpSeparatorIndex);\n\t\t\tlet tmpNewAddress = pAddress.substring(tmpSeparatorIndex+1);\n\n\t\t\t// Test if the tmpNewAddress is an array or object\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = tmpSubObjectName.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = tmpSubObjectName.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[42]\n\t\t\t// \t\tMyValues['Color']\n\t\t\t// \t\tMyValues[\"Weight\"]\n\t\t\t// \t\tMyValues[`Diameter`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is data \n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = tmpSubObjectName.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyReference = tmpSubObjectName.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[1].Tardy\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[\"JaneDoe\"].Grade\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an array, so the [\"JaneDoe\"].Grade is not possible to access\n\t\t\t\t// TODO: Should this be an error or something?  Should we keep a log of failures like this?\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//This is a bracketed value\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to reat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynanmic object property.\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Recurse directly into the subobject\n\t\t\t\t\treturn this.setValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference], tmpNewAddress, pValue);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// We parsed a valid number out of the boxed property name, so recurse into the array\n\t\t\t\t\treturn this.setValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber], tmpNewAddress, pValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there is an object property already named for the sub object, but it isn't an object\n\t\t\t// then the system can't set the value in there.  Error and abort!\n\t\t\tif (pObject.hasOwnProperty(tmpSubObjectName) && typeof(pObject[tmpSubObjectName]) !== 'object')\n\t\t\t{\n\t\t\t\tif (!pObject.hasOwnProperty('__ERROR'))\n\t\t\t\t\tpObject['__ERROR'] = {};\n\t\t\t\t// Put it in an error object so data isn't lost\n\t\t\t\tpObject['__ERROR'][pAddress] = pValue;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (pObject.hasOwnProperty(tmpSubObjectName))\n\t\t\t{\n\t\t\t\t// If there is already a subobject pass that to the recursive thingy\n\t\t\t\treturn this.setValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, pValue);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Create a subobject and then pass that\n\t\t\t\tpObject[tmpSubObjectName] = {};\n\t\t\t\treturn this.setValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, pValue);\n\t\t\t}\n\t\t}\n\t}\n};\n\nmodule.exports = ManyfestObjectAddressResolver;","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\nlet libPrecedent = require('precedent');\n\nlet libHashTranslation = require('./Manyfest-HashTranslation.js');\nlet libObjectAddressResolver = require('./Manyfest-ObjectAddressResolver.js');\nlet libObjectAddressGeneration = require('./Manyfest-ObjectAddressGeneration.js');\nlet libSchemaManipulation = require('./Manyfest-SchemaManipulation.js');\n\n\n/**\n* Manyfest object address-based descriptions and manipulations.\n*\n* @class Manyfest\n*/\nclass Manyfest\n{\n\tconstructor(pManifest, pInfoLog, pErrorLog, pOptions)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) === 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) === 'function') ? pErrorLog : libSimpleLog;\n\n\t\t// Create an object address resolver and map in the functions\n\t\tthis.objectAddressResolver = new libObjectAddressResolver(this.logInfo, this.logError);\n\n\t\tthis.options = (\n\t\t\t{\n\t\t\t\tstrict: false,\n\t\t\t\tdefaultValues: \n\t\t\t\t\t{\n\t\t\t\t\t\t\"String\": \"\",\n\t\t\t\t\t\t\"Number\": 0,\n\t\t\t\t\t\t\"Float\": 0.0,\n\t\t\t\t\t\t\"Integer\": 0,\n\t\t\t\t\t\t\"Boolean\": false,\n\t\t\t\t\t\t\"Binary\": 0,\n\t\t\t\t\t\t\"DateTime\": 0,\n\t\t\t\t\t\t\"Array\": [],\n\t\t\t\t\t\t\"Object\": {},\n\t\t\t\t\t\t\"Null\": null\n\t\t\t\t\t}\n\t\t\t});\n\n\t\tthis.scope = undefined;\n\t\tthis.elementAddresses = undefined;\n\t\tthis.elementHashes = undefined;\n\t\tthis.elementDescriptors = undefined;\n\t\t// This can cause a circular dependency chain, so it only gets initialized if the schema specifically calls for it.\n\t\tthis.dataSolvers = undefined;\n\t\t// So solvers can use their own state\n\t\tthis.dataSolverState = undefined;\n\n\t\tthis.reset();\n\n\t\tif (typeof(pManifest) === 'object')\n\t\t{\n\t\t\tthis.loadManifest(pManifest);\n\t\t}\n\n\t\tthis.schemaManipulations = new libSchemaManipulation(this.logInfo, this.logError);\n\t\tthis.objectAddressGeneration = new libObjectAddressGeneration(this.logInfo, this.logError);\n\n\t\tthis.hashTranslations = new libHashTranslation(this.logInfo, this.logError);\n\t}\n\n\t/*************************************************************************\n\t * Schema Manifest Loading, Reading, Manipulation and Serialization Functions\n\t */\n\n\t// Reset critical manifest properties\n\treset()\n\t{\n\t\tthis.scope = 'DEFAULT';\n\t\tthis.elementAddresses = [];\n\t\tthis.elementHashes = {};\n\t\tthis.elementDescriptors = {};\n\t\tthis.dataSolvers = undefined;\n\t\tthis.dataSolverState = {};\n\n\t\tthis.libElucidator = undefined;\n\t\tthis.objectAddressResolver.elucidatorSolver = false;\n\t}\n\n\tclone()\n\t{\n\t\t// Make a copy of the options in-place\n\t\tlet tmpNewOptions = JSON.parse(JSON.stringify(this.options));\n\n\t\tlet tmpNewManyfest = new Manyfest(this.getManifest(), this.logInfo, this.logError, tmpNewOptions);\n\n\t\t// Import the hash translations\n\t\ttmpNewManyfest.hashTranslations.addTranslation(this.hashTranslations.translationTable);\n\n\t\treturn tmpNewManyfest;\n\t}\n\n\t// Deserialize a Manifest from a string\n\tdeserialize(pManifestString)\n\t{\n\t\t// TODO: Add guards for bad manifest string\n\t\treturn this.loadManifest(JSON.parse(pManifestString));\n\t}\n\n\t// Load a manifest from an object\n\tloadManifest(pManifest)\n\t{\n\t\tif (typeof(pManifest) !== 'object')\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading manifest; expecting an object but parameter was type ${typeof(pManifest)}.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (pManifest.hasOwnProperty('Scope'))\n\t\t{\n\t\t\tif (typeof(pManifest.Scope) === 'string')\n\t\t\t{\n\t\t\t\tthis.scope = pManifest.Scope;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.logError(`(${this.scope}) Error loading scope from manifest; expecting a string but property was type ${typeof(pManifest.Scope)}.`, pManifest);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading scope from manifest object.  Property \"Scope\" does not exist in the root of the object.`, pManifest);\n\t\t}\n\n\t\tif (pManifest.hasOwnProperty('Descriptors'))\n\t\t{\n\t\t\tif (typeof(pManifest.Descriptors) === 'object')\n\t\t\t{\n\t\t\t\tlet tmpDescriptionAddresses = Object.keys(pManifest.Descriptors);\n\t\t\t\tfor (let i = 0; i < tmpDescriptionAddresses.length; i++)\n\t\t\t\t{\n\t\t\t\t\tthis.addDescriptor(tmpDescriptionAddresses[i], pManifest.Descriptors[tmpDescriptionAddresses[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.logError(`(${this.scope}) Error loading description object from manifest object.  Expecting an object in 'Manifest.Descriptors' but the property was type ${typeof(pManifest.Descriptors)}.`, pManifest);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading object description from manifest object.  Property \"Descriptors\" does not exist in the root of the Manifest object.`, pManifest);\n\t\t}\n\n\t\t// This seems like it would create a circular dependency issue but it only goes as deep as the schema defines Solvers\n\t\tif ((pManifest.hasOwnProperty('Solvers')) && (typeof(pManifest.Solvers) == 'object'))\n\t\t{\n\t\t\t// There are elucidator solvers passed-in, so we will create one to filter data.\n\t\t\tlet libElucidator = require('elucidator');\n\t\t\t// WARNING THESE CAN MUTATE THE DATA\n\t\t\t\t// The pattern for the solver is: {<~~SolverName~~>} anywhere in a property.\n\t\t\t\t//   Yes, this means your Javascript elements can't have my self-styled jellyfish brackets in them.\n\t\t\t\t//   This does, though, mean we can filter at multiple layers safely.\n\t\t\t\t//   Because these can be put at any address\n\t\t\t// The solver themselves:\n\t\t\t\t//   They are passed-in an object, and the current record is in the Record subobject.\n\t\t\t\t//   Basic operations can just write to the root object but...\n\t\t\t\t//   IF YOU PERMUTE THE Record SUBOBJECT YOU CAN AFFECT RECURSION\n\t\t\t// This is mostly meant for if statements to filter.\n\t\t\t\t//   Basically on aggregation, if a filter is set it will set \"keep record\" to true and let the solver decide differently.\n\t\t\tthis.dataSolvers = new libElucidator(pManifest.Solvers, this.logInfo, this.logError);\n\t\t\tthis.objectAddressResolver.elucidatorSolver = this.dataSolvers;\n\n\t\t\t// Load the solver state in so each instruction can have internal config\n\t\t\t// TODO: Should this just be a part of the lower layer pattern?\n\t\t\tlet tmpSolverKeys = Object.keys(pManifest.Solvers)\n\t\t\tfor (let i = 0; i < tmpSolverKeys.length; i++)\n\t\t\t{\n\t\t\t\tthis.dataSolverState[tmpSolverKeys] = pManifest.Solvers[tmpSolverKeys[i]];\n\t\t\t}\n\t\t\tthis.objectAddressResolver.elucidatorSolverState = this.dataSolverState;\n\t\t}\n\t}\n\n\t// Serialize the Manifest to a string\n\t// TODO: Should this also serialize the translation table?\n\tserialize()\n\t{\n\t\treturn JSON.stringify(this.getManifest());\n\t}\n\n\tgetManifest()\n\t{\n\t\treturn (\n\t\t\t{\n\t\t\t\tScope: this.scope,\n\t\t\t\tDescriptors: JSON.parse(JSON.stringify(this.elementDescriptors))\n\t\t\t});\n\t}\n\n\t// Add a descriptor to the manifest\n\taddDescriptor(pAddress, pDescriptor)\n\t{\n\t\tif (typeof(pDescriptor) === 'object')\n\t\t{\n\t\t\t// Add the Address into the Descriptor if it doesn't exist:\n\t\t\tif (!pDescriptor.hasOwnProperty('Address'))\n\t\t\t{\n\t\t\t\tpDescriptor.Address = pAddress;\n\t\t\t}\n\n\t\t\tif (!this.elementDescriptors.hasOwnProperty(pAddress))\n\t\t\t{\n\t\t\t\tthis.elementAddresses.push(pAddress);\n\t\t\t}\n\n\t\t\t// Add the element descriptor to the schema\n\t\t\tthis.elementDescriptors[pAddress] = pDescriptor;\n\n\t\t\t// Always add the address as a hash\n\t\t\tthis.elementHashes[pAddress] = pAddress;\n\n\t\t\tif (pDescriptor.hasOwnProperty('Hash'))\n\t\t\t{\n\t\t\t\t// TODO: Check if this is a good idea or not..\n\t\t\t\t//       Collisions are bound to happen with both representations of the address/hash in here and developers being able to create their own hashes.\n\t\t\t\tthis.elementHashes[pDescriptor.Hash] = pAddress;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpDescriptor.Hash = pAddress;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading object descriptor for address '${pAddress}' from manifest object.  Expecting an object but property was type ${typeof(pDescriptor)}.`);\n\t\t\treturn false;\n\t\t}\t\n\t}\n\n\tgetDescriptorByHash(pHash)\n\t{\n\t\treturn this.getDescriptor(this.resolveHashAddress(pHash));\n\t}\n\n\tgetDescriptor(pAddress)\n\t{\n\t\treturn this.elementDescriptors[pAddress];\n\t}\n\n\t// execute an action function for each descriptor\n\teachDescriptor(fAction)\n\t{\n        let tmpDescriptorAddresses = Object.keys(this.elementDescriptors);\n        for (let i = 0; i < tmpDescriptorAddresses.length; i++)\n        {\n            fAction(this.elementDescriptors[tmpDescriptorAddresses[i]]);\n        }\n\n\t}\n\n\t/*************************************************************************\n\t * Beginning of Object Manipulation (read & write) Functions\n\t */\n\t// Check if an element exists by its hash\n\tcheckAddressExistsByHash (pObject, pHash)\n\t{\n\t\treturn this.checkAddressExists(pObject,this.resolveHashAddress(pHash));\n\t}\n\n\t// Check if an element exists at an address\n\tcheckAddressExists (pObject, pAddress)\n\t{\n\t\treturn this.objectAddressResolver.checkAddressExists(pObject, pAddress);\n\t}\n\n\t// Turn a hash into an address, factoring in the translation table.\n\tresolveHashAddress(pHash)\n\t{\n\t\tlet tmpAddress = undefined;\n\n\t\tlet tmpInElementHashTable = this.elementHashes.hasOwnProperty(pHash);\n\t\tlet tmpInTranslationTable = this.hashTranslations.translationTable.hasOwnProperty(pHash);\n\n\t\t// The most straightforward: the hash exists, no translations.\n\t\tif (tmpInElementHashTable && !tmpInTranslationTable)\n\t\t{\n\t\t\ttmpAddress = this.elementHashes[pHash];\n\t\t}\n\t\t// There is a translation from one hash to another, and, the elementHashes contains the pointer end\n\t\telse if (tmpInTranslationTable && this.elementHashes.hasOwnProperty(this.hashTranslations.translate(pHash)))\n\t\t{\n\t\t\ttmpAddress = this.elementHashes[this.hashTranslations.translate(pHash)];\n\t\t}\n\t\t// Use the level of indirection only in the Translation Table \n\t\telse if (tmpInTranslationTable)\n\t\t{\n\t\t\ttmpAddress = this.hashTranslations.translate(pHash);\n\t\t}\n\t\t// Just treat the hash as an address.\n\t\t// TODO: Discuss this ... it is magic but controversial\n\t\telse\n\t\t{\n\t\t\ttmpAddress = pHash;\n\t\t}\n\n\t\treturn tmpAddress;\n\t}\n\n\t// Get the value of an element by its hash\n\tgetValueByHash (pObject, pHash)\n\t{\n\t\tlet tmpValue = this.getValueAtAddress(pObject, this.resolveHashAddress(pHash));\n\n\t\tif (typeof(tmpValue) == 'undefined')\n\t\t{\n\t\t\t// Try to get a default if it exists\n\t\t\ttmpValue = this.getDefaultValue(this.getDescriptorByHash(pHash));\n\t\t}\n\n\t\treturn tmpValue;\n\t}\n\n\t// Get the value of an element at an address\n\tgetValueAtAddress (pObject, pAddress)\n\t{\n\t\tlet tmpValue = this.objectAddressResolver.getValueAtAddress(pObject, pAddress);\n\n\t\tif (typeof(tmpValue) == 'undefined')\n\t\t{\n\t\t\t// Try to get a default if it exists\n\t\t\ttmpValue = this.getDefaultValue(this.getDescriptor(pAddress));\n\t\t}\n\n\t\treturn tmpValue;\n\t}\n\n\t// Set the value of an element by its hash\n\tsetValueByHash(pObject, pHash, pValue)\n\t{\n\t\treturn this.setValueAtAddress(pObject, this.resolveHashAddress(pHash), pValue);\n\t}\n\n\n\t// Set the value of an element at an address\n\tsetValueAtAddress (pObject, pAddress, pValue)\n\t{\n\t\treturn this.objectAddressResolver.setValueAtAddress(pObject, pAddress, pValue);\n\t}\n\n\t// Validate the consistency of an object against the schema\n\tvalidate(pObject)\n\t{\n\t\tlet tmpValidationData =\n\t\t{\n\t\t\tError: null,\n\t\t\tErrors: [],\n\t\t\tMissingElements:[]\n\t\t};\n\n\t\tif (typeof(pObject) !== 'object')\n\t\t{\n\t\t\ttmpValidationData.Error = true;\n\t\t\ttmpValidationData.Errors.push(`Expected passed in object to be type object but was passed in ${typeof(pObject)}`);\n\t\t}\n\n\t\tlet addValidationError = (pAddress, pErrorMessage) =>\n\t\t{\n\t\t\ttmpValidationData.Error = true;\n\t\t\ttmpValidationData.Errors.push(`Element at address \"${pAddress}\" ${pErrorMessage}.`);\n\t\t};\n\n\t\t// Now enumerate through the values and check for anomalies based on the schema\n\t\tfor (let i = 0; i < this.elementAddresses.length; i++)\n\t\t{\n\t\t\tlet tmpDescriptor = this.getDescriptor(this.elementAddresses[i]);\n\t\t\tlet tmpValueExists = this.checkAddressExists(pObject, tmpDescriptor.Address);\n\t\t\tlet tmpValue = this.getValueAtAddress(pObject, tmpDescriptor.Address);\n\n\t\t\tif ((typeof(tmpValue) == 'undefined') || !tmpValueExists)\n\t\t\t{\n\t\t\t\t// This will technically mean that `Object.Some.Value = undefined` will end up showing as \"missing\"\n\t\t\t\t// TODO: Do we want to do a different message based on if the property exists but is undefined?\n\t\t\t\ttmpValidationData.MissingElements.push(tmpDescriptor.Address);\n\t\t\t\tif (tmpDescriptor.Required || this.options.strict)\n\t\t\t\t{\n\t\t\t\t\taddValidationError(tmpDescriptor.Address, 'is flagged REQUIRED but is not set in the object');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Now see if there is a data type specified for this element\n\t\t\tif (tmpDescriptor.DataType)\n\t\t\t{\n\t\t\t\tlet tmpElementType = typeof(tmpValue);\n\t\t\t\tswitch(tmpDescriptor.DataType.toString().trim().toLowerCase())\n\t\t\t\t{\n\t\t\t\t\tcase 'string':\n\t\t\t\t\t\tif (tmpElementType != 'string')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'number':\n\t\t\t\t\t\tif (tmpElementType != 'number')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'integer':\n\t\t\t\t\t\tif (tmpElementType != 'number')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlet tmpValueString = tmpValue.toString();\n\t\t\t\t\t\t\tif (tmpValueString.indexOf('.') > -1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// TODO: Is this an error?\n\t\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but has a decimal point in the number.`);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'float':\n\t\t\t\t\t\tif (tmpElementType != 'number')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'DateTime':\n\t\t\t\t\t\tlet tmpValueDate = new Date(tmpValue);\n\t\t\t\t\t\tif (tmpValueDate.toString() == 'Invalid Date')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is not parsable as a Date by Javascript`);\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// Check if this is a string, in the default case\n\t\t\t\t\t\t// Note this is only when a DataType is specified and it is an unrecognized data type.\n\t\t\t\t\t\tif (tmpElementType != 'string')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} (which auto-converted to String because it was unrecognized) but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn tmpValidationData;\n\t}\n\n\t// Returns a default value, or, the default value for the data type (which is overridable with configuration)\n\tgetDefaultValue(pDescriptor)\n\t{\n\t\tif (typeof(pDescriptor) != 'object')\n\t\t{\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (pDescriptor.hasOwnProperty('Default'))\n\t\t{\n\t\t\treturn pDescriptor.Default;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Default to a null if it doesn't have a type specified.\n\t\t\t// This will ensure a placeholder is created but isn't misinterpreted.\n\t\t\tlet tmpDataType = (pDescriptor.hasOwnProperty('DataType')) ? pDescriptor.DataType : 'String';\n\t\t\tif (this.options.defaultValues.hasOwnProperty(tmpDataType))\n\t\t\t{\n\t\t\t\treturn this.options.defaultValues[tmpDataType];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// give up and return null\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Enumerate through the schema and populate default values if they don't exist.\n\tpopulateDefaults(pObject, pOverwriteProperties)\n\t{\n\t\treturn this.populateObject(pObject, pOverwriteProperties,\n\t\t\t// This just sets up a simple filter to see if there is a default set.\n\t\t\t(pDescriptor) =>\n\t\t\t{\n\t\t\t\treturn pDescriptor.hasOwnProperty('Default');\n\t\t\t});\n\t}\n\n\t// Forcefully populate all values even if they don't have defaults.\n\t// Based on type, this can do unexpected things.\n\tpopulateObject(pObject, pOverwriteProperties, fFilter)\n\t{\n\t\t// Automatically create an object if one isn't passed in.\n\t\tlet tmpObject = (typeof(pObject) === 'object') ? pObject : {};\n\t\t// Default to *NOT OVERWRITING* properties\n\t\tlet tmpOverwriteProperties = (typeof(pOverwriteProperties) == 'undefined') ? false : pOverwriteProperties;\n\t\t// This is a filter function, which is passed the schema and allows complex filtering of population\n\t\t// The default filter function just returns true, populating everything.\n\t\tlet tmpFilterFunction = (typeof(fFilter) == 'function') ? fFilter : (pDescriptor) => { return true; };\n\n\t\tthis.elementAddresses.forEach(\n\t\t\t(pAddress) =>\n\t\t\t{\n\t\t\t\tlet tmpDescriptor = this.getDescriptor(pAddress);\n\t\t\t\t// Check the filter function to see if this is an address we want to set the value for.\n\t\t\t\tif (tmpFilterFunction(tmpDescriptor))\n\t\t\t\t{\n\t\t\t\t\t// If we are overwriting properties OR the property does not exist\n\t\t\t\t\tif (tmpOverwriteProperties || !this.checkAddressExists(tmpObject, pAddress))\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.setValueAtAddress(tmpObject, pAddress, this.getDefaultValue(tmpDescriptor));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn tmpObject;\n\t}\n};\n\nmodule.exports = Manyfest;"]}