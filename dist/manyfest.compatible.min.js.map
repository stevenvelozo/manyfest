{"version":3,"sources":["manyfest.compatible.min.js","node_modules/browser-pack/_prelude.js","node_modules/fable-serviceproviderbase/source/Fable-ServiceProviderBase.js","source/Manyfest-CleanWrapCharacters.js","source/Manyfest-HashTranslation.js","source/Manyfest-LogToConsole.js","source/Manyfest-ObjectAddress-CheckAddressExists.js","source/Manyfest-ObjectAddress-DeleteValue.js","source/Manyfest-ObjectAddress-GetValue.js","source/Manyfest-ObjectAddress-Parser.js","source/Manyfest-ObjectAddress-SetValue.js","source/Manyfest-ObjectAddressGeneration.js","source/Manyfest-ParseConditionals.js","source/Manyfest-SchemaManipulation.js","source/Manyfest.js"],"names":["_callSuper","t","o","e","_getPrototypeOf","_possibleConstructorReturn","_isNativeReflectConstruct","Reflect","construct","constructor","apply","self","call","_typeof","TypeError","_assertThisInitialized","ReferenceError","Boolean","prototype","valueOf","Object","setPrototypeOf","getPrototypeOf","bind","__proto__","_inherits","subClass","superClass","create","value","writable","configurable","defineProperty","_setPrototypeOf","p","_classCallCheck","instance","Constructor","_defineProperties","target","props","i","length","descriptor","enumerable","_toPropertyKey","key","_createClass","protoProps","staticProps","_defineProperty","obj","_toPrimitive","r","Symbol","toPrimitive","String","Number","iterator","f","exports","module","define","amd","window","global","this","Manyfest","n","c","require","u","a","Error","code","FableServiceProviderBase","pFable","pOptions","pServiceHash","isFable","connectFable","fable","UUID","getUUID","options","concat","Math","floor","random","serviceType","Hash","tmpErrorMessage","console","log","Logging","services","servicesMap","CoreServiceProviderBase","pCharacter","pString","startsWith","endsWith","substring","libSimpleLog","ManyfestHashTranslation","pInfoLog","pErrorLog","logInfo","logError","translationTable","keys","pTranslation","_this","forEach","pTranslationSource","pTranslationHash","_this2","removeTranslationHash","removeTranslation","pLogLine","pLogObject","tmpLogLine","JSON","stringify","libGetObjectValue","_MockFable","DataFormat","ManyfestObjectAddressResolverCheckAddressExists","getObjectValueClass","pObject","pAddress","pRootObject","tmpRootObject","tmpAddressPartBeginning","stringGetFirstSegment","tmpBracketStartIndex","indexOf","tmpBracketStopIndex","tmpFunctionStartIndex","stringCountEnclosures","tmpFunctionAddress","trim","tmpBoxedPropertyName","tmpBoxedPropertyReference","tmpBoxedPropertyNumber","parseInt","Array","isArray","isNaN","cleanWrapCharacters","tmpSubObjectName","tmpNewAddress","tmpFunctionArguments","stringGetSegments","stringGetEnclosureValueByIndex","checkAddressExists","pError","message","tmpArgumentValues","push","getValueAtAddress","fCleanWrapCharacters","fParseConditionals","ManyfestObjectAddressResolverDeleteValue","pRecord","pParentAddress","tmpParentAddress","tmpSeparatorIndex","tmpObjectTypeMarkerIndex","tmpInputArray","checkRecordFilters","splice","tmpObjectPropertyName","deleteValueAtAddress","tmpArrayProperty","tmpContainerObject","tmpPropertyParentAddress","tmpValue","tmpObjectProperty","tmpObjectPropertyKeys","ManyfestObjectAddressResolverGetValue","tmpParentAddressParts","tmpBackNavigationCount","charAt","tmpParentAddressLength","tmpRecurseAddress","slice","join","tmpOutputArray","stringCountSegments","pSeparator","pEnclosureStartSymbolMap","pEnclosureEndSymbolMap","tmpString","tmpSeparator","tmpEnclosureStartSymbolMap","pEnclosureStart","tmpEnclosureEndSymbolMap","pEnclosureEnd","tmpSegmentCount","tmpEnclosureStack","pop","tmpCurrentSegmentStart","tmpSegmentList","tmpEnclosureStart","tmpEnclosureEnd","tmpEnclosureCount","tmpEnclosureDepth","pEnclosureIndexToGet","tmpEnclosureIndexToGet","tmpMatchedEnclosureIndex","tmpEnclosedValueStartIndex","tmpEnclosedValueEndIndex","ManyfestObjectAddressSetValue","pValue","setValueAtAddress","ManyfestObjectAddressGeneration","pBaseAddress","pSchema","tmpBaseAddress","tmpSchema","tmpObjectType","tmpSchemaObjectEntry","Address","Name","InSchema","DataType","Default","generateAddressses","tmpObjectProperties","_ConditionalStanzaStart","_ConditionalStanzaEnd","testCondition","pManyfest","pSearchAddress","pSearchComparator","tmpKeepRecord","tmpStartIndex","tmpStopIndex","tmpMagicComparisonPatternSet","split","tmpSearchAddress","tmpSearchComparator","tmpSearchValue","ManyfestSchemaManipulation","pManyfestSchemaDescriptors","pAddressMapping","tmpManyfestAddresses","tmpHashMapping","pInputAddress","tmpNewDescriptorAddress","tmpOldDescriptorAddress","tmpDescriptor","tmpManyfestSchemaDescriptors","parse","resolveAddressMappings","pManyfestSchemaDescriptorsDestination","pManyfestSchemaDescriptorsSource","tmpSource","tmpNewManyfestSchemaDescriptors","pDescriptorAddress","libFableServiceProviderBase","libHashTranslation","libObjectAddressCheckAddressExists","libObjectAddressGetValue","libObjectAddressSetValue","libObjectAddressDeleteValue","libObjectAddressGeneration","libSchemaManipulation","_DefaultConfiguration","Scope","Descriptors","_libFableServiceProvi","pManifest","_this3","undefined","objectAddressCheckAddressExists","objectAddressGetValue","objectAddressSetValue","objectAddressDeleteValue","defaultValues","Float","Integer","PreciseNumber","Binary","DateTime","Null","strict","scope","elementAddresses","elementHashes","elementDescriptors","reset","loadManifest","schemaManipulations","objectAddressGeneration","hashTranslations","numberRegex","tmpNewOptions","tmpNewManyfest","getManifest","addTranslation","pManifestString","tmpManifest","tmpDescriptorKeys","tmpDescriptionAddresses","addDescriptor","HashTranslations","pDescriptor","pHash","getDescriptor","resolveHashAddress","fAction","tmpDescriptorAddresses","tmpInElementHashTable","tmpInTranslationTable","translate","getDefaultValue","getDescriptorByHash","tmpValidationData","Errors","MissingElements","addValidationError","pErrorMessage","tmpValueExists","Required","tmpElementType","toString","toLowerCase","test","Date","tmpDataType","pOverwriteProperties","populateObject","fFilter","_this4","tmpObject","tmpOverwriteProperties","tmpFilterFunction"],"mappings":"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","file":"manyfest.compatible.min.js","sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.Manyfest = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n/**\n* Fable Service Base\n* @author <steven@velozo.com>\n*/\n\nclass FableServiceProviderBase\n{\n\t// The constructor can be used in two ways:\n\t// 1) With a fable, options object and service hash (the options object and service hash are optional)\n\t// 2) With an object or nothing as the first parameter, where it will be treated as the options object\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\t// Check if a fable was passed in; connect it if so\n\t\tif ((typeof(pFable) === 'object') && pFable.isFable)\n\t\t{\n\t\t\tthis.connectFable(pFable);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.fable = false;\n\t\t}\n\n\t\t// initialize options and UUID based on whether the fable was passed in or not.\n\t\tif (this.fable)\n\t\t{\n\t\t\tthis.UUID = pFable.getUUID();\n\t\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t\t: {};\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// With no fable, check to see if there was an object passed into either of the first two\n\t\t\t// Parameters, and if so, treat it as the options object\n\t\t\tthis.options = ((typeof(pFable) === 'object') && !pFable.isFable) ? pFable\n\t\t\t\t\t\t\t: (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t\t: {};\n\t\t\tthis.UUID = `CORE-SVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`\n\t\t}\n\n\t\t// It's expected that the deriving class will set this\n\t\tthis.serviceType = `Unknown-${this.UUID}`;\n\n\t\t// The service hash is used to identify the specific instantiation of the service in the services map\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash \n\t\t\t\t\t: (!this.fable && (typeof(pOptions) === 'string')) ? pOptions\n\t\t\t\t\t: `${this.UUID}`;\n\t}\n\n\tconnectFable(pFable)\n\t{\n\t\tif ((typeof(pFable) !== 'object') || (!pFable.isFable))\n\t\t{\n\t\t\tlet tmpErrorMessage = `Fable Service Provider Base: Cannot connect to Fable, invalid Fable object passed in.  The pFable parameter was a [${typeof(pFable)}].}`;\n\t\t\tconsole.log(tmpErrorMessage);\n\t\t\treturn new Error(tmpErrorMessage);\n\t\t}\n\n\t\tif (!this.fable)\n\t\t{\n\t\t\tthis.fable = pFable;\n\t\t}\n\n\t\tif (!this.log)\n\t\t{\n\t\t\tthis.log = this.fable.Logging;\n\t\t}\n\t\tif (!this.services)\n\t\t{\n\t\t\tthis.services = this.fable.services;\n\t\t}\n\n\t\tif (!this.servicesMap)\n\t\t{\n\t\t\tthis.servicesMap = this.fable.servicesMap;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tstatic isFableService = true;\n}\n\nmodule.exports = FableServiceProviderBase;\n\n// This is left here in case we want to go back to having different code/base class for \"core\" services\nmodule.exports.CoreServiceProviderBase = FableServiceProviderBase;\n},{}],2:[function(require,module,exports){\n// When a boxed property is passed in, it should have quotes of some\n// kind around it.\n//\n// For instance:\n// \t\tMyValues['Name']\n// \t\tMyValues[\"Age\"]\n// \t\tMyValues[`Cost`]\n//\n// This function removes the wrapping quotes.\n//\n// Please note it *DOES NOT PARSE* template literals, so backticks just\n// end up doing the same thing as other quote types.\n//\n// TODO: Should template literals be processed?  If so what state do they have access to?  That should happen here if so.\n// TODO: Make a simple class include library with these\nconst cleanWrapCharacters = (pCharacter, pString) =>\n{\n\tif (pString.startsWith(pCharacter) && pString.endsWith(pCharacter))\n\t{\n\t\treturn pString.substring(1, pString.length - 1);\n\t}\n\telse\n\t{\n\t\treturn pString;\n\t}\n};\n\nmodule.exports = cleanWrapCharacters;\n},{}],3:[function(require,module,exports){\n/**\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\n/**\n* Hash Translation\n*\n* This is a very simple translation table for hashes, which allows the same schema to resolve\n* differently based on a loaded translation table.\n*\n* This is to prevent the requirement for mutating schemas over and over again when we want to\n* reuse the structure but look up data elements by different addresses.\n*\n* One side-effect of this is that a translation table can \"override\" the built-in hashes, since\n* this is always used to resolve hashes before any of the functionCallByHash(pHash, ...) perform\n* their lookups by hash.\n*\n* @class ManyfestHashTranslation\n*/\nclass ManyfestHashTranslation\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) === 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) === 'function') ? pErrorLog : libSimpleLog;\n\n        this.translationTable = {};\n\t}\n\n    translationCount()\n    {\n        return Object.keys(this.translationTable).length;\n    }\n\n    addTranslation(pTranslation)\n    {\n        // This adds a translation in the form of:\n        // { \"SourceHash\": \"DestinationHash\", \"SecondSourceHash\":\"SecondDestinationHash\" }\n        if (typeof(pTranslation) != 'object')\n        {\n            this.logError(`Hash translation addTranslation expected a translation be type object but was passed in ${typeof(pTranslation)}`);\n            return false;\n        }\n\n        let tmpTranslationSources = Object.keys(pTranslation)\n\n        tmpTranslationSources.forEach(\n            (pTranslationSource) =>\n            {\n                if (typeof(pTranslation[pTranslationSource]) != 'string')\n                {\n                    this.logError(`Hash translation addTranslation expected a translation destination hash for [${pTranslationSource}] to be a string but the referrant was a ${typeof(pTranslation[pTranslationSource])}`);\n                }\n                else\n                {\n                    this.translationTable[pTranslationSource] = pTranslation[pTranslationSource];\n                }\n            });\n    }\n\n    removeTranslationHash(pTranslationHash)\n    {\n        if (pTranslationHash in this.translationTable)\n        {\n            delete this.translationTable[pTranslationHash];\n        }\n    }\n\n    // This removes translations.\n    // If passed a string, just removes the single one.\n    // If passed an object, it does all the source keys.\n    removeTranslation(pTranslation)\n    {\n        if (typeof(pTranslation) == 'string')\n        {\n            this.removeTranslationHash(pTranslation);\n            return true;\n        }\n        else if (typeof(pTranslation) == 'object')\n        {\n            let tmpTranslationSources = Object.keys(pTranslation)\n\n            tmpTranslationSources.forEach(\n                (pTranslationSource) =>\n                {\n                    this.removeTranslation(pTranslationSource);\n                });\n            return true;\n        }\n        else\n        {\n            this.logError(`Hash translation removeTranslation expected either a string or an object but the passed-in translation was type ${typeof(pTranslation)}`);\n            return false;\n        }\n    }\n\n    clearTranslations()\n    {\n        this.translationTable = {};\n    }\n\n    translate(pTranslation)\n    {\n        if (pTranslation in this.translationTable)\n        {\n            return this.translationTable[pTranslation];\n        }\n        else\n        {\n            return pTranslation;\n        }\n    }\n}\n\nmodule.exports = ManyfestHashTranslation;\n},{\"./Manyfest-LogToConsole.js\":4}],4:[function(require,module,exports){\n/**\n* @author <steven@velozo.com>\n*/\n\n/**\n* Manyfest simple logging shim (for browser and dependency-free running)\n*/\n\nconst logToConsole = (pLogLine, pLogObject) =>\n{\n    let tmpLogLine = (typeof(pLogLine) === 'string') ? pLogLine : '';\n\n    console.log(`[Manyfest] ${tmpLogLine}`);\n\n    if (pLogObject) console.log(JSON.stringify(pLogObject));\n};\n\nmodule.exports = logToConsole;\n},{}],5:[function(require,module,exports){\n/**\n* @author <steven@velozo.com>\n*/\nconst libSimpleLog = require('./Manyfest-LogToConsole.js');\n// This is for resolving functions mid-address\nconst libGetObjectValue = require('./Manyfest-ObjectAddress-GetValue.js');\n\n// TODO: Just until this is a fable service.\nlet _MockFable = { DataFormat: require('./Manyfest-ObjectAddress-Parser.js') };\n\n/**\n* Object Address Resolver\n*\n* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to\n*                 be extremely clear what is going on in the recursion for\n*                 each of the three address resolution functions.\n*\n*                 Although there is some opportunity to repeat ourselves a\n*                 bit less in this codebase (e.g. with detection of arrays\n*                 versus objects versus direct properties), it can make\n*                 debugging.. challenging.  The minified version of the code\n*                 optimizes out almost anything repeated in here.  So please\n*                 be kind and rewind... meaning please keep the codebase less\n*                 terse and more verbose so humans can comprehend it.\n*\n*\n* @class ManyfestObjectAddressResolverCheckAddressExists\n*/\nclass ManyfestObjectAddressResolverCheckAddressExists\n{\n\tconstructor()\n\t{\n\t\tthis.getObjectValueClass = new libGetObjectValue(libSimpleLog, libSimpleLog);\n\t}\n\n\t// Check if an address exists.\n\t//\n\t// This is necessary because the getValueAtAddress function is ambiguous on\n\t// whether the element/property is actually there or not (it returns\n\t// undefined whether the property exists or not).  This function checks for\n\t// existance and returns true or false dependent.\n\tcheckAddressExists (pObject, pAddress, pRootObject)\n\t{\n\t\t// TODO: Should these throw an error?\n\t\t// Make sure pObject is an object\n\t\tif (typeof(pObject) != 'object') return false;\n\t\t// Make sure pAddress is a string\n\t\tif (typeof(pAddress) != 'string') return false;\n\n\t\t// Set the root object to the passed-in object if it isn't set yet.  This is expected to be the root object.\n\t\t// NOTE: This was added to support functions mid-stream\n\t\tlet tmpRootObject = (typeof(pRootObject) == 'undefined') ? pObject : pRootObject;\n\n\t\t// DONE: Make this work for things like SomeRootObject.Metadata[\"Some.People.Use.Bad.Object.Property.Names\"]\n\t\tlet tmpAddressPartBeginning = _MockFable.DataFormat.stringGetFirstSegment(pAddress);\n\n\t\t// This is the terminal address string (no more dots so the RECUSION ENDS IN HERE somehow)\n\t\tif (tmpAddressPartBeginning.length == pAddress.length)\n\t\t{\n\t\t\t// Check if the address refers to a boxed property\n\t\t\tlet tmpBracketStartIndex = pAddress.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = pAddress.indexOf(']');\n\n\t\t\t// Check if there is a function somewhere in the address... parenthesis start should only be in a function\n\t\t\tlet tmpFunctionStartIndex = pAddress.indexOf('(');\n\n\t\t\t// NOTE THAT FUNCTIONS MUST RESOLVE FIRST\n\t\t\t// Functions look like this\n\t\t\t// \t\tMyFunction()\n\t\t\t// \t\tMyFunction(Some.Address)\n\t\t\t// \t\tMyFunction(Some.Address,Some.Other.Address)\n\t\t\t// \t\tMyFunction(Some.Address,Some.Other.Address,Some.Third.Address)\n\t\t\t//\n\t\t\t// This could be enhanced to allow purely numeric and string values to be passed to the function.  For now,\n\t\t\t// To heck with that.  This is a simple function call.\n\t\t\t//\n\t\t\t// The requirements to detect a function are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpFunctionStartIndex > 0)\n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (_MockFable.DataFormat.stringCountEnclosures(pAddress) > 0))\n\t\t\t{\n\t\t\t\tlet tmpFunctionAddress = pAddress.substring(0, tmpFunctionStartIndex).trim();\n\n\t\t\t\tif (((tmpFunctionAddress in pObject)) && (typeof(pObject[tmpFunctionAddress]) == 'function'))\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// The address suggests it is a function, but it is not.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[10]\n\t\t\t// \t\tMyValues['Name']\n\t\t\t// \t\tMyValues[\"Age\"]\n\t\t\t// \t\tMyValues[`Cost`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\t// The \"Name\" of the Object contained too the left of the bracket\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\t// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.\n\t\t\t\t// This is a rare case where Arrays testing as Objects is useful\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// The \"Reference\" to the property within it, either an array element or object property\n\t\t\t\tlet tmpBoxedPropertyReference = pAddress.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\t\t\t\t// Attempt to parse the reference as a number, which will be used as an array element\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to treat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynamic object property.\n\t\t\t\t\t// We would expect the property to be wrapped in some kind of quotes so strip them\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Check if the property exists.\n\t\t\t\t\treturn (tmpBoxedPropertyReference in pObject[tmpBoxedPropertyName]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Use the new in operator to see if the element is in the array\n\t\t\t\t\treturn (tmpBoxedPropertyNumber in pObject[tmpBoxedPropertyName]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Check if the property exists\n\t\t\t\treturn (pAddress in pObject);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpSubObjectName = tmpAddressPartBeginning;\n\t\t\tlet tmpNewAddress = pAddress.substring(tmpAddressPartBeginning.length+1);\n\n\t\t\t// Test if the tmpNewAddress is an array or object\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = tmpSubObjectName.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = tmpSubObjectName.indexOf(']');\n\n\t\t\t// Check if there is a function somewhere in the address... parenthesis start should only be in a function\n\t\t\tlet tmpFunctionStartIndex = tmpSubObjectName.indexOf('(');\n\n\t\t\t// NOTE THAT FUNCTIONS MUST RESOLVE FIRST\n\t\t\t// Functions look like this\n\t\t\t// \t\tMyFunction()\n\t\t\t// \t\tMyFunction(Some.Address)\n\t\t\t// \t\tMyFunction(Some.Address,Some.Other.Address)\n\t\t\t// \t\tMyFunction(Some.Address,Some.Other.Address,Some.Third.Address)\n\t\t\t//\n\t\t\t// This could be enhanced to allow purely numeric and string values to be passed to the function.  For now,\n\t\t\t// To heck with that.  This is a simple function call.\n\t\t\t//\n\t\t\t// The requirements to detect a function are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpFunctionStartIndex > 0)\n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (_MockFable.DataFormat.stringCountEnclosures(tmpSubObjectName) > 0))\n\t\t\t{\n\t\t\t\tlet tmpFunctionAddress = tmpSubObjectName.substring(0, tmpFunctionStartIndex).trim();\n\t\t\t\t//tmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\n\t\t\t\tif (!typeof(pObject[tmpFunctionAddress]) == 'function')\n\t\t\t\t{\n\t\t\t\t\t// The address suggests it is a function, but it is not.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Now see if the function has arguments.\n\t\t\t\t// Implementation notes: * ARGUMENTS MUST SHARE THE SAME ROOT OBJECT CONTEXT *\n\t\t\t\tlet tmpFunctionArguments = _MockFable.DataFormat.stringGetSegments(_MockFable.DataFormat.stringGetEnclosureValueByIndex(tmpSubObjectName.substring(tmpFunctionAddress.length), 0), ',');\n\t\t\t\tif ((tmpFunctionArguments.length == 0) || (tmpFunctionArguments[0] == ''))\n\t\t\t\t{\n\t\t\t\t\t// No arguments... just call the function (bound to the scope of the object it is contained withing)\n\t\t\t\t\tif (tmpFunctionAddress in pObject)\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn this.checkAddressExists(pObject[tmpFunctionAddress].apply(pObject), tmpNewAddress, tmpRootObject);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(pError)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// The function call failed, so the address doesn't exist\n\t\t\t\t\t\t\tlibSimpleLog.log(`Error calling function ${tmpFunctionAddress} (address [${pAddress}]): ${pError.message}`);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// The function doesn't exist, so the address doesn't exist\n\t\t\t\t\t\tlibSimpleLog.log(`Function ${tmpFunctionAddress} does not exist (address [${pAddress}])`);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlet tmpArgumentValues = [];\n\n\t\t\t\t\tlet tmpRootObject = (typeof(pRootObject) == 'undefined') ? pObject : pRootObject;\n\n\t\t\t\t\t// Now get the value for each argument\n\t\t\t\t\tfor (let i = 0; i < tmpFunctionArguments.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Resolve the values for each subsequent entry\n\t\t\t\t\t\t// NOTE: This is where the resolves get really tricky.  Recursion within recursion.  Programming gom jabbar, yo.\n\t\t\t\t\t\ttmpArgumentValues.push(this.getObjectValueClass.getValueAtAddress(tmpRootObject, tmpFunctionArguments[i]));\n\t\t\t\t\t}\n\n\t\t\t\t\t//return this.checkAddressExists(pObject[tmpFunctionAddress].apply(pObject, tmpArgumentValues), tmpNewAddress, tmpRootObject);\n\t\t\t\t\tif (tmpFunctionAddress in pObject)\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn this.checkAddressExists(pObject[tmpFunctionAddress].apply(pObject, tmpArgumentValues), tmpNewAddress, tmpRootObject);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(pError)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// The function call failed, so the address doesn't exist\n\t\t\t\t\t\t\tlibSimpleLog.log(`Error calling function ${tmpFunctionAddress} (address [${pAddress}]): ${pError.message}`);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// The function doesn't exist, so the address doesn't exist\n\t\t\t\t\t\tlibSimpleLog.log(`Function ${tmpFunctionAddress} does not exist (address [${pAddress}])`);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[42]\n\t\t\t// \t\tMyValues['Color']\n\t\t\t// \t\tMyValues[\"Weight\"]\n\t\t\t// \t\tMyValues[`Diameter`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = tmpSubObjectName.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyReference = tmpSubObjectName.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[1].Tardy\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[\"JaneDoe\"].Grade\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an array, so the [\"JaneDoe\"].Grade is not possible to access\n\t\t\t\t// TODO: Should this be an error or something?  Should we keep a log of failures like this?\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// Because this is an impossible address, the property doesn't exist\n\t\t\t\t\t// TODO: Should we throw an error in this condition?\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//This is a bracketed value\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to reat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynanmic object property.\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Recurse directly into the subobject\n\t\t\t\t\treturn this.checkAddressExists(pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference], tmpNewAddress, tmpRootObject);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// We parsed a valid number out of the boxed property name, so recurse into the array\n\t\t\t\t\treturn this.checkAddressExists(pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber], tmpNewAddress, tmpRootObject);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there is an object property already named for the sub object, but it isn't an object\n\t\t\t// then the system can't set the value in there.  Error and abort!\n\t\t\tif ((tmpSubObjectName in pObject) && typeof(pObject[tmpSubObjectName]) !== 'object')\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (tmpSubObjectName in pObject)\n\t\t\t{\n\t\t\t\t// If there is already a subobject pass that to the recursive thingy\n\t\t\t\treturn this.checkAddressExists(pObject[tmpSubObjectName], tmpNewAddress, tmpRootObject);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Create a subobject and then pass that\n\t\t\t\tpObject[tmpSubObjectName] = {};\n\t\t\t\treturn this.checkAddressExists(pObject[tmpSubObjectName], tmpNewAddress, tmpRootObject);\n\t\t\t}\n\t\t}\n\t}\n};\n\nmodule.exports = ManyfestObjectAddressResolverCheckAddressExists;\n},{\"./Manyfest-LogToConsole.js\":4,\"./Manyfest-ObjectAddress-GetValue.js\":7,\"./Manyfest-ObjectAddress-Parser.js\":8}],6:[function(require,module,exports){\n/**\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\nlet fCleanWrapCharacters = require('./Manyfest-CleanWrapCharacters.js');\nlet fParseConditionals = require(`../source/Manyfest-ParseConditionals.js`)\n\n/**\n* Object Address Resolver - DeleteValue\n*\n* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to\n*                 be extremely clear what is going on in the recursion for\n*                 each of the three address resolution functions.\n*\n*                 Although there is some opportunity to repeat ourselves a\n*                 bit less in this codebase (e.g. with detection of arrays\n*                 versus objects versus direct properties), it can make\n*                 debugging.. challenging.  The minified version of the code\n*                 optimizes out almost anything repeated in here.  So please\n*                 be kind and rewind... meaning please keep the codebase less\n*                 terse and more verbose so humans can comprehend it.\n*\n* TODO: Once we validate this pattern is good to go, break these out into\n*       three separate modules.\n*\n* @class ManyfestObjectAddressResolverDeleteValue\n*/\nclass ManyfestObjectAddressResolverDeleteValue\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) == 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) == 'function') ? pErrorLog : libSimpleLog;\n\n\t\tthis.cleanWrapCharacters = fCleanWrapCharacters;\n\t}\n\n\t// TODO: Dry me\n\tcheckRecordFilters(pAddress, pRecord)\n\t{\n\t\treturn fParseConditionals(this, pAddress, pRecord);\n\t}\n\n\t// Delete the value of an element at an address\n\tdeleteValueAtAddress (pObject, pAddress, pParentAddress)\n\t{\n\t\t// Make sure pObject (the object we are meant to be recursing) is an object (which could be an array or object)\n\t\tif (typeof(pObject) != 'object') return undefined;\n\t\t// Make sure pAddress (the address we are resolving) is a string\n\t\tif (typeof(pAddress) != 'string') return undefined;\n\t\t// Stash the parent address for later resolution\n\t\tlet tmpParentAddress = \"\";\n\t\tif (typeof(pParentAddress) == 'string')\n\t\t{\n\t\t\ttmpParentAddress = pParentAddress;\n\t\t}\n\n\t\t// TODO: Make this work for things like SomeRootObject.Metadata[\"Some.People.Use.Bad.Object.Property.Names\"]\n\t\tlet tmpSeparatorIndex = pAddress.indexOf('.');\n\n\t\t// This is the terminal address string (no more dots so the RECUSION ENDS IN HERE somehow)\n\t\tif (tmpSeparatorIndex == -1)\n\t\t{\n\t\t\t// Check if the address refers to a boxed property\n\t\t\tlet tmpBracketStartIndex = pAddress.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = pAddress.indexOf(']');\n\n\t\t\t// Check for the Object Set Type marker.\n\t\t\t// Note this will not work with a bracket in the same address box set\n\t\t\tlet tmpObjectTypeMarkerIndex = pAddress.indexOf('{}');\n\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[10]\n\t\t\t// \t\tMyValues['Name']\n\t\t\t// \t\tMyValues[\"Age\"]\n\t\t\t// \t\tMyValues[`Cost`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\t// The \"Name\" of the Object contained too the left of the bracket\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\t// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.\n\t\t\t\t// This is a rare case where Arrays testing as Objects is useful\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// The \"Reference\" to the property within it, either an array element or object property\n\t\t\t\tlet tmpBoxedPropertyReference = pAddress.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\t\t\t\t// Attempt to parse the reference as a number, which will be used as an array element\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to treat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynamic object property.\n\t\t\t\t\t// We would expect the property to be wrapped in some kind of quotes so strip them\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Return the value in the property\n\t\t\t\t\tdelete pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference];\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdelete pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber];\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// The requirements to detect a boxed set element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is nothing in the brackets\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex == 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tif (!Array.isArray(pObject[tmpBoxedPropertyName]))\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tlet tmpInputArray = pObject[tmpBoxedPropertyName];\n\t\t\t\t// Count from the end to the beginning so splice doesn't %&%#$ up the array\n\t\t\t\tfor (let i = tmpInputArray.length - 1; i >= 0; i--)\n\t\t\t\t{\n\t\t\t\t\t// The filtering is complex but allows config-based metaprogramming directly from schema\n\t\t\t\t\tlet tmpKeepRecord = this.checkRecordFilters(pAddress, tmpInputArray[i]);\n\t\t\t\t\tif (tmpKeepRecord)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Delete elements end to beginning\n\t\t\t\t\t\ttmpInputArray.splice(i, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// The object has been flagged as an object set, so treat it as such\n\t\t\telse if (tmpObjectTypeMarkerIndex > 0)\n\t\t\t{\n\t\t\t\tlet tmpObjectPropertyName = pAddress.substring(0, tmpObjectTypeMarkerIndex).trim();\n\n\t\t\t\tif (typeof(pObject[tmpObjectPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tdelete pObject[tmpObjectPropertyName];\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Now is the point in recursion to return the value in the address\n\t\t\t\tdelete pObject[pAddress];\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpSubObjectName = pAddress.substring(0, tmpSeparatorIndex);\n\t\t\tlet tmpNewAddress = pAddress.substring(tmpSeparatorIndex+1);\n\n\t\t\t// BOXED ELEMENTS\n\t\t\t// Test if the tmpNewAddress is an array or object\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = tmpSubObjectName.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = tmpSubObjectName.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[42]\n\t\t\t// \t\tMyValues['Color']\n\t\t\t// \t\tMyValues[\"Weight\"]\n\t\t\t// \t\tMyValues[`Diameter`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = tmpSubObjectName.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyReference = tmpSubObjectName.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[1].Tardy\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[\"JaneDoe\"].Grade\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an array, so the [\"JaneDoe\"].Grade is not possible to access\n\t\t\t\t// TODO: Should this be an error or something?  Should we keep a log of failures like this?\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// Check if the boxed property is an object.\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t//This is a bracketed value\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to reat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynanmic object property.\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\t\t// Recurse directly into the subobject\n\t\t\t\t\treturn this.deleteValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference], tmpNewAddress, tmpParentAddress);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\t\t// We parsed a valid number out of the boxed property name, so recurse into the array\n\t\t\t\t\treturn this.deleteValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber], tmpNewAddress, tmpParentAddress);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// The requirements to detect a boxed set element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is nothing in the brackets\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex == 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tif (!Array.isArray(pObject[tmpBoxedPropertyName]))\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// We need to enumerate the array and grab the addresses from there.\n\t\t\t\tlet tmpArrayProperty = pObject[tmpBoxedPropertyName];\n\t\t\t\t// Managing the parent address is a bit more complex here -- the box will be added for each element.\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpBoxedPropertyName}`;\n\t\t\t\t// The container object is where we have the \"Address\":SOMEVALUE pairs\n\t\t\t\tlet tmpContainerObject = {};\n\t\t\t\tfor (let i = 0; i < tmpArrayProperty.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpPropertyParentAddress = `${tmpParentAddress}[${i}]`;\n\t\t\t\t\tlet tmpValue = this.deleteValueAtAddress(pObject[tmpBoxedPropertyName][i], tmpNewAddress, tmpPropertyParentAddress);\n\n\t\t\t\t\ttmpContainerObject[`${tmpPropertyParentAddress}.${tmpNewAddress}`] = tmpValue;\n\t\t\t\t}\n\n\t\t\t\treturn tmpContainerObject;\n\t\t\t}\n\n\t\t\t// OBJECT SET\n\t\t\t// Note this will not work with a bracket in the same address box set\n\t\t\tlet tmpObjectTypeMarkerIndex = pAddress.indexOf('{}');\n\t\t\tif (tmpObjectTypeMarkerIndex > 0)\n\t\t\t{\n\t\t\t\tlet tmpObjectPropertyName = pAddress.substring(0, tmpObjectTypeMarkerIndex).trim();\n\n\t\t\t\tif (typeof(pObject[tmpObjectPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// We need to enumerate the Object and grab the addresses from there.\n\t\t\t\tlet tmpObjectProperty = pObject[tmpObjectPropertyName];\n\t\t\t\tlet tmpObjectPropertyKeys = Object.keys(tmpObjectProperty);\n\t\t\t\t// Managing the parent address is a bit more complex here -- the box will be added for each element.\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpObjectPropertyName}`;\n\t\t\t\t// The container object is where we have the \"Address\":SOMEVALUE pairs\n\t\t\t\tlet tmpContainerObject = {};\n\t\t\t\tfor (let i = 0; i < tmpObjectPropertyKeys.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpPropertyParentAddress = `${tmpParentAddress}.${tmpObjectPropertyKeys[i]}`;\n\t\t\t\t\tlet tmpValue = this.deleteValueAtAddress(pObject[tmpObjectPropertyName][tmpObjectPropertyKeys[i]], tmpNewAddress, tmpPropertyParentAddress);\n\n\t\t\t\t\t// The filtering is complex but allows config-based metaprogramming directly from schema\n\t\t\t\t\tlet tmpKeepRecord = this.checkRecordFilters(pAddress, tmpValue);\n\t\t\t\t\tif (tmpKeepRecord)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpContainerObject[`${tmpPropertyParentAddress}.${tmpNewAddress}`] = tmpValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmpContainerObject;\n\t\t\t}\n\n\t\t\t// If there is an object property already named for the sub object, but it isn't an object\n\t\t\t// then the system can't set the value in there.  Error and abort!\n\t\t\tif ((tmpSubObjectName in pObject) && typeof(pObject[tmpSubObjectName]) !== 'object')\n\t\t\t{\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\telse if (tmpSubObjectName in pObject)\n\t\t\t{\n\t\t\t\t// If there is already a subobject pass that to the recursive thingy\n\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\treturn this.deleteValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, tmpParentAddress);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Create a subobject and then pass that\n\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\tpObject[tmpSubObjectName] = {};\n\t\t\t\treturn this.deleteValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, tmpParentAddress);\n\t\t\t}\n\t\t}\n\t}\n};\n\nmodule.exports = ManyfestObjectAddressResolverDeleteValue;\n},{\"../source/Manyfest-ParseConditionals.js\":11,\"./Manyfest-CleanWrapCharacters.js\":2,\"./Manyfest-LogToConsole.js\":4}],7:[function(require,module,exports){\n/**\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\nlet fCleanWrapCharacters = require('./Manyfest-CleanWrapCharacters.js');\nlet fParseConditionals = require(`../source/Manyfest-ParseConditionals.js`);\n\nlet _MockFable = { DataFormat: require('./Manyfest-ObjectAddress-Parser.js') };\n\n/**\n* Object Address Resolver - GetValue\n*\n* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to\n*                 be extremely clear what is going on in the recursion for\n*                 each of the three address resolution functions.\n*\n*                 Although there is some opportunity to repeat ourselves a\n*                 bit less in this codebase (e.g. with detection of arrays\n*                 versus objects versus direct properties), it can make\n*                 debugging.. challenging.  The minified version of the code\n*                 optimizes out almost anything repeated in here.  So please\n*                 be kind and rewind... meaning please keep the codebase less\n*                 terse and more verbose so humans can comprehend it.\n*\n* TODO: Once we validate this pattern is good to go, break these out into\n*       three separate modules.\n*\n* @class ManyfestObjectAddressResolverGetValue\n*/\nclass ManyfestObjectAddressResolverGetValue\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) == 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) == 'function') ? pErrorLog : libSimpleLog;\n\n\t\tthis.cleanWrapCharacters = fCleanWrapCharacters;\n\t}\n\n\tcheckRecordFilters(pAddress, pRecord)\n\t{\n\t\treturn fParseConditionals(this, pAddress, pRecord);\n\t}\n\n\t// Get the value of an element at an address\n\tgetValueAtAddress (pObject, pAddress, pParentAddress, pRootObject)\n\t{\n\t\t// Make sure pObject (the object we are meant to be recursing) is an object (which could be an array or object)\n\t\tif (typeof(pObject) != 'object') return undefined;\n\t\t// Make sure pAddress (the address we are resolving) is a string\n\t\tif (typeof(pAddress) != 'string') return undefined;\n\t\t// Stash the parent address for later resolution\n\t\tlet tmpParentAddress = \"\";\n\t\tif (typeof(pParentAddress) == 'string')\n\t\t{\n\t\t\ttmpParentAddress = pParentAddress;\n\t\t}\n\n\t\t// Set the root object to the passed-in object if it isn't set yet.  This is expected to be the root object.\n\t\tlet tmpRootObject = (typeof(pRootObject) == 'undefined') ? pObject : pRootObject;\n\n\t\t// DONE: Make this work for things like SomeRootObject.Metadata[\"Some.People.Use.Bad.Object.Property.Names\"]\n\t\tlet tmpAddressPartBeginning = _MockFable.DataFormat.stringGetFirstSegment(pAddress);\n\n\t\t// Adding simple back-navigation in objects\n\t\tif (tmpAddressPartBeginning == '')\n\t\t{\n\t\t\t// Given an address of \"Bundle.Contract.IDContract...Project.IDProject\" the ... would be interpreted as two back-navigations from IDContract.\n\t\t\t// When the address is passed in, though, the first . is already eliminated.  So we can count the dots.\n\t\t\tlet tmpParentAddressParts = _MockFable.DataFormat.stringGetSegments(tmpParentAddress);\n\n\t\t\tlet tmpBackNavigationCount = 0;\n\n\t\t\t// Count the number of dots\n\t\t\tfor (let i = 0; i < pAddress.length; i++)\n\t\t\t{\n\t\t\t\tif (pAddress.charAt(i) != '.')\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttmpBackNavigationCount++;\n\t\t\t}\n\n\t\t\tlet tmpParentAddressLength = tmpParentAddressParts.length - tmpBackNavigationCount;\n\n\t\t\tif (tmpParentAddressLength < 0)\n\t\t\t{\n\t\t\t\t// We are trying to back navigate more than we can.\n\t\t\t\t// TODO: Should this be undefined or should we bank out at the bottom and try to go forward?\n\t\t\t\t// This seems safest for now.\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// We are trying to back navigate to a parent object.\n\t\t\t\t// Recurse with the back-propagated parent address, and, the new address without the back-navigation dots.\n\t\t\t\tlet tmpRecurseAddress = pAddress.slice(tmpBackNavigationCount);\n\t\t\t\tif (tmpParentAddressLength > 0)\n\t\t\t\t{\n\t\t\t\t\ttmpRecurseAddress = `${tmpParentAddressParts.slice(0, tmpParentAddressLength).join('.')}.${tmpRecurseAddress}`;\n\t\t\t\t}\n\t\t\t\tthis.logInfo(`Back-navigation detected.  Recursing back to address [${tmpRecurseAddress}]`);\n\t\t\t\treturn this.getValueAtAddress(tmpRootObject, tmpRecurseAddress);\n\t\t\t}\n\t\t}\n\n\t\t// This is the terminal address string (no more dots so the RECUSION ENDS IN HERE somehow)\n\t\tif (tmpAddressPartBeginning.length == pAddress.length)\n\t\t{\n\t\t\t// TODO: Optimize this by having these calls only happen when the previous fails.\n\t\t\t// TODO: Alternatively look for all markers in one pass?\n\t\t\t// Check if the address refers to a boxed property\n\t\t\tlet tmpBracketStartIndex = pAddress.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = pAddress.indexOf(']');\n\n\t\t\t// Check for the Object Set Type marker.\n\t\t\t// Note this will not work with a bracket in the same address box set\n\t\t\tlet tmpObjectTypeMarkerIndex = pAddress.indexOf('{}');\n\n\n\t\t\t// Check if there is a function somewhere in the address... parenthesis start should only be in a function\n\t\t\tlet tmpFunctionStartIndex = pAddress.indexOf('(');\n\n\t\t\t// NOTE THAT FUNCTIONS MUST RESOLVE FIRST\n\t\t\t// Functions look like this\n\t\t\t// \t\tMyFunction()\n\t\t\t// \t\tMyFunction(Some.Address)\n\t\t\t// \t\tMyFunction(Some.Address,Some.Other.Address)\n\t\t\t// \t\tMyFunction(Some.Address,Some.Other.Address,Some.Third.Address)\n\t\t\t//\n\t\t\t// This could be enhanced to allow purely numeric and string values to be passed to the function.  For now,\n\t\t\t// To heck with that.  This is a simple function call.\n\t\t\t//\n\t\t\t// The requirements to detect a function are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpFunctionStartIndex > 0)\n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (_MockFable.DataFormat.stringCountEnclosures(pAddress) > 0))\n\t\t\t{\n\t\t\t\tlet tmpFunctionAddress = pAddress.substring(0, tmpFunctionStartIndex).trim();\n\n\t\t\t\tif (!typeof(pObject[tmpFunctionAddress]) == 'function')\n\t\t\t\t{\n\t\t\t\t\t// The address suggests it is a function, but it is not.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Now see if the function has arguments.\n\t\t\t\t// Implementation notes: * ARGUMENTS MUST SHARE THE SAME ROOT OBJECT CONTEXT *\n\t\t\t\tlet tmpFunctionArguments = _MockFable.DataFormat.stringGetSegments(_MockFable.DataFormat.stringGetEnclosureValueByIndex(pAddress.substring(tmpFunctionAddress.length), 0), ',');\n\t\t\t\tif ((tmpFunctionArguments.length == 0) || (tmpFunctionArguments[0] == ''))\n\t\t\t\t{\n\t\t\t\t\t// No arguments... just call the function (bound to the scope of the object it is contained withing)\n\t\t\t\t\tif (tmpFunctionAddress in pObject)\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn pObject[tmpFunctionAddress].apply(pObject);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(pError)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// The function call failed, so the address doesn't exist\n\t\t\t\t\t\t\tconsole.log(`Error in getValueAtAddress calling function ${tmpFunctionAddress} (address [${pAddress}]): ${pError.message}`);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// The function doesn't exist, so the address doesn't exist\n\t\t\t\t\t\tconsole.log(`Function ${tmpFunctionAddress} does not exist (address [${pAddress}])`);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlet tmpArgumentValues = [];\n\n\t\t\t\t\tlet tmpRootObject = (typeof(pRootObject) == 'undefined') ? pObject : pRootObject;\n\n\t\t\t\t\t// Now get the value for each argument\n\t\t\t\t\tfor (let i = 0; i < tmpFunctionArguments.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Resolve the values for each subsequent entry\n\t\t\t\t\t\t// Check if the argument value is a string literal or a reference to an address\n\t\t\t\t\t\tif ((tmpFunctionArguments[i].length >= 2)\n\t\t\t\t\t\t\t&&\n\t\t\t\t\t\t\t((tmpFunctionArguments[i].charAt(0) == '\"')\n\t\t\t\t\t\t\t|| (tmpFunctionArguments[i].charAt(0) == \"'\")\n\t\t\t\t\t\t\t|| (tmpFunctionArguments[i].charAt(0) == \"`\"))\n\t\t\t\t\t\t\t&&\n\t\t\t\t\t\t\t((tmpFunctionArguments[i].charAt(tmpFunctionArguments[i].length-1) == '\"')\n\t\t\t\t\t\t\t|| (tmpFunctionArguments[i].charAt(tmpFunctionArguments[i].length-1) == \"'\")\n\t\t\t\t\t\t\t|| (tmpFunctionArguments[i].charAt(tmpFunctionArguments[i].length-1) == \"`\")))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// This is a string literal\n\t\t\t\t\t\t\ttmpArgumentValues.push(tmpFunctionArguments[i].substring(1, tmpFunctionArguments[i].length-1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// This is a hash address\n\t\t\t\t\t\t\ttmpArgumentValues.push(this.getValueAtAddress(tmpRootObject, tmpFunctionArguments[i]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (tmpFunctionAddress in pObject)\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn pObject[tmpFunctionAddress].apply(pObject, tmpArgumentValues);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(pError)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// The function call failed, so the address doesn't exist\n\t\t\t\t\t\t\tconsole.log(`Error in getValueAtAddress calling function ${tmpFunctionAddress} (address [${pAddress}]): ${pError.message}`);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// The function doesn't exist, so the address doesn't exist\n\t\t\t\t\t\tconsole.log(`Function ${tmpFunctionAddress} does not exist (address [${pAddress}])`);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[10]\n\t\t\t// \t\tMyValues['Name']\n\t\t\t// \t\tMyValues[\"Age\"]\n\t\t\t// \t\tMyValues[`Cost`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\t// The \"Name\" of the Object contained too the left of the bracket\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\t// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.\n\t\t\t\t// This is a rare case where Arrays testing as Objects is useful\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\t// The \"Reference\" to the property within it, either an array element or object property\n\t\t\t\tlet tmpBoxedPropertyReference = pAddress.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\t\t\t\t// Attempt to parse the reference as a number, which will be used as an array element\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to treat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynamic object property.\n\t\t\t\t\t// We would expect the property to be wrapped in some kind of quotes so strip them\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Return the value in the property\n\t\t\t\t\treturn pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// The requirements to detect a boxed set element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is nothing in the brackets\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex == 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tif (!Array.isArray(pObject[tmpBoxedPropertyName]))\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tlet tmpInputArray = pObject[tmpBoxedPropertyName];\n\t\t\t\tlet tmpOutputArray = [];\n\t\t\t\tfor (let i = 0; i < tmpInputArray.length; i++)\n\t\t\t\t{\n\t\t\t\t\t// The filtering is complex but allows config-based metaprogramming directly from schema\n\t\t\t\t\tlet tmpKeepRecord = this.checkRecordFilters(pAddress, tmpInputArray[i]);\n\t\t\t\t\tif (tmpKeepRecord)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpOutputArray.push(tmpInputArray[i]);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmpOutputArray;\n\t\t\t}\n\t\t\t// The object has been flagged as an object set, so treat it as such\n\t\t\telse if (tmpObjectTypeMarkerIndex > 0)\n\t\t\t{\n\t\t\t\tlet tmpObjectPropertyName = pAddress.substring(0, tmpObjectTypeMarkerIndex).trim();\n\n\t\t\t\tif (typeof(pObject[tmpObjectPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\treturn pObject[tmpObjectPropertyName];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Now is the point in recursion to return the value in the address\n\t\t\t\tif (typeof(pObject[pAddress]) != null)\n\t\t\t\t{\n\t\t\t\t\treturn pObject[pAddress];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//let tmpSubObjectName = pAddress.substring(0, tmpSeparatorIndex);\n\t\t\t//let tmpNewAddress = pAddress.substring(tmpSeparatorIndex+1);\n\t\t\tlet tmpSubObjectName = tmpAddressPartBeginning;\n\t\t\tlet tmpNewAddress = pAddress.substring(tmpAddressPartBeginning.length+1);\n\n\t\t\t// BOXED ELEMENTS\n\t\t\t// Test if the tmpNewAddress is an array or object\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = tmpSubObjectName.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = tmpSubObjectName.indexOf(']');\n\n\t\t\t// Check if there is a function somewhere in the address... parenthesis start should only be in a function\n\t\t\tlet tmpFunctionStartIndex = tmpSubObjectName.indexOf('(');\n\n\t\t\t// NOTE THAT FUNCTIONS MUST RESOLVE FIRST\n\t\t\t// Functions look like this\n\t\t\t// \t\tMyFunction()\n\t\t\t// \t\tMyFunction(Some.Address)\n\t\t\t// \t\tMyFunction(Some.Address,Some.Other.Address)\n\t\t\t// \t\tMyFunction(Some.Address,Some.Other.Address,Some.Third.Address)\n\t\t\t//\n\t\t\t// This could be enhanced to allow purely numeric and string values to be passed to the function.  For now,\n\t\t\t// To heck with that.  This is a simple function call.\n\t\t\t//\n\t\t\t// The requirements to detect a function are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpFunctionStartIndex > 0)\n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (_MockFable.DataFormat.stringCountEnclosures(tmpSubObjectName) > 0))\n\t\t\t{\n\t\t\t\tlet tmpFunctionAddress = tmpSubObjectName.substring(0, tmpFunctionStartIndex).trim();\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\n\t\t\t\tif (!typeof(pObject[tmpFunctionAddress]) == 'function')\n\t\t\t\t{\n\t\t\t\t\t// The address suggests it is a function, but it is not.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Now see if the function has arguments.\n\t\t\t\t// Implementation notes: * ARGUMENTS MUST SHARE THE SAME ROOT OBJECT CONTEXT *\n\t\t\t\tlet tmpFunctionArguments = _MockFable.DataFormat.stringGetSegments(_MockFable.DataFormat.stringGetEnclosureValueByIndex(tmpSubObjectName.substring(tmpFunctionAddress.length), 0), ',');\n\t\t\t\tif ((tmpFunctionArguments.length == 0) || (tmpFunctionArguments[0] == ''))\n\t\t\t\t{\n\t\t\t\t\t// No arguments... just call the function (bound to the scope of the object it is contained withing)\n\t\t\t\t\tif (tmpFunctionAddress in pObject)\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn this.getValueAtAddress(pObject[tmpFunctionAddress].apply(pObject), tmpNewAddress, tmpParentAddress, tmpRootObject);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(pError)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// The function call failed, so the address doesn't exist\n\t\t\t\t\t\t\tconsole.log(`Error in getValueAtAddress calling function ${tmpFunctionAddress} (address [${pAddress}]): ${pError.message}`);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// The function doesn't exist, so the address doesn't exist\n\t\t\t\t\t\tconsole.log(`Function ${tmpFunctionAddress} does not exist (address [${pAddress}])`);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlet tmpArgumentValues = [];\n\n\t\t\t\t\tlet tmpRootObject = (typeof(pRootObject) == 'undefined') ? pObject : pRootObject;\n\n\t\t\t\t\t// Now get the value for each argument\n\t\t\t\t\tfor (let i = 0; i < tmpFunctionArguments.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Resolve the values for each subsequent entry\n\t\t\t\t\t\t// Check if the argument value is a string literal or a reference to an address\n\t\t\t\t\t\tif ((tmpFunctionArguments[i].length >= 2)\n\t\t\t\t\t\t\t&&\n\t\t\t\t\t\t\t((tmpFunctionArguments[i].charAt(0) == '\"')\n\t\t\t\t\t\t\t|| (tmpFunctionArguments[i].charAt(0) == \"'\")\n\t\t\t\t\t\t\t|| (tmpFunctionArguments[i].charAt(0) == \"`\"))\n\t\t\t\t\t\t\t&&\n\t\t\t\t\t\t\t((tmpFunctionArguments[i].charAt(tmpFunctionArguments[i].length-1) == '\"')\n\t\t\t\t\t\t\t|| (tmpFunctionArguments[i].charAt(tmpFunctionArguments[i].length-1) == \"'\")\n\t\t\t\t\t\t\t|| (tmpFunctionArguments[i].charAt(tmpFunctionArguments[i].length-1) == \"`\")))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// This is a string literal\n\t\t\t\t\t\t\ttmpArgumentValues.push(tmpFunctionArguments[i].substring(1, tmpFunctionArguments[i].length-1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// This is a hash address\n\t\t\t\t\t\t\ttmpArgumentValues.push(this.getValueAtAddress(tmpRootObject, tmpFunctionArguments[i]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (tmpFunctionAddress in pObject)\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn this.getValueAtAddress(pObject[tmpFunctionAddress].apply(pObject, tmpArgumentValues), tmpNewAddress, tmpParentAddress, tmpRootObject);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(pError)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// The function call failed, so the address doesn't exist\n\t\t\t\t\t\t\tconsole.log(`Error in getValueAtAddress calling function ${tmpFunctionAddress} (address [${pAddress}]): ${pError.message}`);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// The function doesn't exist, so the address doesn't exist\n\t\t\t\t\t\tconsole.log(`Function ${tmpFunctionAddress} does not exist (address [${pAddress}])`);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[42]\n\t\t\t// \t\tMyValues['Color']\n\t\t\t// \t\tMyValues[\"Weight\"]\n\t\t\t// \t\tMyValues[`Diameter`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = tmpSubObjectName.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyReference = tmpSubObjectName.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[1].Tardy\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[\"JaneDoe\"].Grade\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an array, so the [\"JaneDoe\"].Grade is not possible to access\n\t\t\t\t// TODO: Should this be an error or something?  Should we keep a log of failures like this?\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\t// Check if the boxed property is an object.\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\n\t\t\t\t//This is a bracketed value\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to reat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynanmic object property.\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\t\t// Recurse directly into the subobject\n\t\t\t\t\treturn this.getValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference], tmpNewAddress, tmpParentAddress, tmpRootObject);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\t\t// We parsed a valid number out of the boxed property name, so recurse into the array\n\t\t\t\t\treturn this.getValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber], tmpNewAddress, tmpParentAddress, tmpRootObject);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// The requirements to detect a boxed set element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is nothing in the brackets\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex == 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tif (!Array.isArray(pObject[tmpBoxedPropertyName]))\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// We need to enumerate the array and grab the addresses from there.\n\t\t\t\tlet tmpArrayProperty = pObject[tmpBoxedPropertyName];\n\t\t\t\t// Managing the parent address is a bit more complex here -- the box will be added for each element.\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpBoxedPropertyName}`;\n\t\t\t\t// The container object is where we have the \"Address\":SOMEVALUE pairs\n\t\t\t\tlet tmpContainerObject = {};\n\t\t\t\tfor (let i = 0; i < tmpArrayProperty.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpPropertyParentAddress = `${tmpParentAddress}[${i}]`;\n\t\t\t\t\tlet tmpValue = this.getValueAtAddress(pObject[tmpBoxedPropertyName][i], tmpNewAddress, tmpPropertyParentAddress, tmpRootObject);\n\n\t\t\t\t\ttmpContainerObject[`${tmpPropertyParentAddress}.${tmpNewAddress}`] = tmpValue;\n\t\t\t\t}\n\n\t\t\t\treturn tmpContainerObject;\n\t\t\t}\n\n\t\t\t// OBJECT SET\n\t\t\t// Note this will not work with a bracket in the same address box set\n\t\t\tlet tmpObjectTypeMarkerIndex = pAddress.indexOf('{}');\n\t\t\tif (tmpObjectTypeMarkerIndex > 0)\n\t\t\t{\n\t\t\t\tlet tmpObjectPropertyName = pAddress.substring(0, tmpObjectTypeMarkerIndex).trim();\n\n\t\t\t\tif (typeof(pObject[tmpObjectPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// We need to enumerate the Object and grab the addresses from there.\n\t\t\t\tlet tmpObjectProperty = pObject[tmpObjectPropertyName];\n\t\t\t\tlet tmpObjectPropertyKeys = Object.keys(tmpObjectProperty);\n\t\t\t\t// Managing the parent address is a bit more complex here -- the box will be added for each element.\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpObjectPropertyName}`;\n\t\t\t\t// The container object is where we have the \"Address\":SOMEVALUE pairs\n\t\t\t\tlet tmpContainerObject = {};\n\t\t\t\tfor (let i = 0; i < tmpObjectPropertyKeys.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpPropertyParentAddress = `${tmpParentAddress}.${tmpObjectPropertyKeys[i]}`;\n\t\t\t\t\tlet tmpValue = this.getValueAtAddress(pObject[tmpObjectPropertyName][tmpObjectPropertyKeys[i]], tmpNewAddress, tmpPropertyParentAddress, tmpRootObject);\n\n\t\t\t\t\t// The filtering is complex but allows config-based metaprogramming directly from schema\n\t\t\t\t\tlet tmpKeepRecord = this.checkRecordFilters(pAddress, tmpValue);\n\t\t\t\t\tif (tmpKeepRecord)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpContainerObject[`${tmpPropertyParentAddress}.${tmpNewAddress}`] = tmpValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmpContainerObject;\n\t\t\t}\n\n\t\t\t// If there is an object property already named for the sub object, but it isn't an object\n\t\t\t// then the system can't set the value in there.  Error and abort!\n\t\t\tif ((tmpSubObjectName in pObject) && typeof(pObject[tmpSubObjectName]) !== 'object')\n\t\t\t{\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\telse if (tmpSubObjectName in pObject)\n\t\t\t{\n\t\t\t\t// If there is already a subobject pass that to the recursive thingy\n\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\treturn this.getValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, tmpParentAddress, tmpRootObject);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Create a subobject and then pass that\n\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\tpObject[tmpSubObjectName] = {};\n\t\t\t\treturn this.getValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, tmpParentAddress, tmpRootObject);\n\t\t\t}\n\t\t}\n\t}\n};\n\nmodule.exports = ManyfestObjectAddressResolverGetValue;\n},{\"../source/Manyfest-ParseConditionals.js\":11,\"./Manyfest-CleanWrapCharacters.js\":2,\"./Manyfest-LogToConsole.js\":4,\"./Manyfest-ObjectAddress-Parser.js\":8}],8:[function(require,module,exports){\n// TODO: This is an inelegant solution to delay the rewrite of Manyfest.\n\n// Fable 3.0 has a service for data formatting that deals well with nested enclosures.\n\n// The Manyfest library predates fable 3.0 and the services structure of it, so the functions\n// are more or less pure javascript and as functional as they can be made to be.\n\n// Until we shift Manyfest to be a fable service, these three functions were pulled out of\n// fable to aid in parsing functions with nested enclosures.\n\nmodule.exports = {\n\t/**\n\t * Count the number of segments in a string, respecting enclosures\n\t * \n\t * @param {string} pString \n\t * @param {string} pSeparator \n\t * @param {object} pEnclosureStartSymbolMap \n\t * @param {object} pEnclosureEndSymbolMap \n\t * @returns the count of segments in the string as a number\n\t */\n\tstringCountSegments: (pString, pSeparator, pEnclosureStartSymbolMap, pEnclosureEndSymbolMap) =>\n\t{\n\t\tlet tmpString = (typeof(pString) == 'string') ? pString : '';\n\n\t\tlet tmpSeparator = (typeof(pSeparator) == 'string') ? pSeparator : '.';\n\n\t\tlet tmpEnclosureStartSymbolMap = (typeof(pEnclosureStartSymbolMap) == 'object') ? pEnclosureStart : { '{': 0, '[': 1, '(': 2 };\n\t\tlet tmpEnclosureEndSymbolMap = (typeof(pEnclosureEndSymbolMap) == 'object') ? pEnclosureEnd : { '}': 0, ']': 1, ')': 2 };\n\n\t\tif (pString.length < 1)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet tmpSegmentCount = 1;\n\t\tlet tmpEnclosureStack = [];\n\n\t\tfor (let i = 0; i < tmpString.length; i++)\n\t\t{\n\t\t\t// IF This is the start of a segment\n\t\t\tif ((tmpString[i] == tmpSeparator)\n\t\t\t\t// AND we are not in a nested portion of the string\n\t\t\t\t&& (tmpEnclosureStack.length == 0))\n\t\t\t{\n\t\t\t\t// Increment the segment count\n\t\t\t\ttmpSegmentCount++;\n\t\t\t}\n\t\t\t// IF This is the start of an enclosure\n\t\t\telse if (tmpString[i] in tmpEnclosureStartSymbolMap)\n\t\t\t{\n\t\t\t\t// Add it to the stack!\n\t\t\t\ttmpEnclosureStack.push(tmpEnclosureStartSymbolMap[tmpString[i]]);\n\t\t\t}\n\t\t\t// IF This is the end of an enclosure\n\t\t\telse if ((tmpString[i] in tmpEnclosureEndSymbolMap)\n\t\t\t\t// AND it matches the current nest level symbol\n\t\t\t\t&& tmpEnclosureEndSymbolMap[tmpString[i]] == tmpEnclosureStack[tmpEnclosureStack.length - 1])\n\t\t\t{\n\t\t\t\t// Pop it off the stack!\n\t\t\t\ttmpEnclosureStack.pop();\n\t\t\t}\n\t\t}\n\n\t\treturn tmpSegmentCount;\n\t},\n\n\t/**\n\t * Get the first segment in a string, respecting enclosures\n\t * \n\t * @param {string} pString \n\t * @param {string} pSeparator \n\t * @param {object} pEnclosureStartSymbolMap \n\t * @param {object} pEnclosureEndSymbolMap \n\t * @returns the first segment in the string as a string\n\t */\n\tstringGetFirstSegment: (pString, pSeparator, pEnclosureStartSymbolMap, pEnclosureEndSymbolMap) =>\n\t{\n\t\tlet tmpString = (typeof(pString) == 'string') ? pString : '';\n\n\t\tlet tmpSeparator = (typeof(pSeparator) == 'string') ? pSeparator : '.';\n\n\t\tlet tmpEnclosureStartSymbolMap = (typeof(pEnclosureStartSymbolMap) == 'object') ? pEnclosureStart : { '{': 0, '[': 1, '(': 2 };\n\t\tlet tmpEnclosureEndSymbolMap = (typeof(pEnclosureEndSymbolMap) == 'object') ? pEnclosureEnd : { '}': 0, ']': 1, ')': 2 };\n\n\t\tif (pString.length < 1)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet tmpEnclosureStack = [];\n\n\t\tfor (let i = 0; i < tmpString.length; i++)\n\t\t{\n\t\t\t// IF This is the start of a segment\n\t\t\tif ((tmpString[i] == tmpSeparator)\n\t\t\t\t// AND we are not in a nested portion of the string\n\t\t\t\t&& (tmpEnclosureStack.length == 0))\n\t\t\t{\n\t\t\t\t// Return the segment\n\t\t\t\treturn tmpString.substring(0, i);\n\t\t\t}\n\t\t\t// IF This is the start of an enclosure\n\t\t\telse if (tmpString[i] in tmpEnclosureStartSymbolMap)\n\t\t\t{\n\t\t\t\t// Add it to the stack!\n\t\t\t\ttmpEnclosureStack.push(tmpEnclosureStartSymbolMap[tmpString[i]]);\n\t\t\t}\n\t\t\t// IF This is the end of an enclosure\n\t\t\telse if ((tmpString[i] in tmpEnclosureEndSymbolMap)\n\t\t\t\t// AND it matches the current nest level symbol\n\t\t\t\t&& tmpEnclosureEndSymbolMap[tmpString[i]] == tmpEnclosureStack[tmpEnclosureStack.length - 1])\n\t\t\t{\n\t\t\t\t// Pop it off the stack!\n\t\t\t\ttmpEnclosureStack.pop();\n\t\t\t}\n\t\t}\n\n\t\treturn tmpString;\n\t},\n\n\t/**\n\t * Get all segments in a string, respecting enclosures\n\t * \n\t * @param {string} pString \n\t * @param {string} pSeparator \n\t * @param {object} pEnclosureStartSymbolMap \n\t * @param {object} pEnclosureEndSymbolMap \n\t * @returns the first segment in the string as a string\n\t */\n\tstringGetSegments: (pString, pSeparator, pEnclosureStartSymbolMap, pEnclosureEndSymbolMap)=>\n\t{\n\t\tlet tmpString = (typeof(pString) == 'string') ? pString : '';\n\n\t\tlet tmpSeparator = (typeof(pSeparator) == 'string') ? pSeparator : '.';\n\n\t\tlet tmpEnclosureStartSymbolMap = (typeof(pEnclosureStartSymbolMap) == 'object') ? pEnclosureStart : { '{': 0, '[': 1, '(': 2 };\n\t\tlet tmpEnclosureEndSymbolMap = (typeof(pEnclosureEndSymbolMap) == 'object') ? pEnclosureEnd : { '}': 0, ']': 1, ')': 2 };\n\n\t\tlet tmpCurrentSegmentStart = 0;\n\t\tlet tmpSegmentList = [];\n\n\t\tif (pString.length < 1)\n\t\t{\n\t\t\treturn tmpSegmentList;\n\t\t}\n\n\t\tlet tmpEnclosureStack = [];\n\n\t\tfor (let i = 0; i < tmpString.length; i++)\n\t\t{\n\t\t\t// IF This is the start of a segment\n\t\t\tif ((tmpString[i] == tmpSeparator)\n\t\t\t\t// AND we are not in a nested portion of the string\n\t\t\t\t&& (tmpEnclosureStack.length == 0))\n\t\t\t{\n\t\t\t\t// Return the segment\n\t\t\t\ttmpSegmentList.push(tmpString.substring(tmpCurrentSegmentStart, i));\n\t\t\t\ttmpCurrentSegmentStart = i+1;\n\t\t\t}\n\t\t\t// IF This is the start of an enclosure\n\t\t\telse if (tmpString[i] in tmpEnclosureStartSymbolMap)\n\t\t\t{\n\t\t\t\t// Add it to the stack!\n\t\t\t\ttmpEnclosureStack.push(tmpEnclosureStartSymbolMap[tmpString[i]]);\n\t\t\t}\n\t\t\t// IF This is the end of an enclosure\n\t\t\telse if ((tmpString[i] in tmpEnclosureEndSymbolMap)\n\t\t\t\t// AND it matches the current nest level symbol\n\t\t\t\t&& tmpEnclosureEndSymbolMap[tmpString[i]] == tmpEnclosureStack[tmpEnclosureStack.length - 1])\n\t\t\t{\n\t\t\t\t// Pop it off the stack!\n\t\t\t\ttmpEnclosureStack.pop();\n\t\t\t}\n\t\t}\n\n\t\tif (tmpCurrentSegmentStart < tmpString.length)\n\t\t{\n\t\t\ttmpSegmentList.push(tmpString.substring(tmpCurrentSegmentStart));\n\t\t}\n\n\t\treturn tmpSegmentList;\n\t},\n\n\t/**\n\t * Count the number of enclosures in a string based on the start and end characters.\n\t *\n\t * If no start or end characters are specified, it will default to parentheses.  If the string is not a string, it will return 0.\n\t *\n\t * @param {string} pString\n\t * @param {string} pEnclosureStart\n\t * @param {string} pEnclosureEnd\n\t * @returns the count of full in the string\n\t */\n\tstringCountEnclosures: (pString, pEnclosureStart, pEnclosureEnd) =>\n\t{\n\t\tlet tmpString = (typeof(pString) == 'string') ? pString : '';\n\t\tlet tmpEnclosureStart = (typeof(pEnclosureStart) == 'string') ? pEnclosureStart : '(';\n\t\tlet tmpEnclosureEnd = (typeof(pEnclosureEnd) == 'string') ? pEnclosureEnd : ')';\n\n\t\tlet tmpEnclosureCount = 0;\n\t\tlet tmpEnclosureDepth = 0;\n\t\tfor (let i = 0; i < tmpString.length; i++)\n\t\t{\n\t\t\t// This is the start of an enclosure\n\t\t\tif (tmpString[i] == tmpEnclosureStart)\n\t\t\t{\n\t\t\t\tif (tmpEnclosureDepth == 0)\n\t\t\t\t{\n\t\t\t\t\ttmpEnclosureCount++;\n\t\t\t\t}\n\t\t\t\ttmpEnclosureDepth++;\n\t\t\t}\n\t\t\telse if (tmpString[i] == tmpEnclosureEnd)\n\t\t\t{\n\t\t\t\ttmpEnclosureDepth--;\n\t\t\t}\n\t\t}\n\n\t\treturn tmpEnclosureCount;\n\t},\n\n\n\t/**\n\t * Get the value of the enclosure at the specified index.\n\t *\n\t * If the index is not a number, it will default to 0.  If the string is not a string, it will return an empty string.  If the enclosure is not found, it will return an empty string.  If the enclosure\n\t *\n\t * @param {string} pString\n\t * @param {number} pEnclosureIndexToGet\n\t * @param {string} pEnclosureStart\n\t * @param {string}} pEnclosureEnd\n\t * @returns {string}\n\t */\n\tstringGetEnclosureValueByIndex: (pString, pEnclosureIndexToGet, pEnclosureStart, pEnclosureEnd) =>\n\t{\n\t\tlet tmpString = (typeof(pString) == 'string') ? pString : '';\n\t\tlet tmpEnclosureIndexToGet = (typeof(pEnclosureIndexToGet) == 'number') ? pEnclosureIndexToGet : 0;\n\t\tlet tmpEnclosureStart = (typeof(pEnclosureStart) == 'string') ? pEnclosureStart : '(';\n\t\tlet tmpEnclosureEnd = (typeof(pEnclosureEnd) == 'string') ? pEnclosureEnd : ')';\n\n\t\tlet tmpEnclosureCount = 0;\n\t\tlet tmpEnclosureDepth = 0;\n\n\t\tlet tmpMatchedEnclosureIndex = false;\n\t\tlet tmpEnclosedValueStartIndex = 0;\n\t\tlet tmpEnclosedValueEndIndex = 0;\n\n\t\tfor (let i = 0; i < tmpString.length; i++)\n\t\t{\n\t\t\t// This is the start of an enclosure\n\t\t\tif (tmpString[i] == tmpEnclosureStart)\n\t\t\t{\n\t\t\t\ttmpEnclosureDepth++;\n\n\t\t\t\t// Only count enclosures at depth 1, but still this parses both pairs of all of them.\n\t\t\t\tif (tmpEnclosureDepth == 1)\n\t\t\t\t{\n\t\t\t\t\ttmpEnclosureCount++;\n\t\t\t\t\tif (tmpEnclosureIndexToGet == (tmpEnclosureCount - 1))\n\t\t\t\t\t{\n\t\t\t\t\t\t// This is the start of *the* enclosure\n\t\t\t\t\t\ttmpMatchedEnclosureIndex = true;\n\t\t\t\t\t\ttmpEnclosedValueStartIndex = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// This is the end of an enclosure\n\t\t\telse if (tmpString[i] == tmpEnclosureEnd)\n\t\t\t{\n\t\t\t\ttmpEnclosureDepth--;\n\n\t\t\t\t// Again, only count enclosures at depth 1, but still this parses both pairs of all of them.\n\t\t\t\tif ((tmpEnclosureDepth == 0) &&\n\t\t\t\t\ttmpMatchedEnclosureIndex &&\n\t\t\t\t\t(tmpEnclosedValueEndIndex <= tmpEnclosedValueStartIndex))\n\t\t\t\t{\n\t\t\t\t\ttmpEnclosedValueEndIndex = i;\n\t\t\t\t\ttmpMatchedEnclosureIndex = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (tmpEnclosureCount <= tmpEnclosureIndexToGet)\n\t\t{\n\t\t\t// Return an empty string if the enclosure is not found\n\t\t\treturn '';\n\t\t}\n\n\t\tif ((tmpEnclosedValueEndIndex > 0) && (tmpEnclosedValueEndIndex > tmpEnclosedValueStartIndex))\n\t\t{\n\t\t\treturn tmpString.substring(tmpEnclosedValueStartIndex+1, tmpEnclosedValueEndIndex);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn tmpString.substring(tmpEnclosedValueStartIndex+1);\n\t\t}\n\t}\n}\n},{}],9:[function(require,module,exports){\n/**\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\nlet fCleanWrapCharacters = require('./Manyfest-CleanWrapCharacters.js');\n\n/**\n* Object Address Resolver - SetValue\n*\n* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to\n*                 be extremely clear what is going on in the recursion for\n*                 each of the three address resolution functions.\n*\n*                 Although there is some opportunity to repeat ourselves a\n*                 bit less in this codebase (e.g. with detection of arrays\n*                 versus objects versus direct properties), it can make\n*                 debugging.. challenging.  The minified version of the code\n*                 optimizes out almost anything repeated in here.  So please\n*                 be kind and rewind... meaning please keep the codebase less\n*                 terse and more verbose so humans can comprehend it.\n*\n*\n* @class ManyfestObjectAddressSetValue\n*/\nclass ManyfestObjectAddressSetValue\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) == 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) == 'function') ? pErrorLog : libSimpleLog;\n\n\t\tthis.cleanWrapCharacters = fCleanWrapCharacters;\n\t}\n\n\t// Set the value of an element at an address\n\tsetValueAtAddress (pObject, pAddress, pValue)\n\t{\n\t\t// Make sure pObject is an object\n\t\tif (typeof(pObject) != 'object') return false;\n\t\t// Make sure pAddress is a string\n\t\tif (typeof(pAddress) != 'string') return false;\n\n\t\tlet tmpSeparatorIndex = pAddress.indexOf('.');\n\n\t\tif (tmpSeparatorIndex == -1)\n\t\t{\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = pAddress.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = pAddress.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[10]\n\t\t\t// \t\tMyValues['Name']\n\t\t\t// \t\tMyValues[\"Age\"]\n\t\t\t// \t\tMyValues[`Cost`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\t// The \"Name\" of the Object contained too the left of the bracket\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\t// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.\n\t\t\t\t// This is a rare case where Arrays testing as Objects is useful\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// The \"Reference\" to the property within it, either an array element or object property\n\t\t\t\tlet tmpBoxedPropertyReference = pAddress.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\t\t\t\t// Attempt to parse the reference as a number, which will be used as an array element\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to treat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynamic object property.\n\t\t\t\t\t// We would expect the property to be wrapped in some kind of quotes so strip them\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Return the value in the property\n\t\t\t\t\tpObject[tmpBoxedPropertyName][tmpBoxedPropertyReference] = pValue;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber] = pValue;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Now is the time in recursion to set the value in the object\n\t\t\t\tpObject[pAddress] = pValue;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpSubObjectName = pAddress.substring(0, tmpSeparatorIndex);\n\t\t\tlet tmpNewAddress = pAddress.substring(tmpSeparatorIndex+1);\n\n\t\t\t// Test if the tmpNewAddress is an array or object\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = tmpSubObjectName.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = tmpSubObjectName.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[42]\n\t\t\t// \t\tMyValues['Color']\n\t\t\t// \t\tMyValues[\"Weight\"]\n\t\t\t// \t\tMyValues[`Diameter`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = tmpSubObjectName.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyReference = tmpSubObjectName.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[1].Tardy\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[\"JaneDoe\"].Grade\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an array, so the [\"JaneDoe\"].Grade is not possible to access\n\t\t\t\t// TODO: Should this be an error or something?  Should we keep a log of failures like this?\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//This is a bracketed value\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to reat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynanmic object property.\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Recurse directly into the subobject\n\t\t\t\t\treturn this.setValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference], tmpNewAddress, pValue);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// We parsed a valid number out of the boxed property name, so recurse into the array\n\t\t\t\t\treturn this.setValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber], tmpNewAddress, pValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there is an object property already named for the sub object, but it isn't an object\n\t\t\t// then the system can't set the value in there.  Error and abort!\n\t\t\tif ((tmpSubObjectName in pObject) && typeof(pObject[tmpSubObjectName]) !== 'object')\n\t\t\t{\n\t\t\t\tif (!('__ERROR' in pObject))\n\t\t\t\t\tpObject['__ERROR'] = {};\n\t\t\t\t// Put it in an error object so data isn't lost\n\t\t\t\tpObject['__ERROR'][pAddress] = pValue;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (tmpSubObjectName in pObject)\n\t\t\t{\n\t\t\t\t// If there is already a subobject pass that to the recursive thingy\n\t\t\t\treturn this.setValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, pValue);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Create a subobject and then pass that\n\t\t\t\tpObject[tmpSubObjectName] = {};\n\t\t\t\treturn this.setValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, pValue);\n\t\t\t}\n\t\t}\n\t}\n};\n\nmodule.exports = ManyfestObjectAddressSetValue;\n},{\"./Manyfest-CleanWrapCharacters.js\":2,\"./Manyfest-LogToConsole.js\":4}],10:[function(require,module,exports){\n/**\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\n/**\n* Object Address Generation\n*\n* Automagically generate addresses and properties based on a passed-in object,\n* to be used for easy creation of schemas.  Meant to simplify the lives of\n* developers wanting to create schemas without typing a bunch of stuff.\n*\n* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to\n*                 be extremely clear what is going on in the recursion for\n*                 each of the three address resolution functions.\n*\n*                 Although there is some opportunity to repeat ourselves a\n*                 bit less in this codebase (e.g. with detection of arrays\n*                 versus objects versus direct properties), it can make\n*                 debugging.. challenging.  The minified version of the code\n*                 optimizes out almost anything repeated in here.  So please\n*                 be kind and rewind... meaning please keep the codebase less\n*                 terse and more verbose so humans can comprehend it.\n*\n*\n* @class ManyfestObjectAddressGeneration\n*/\nclass ManyfestObjectAddressGeneration\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) == 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) == 'function') ? pErrorLog : libSimpleLog;\n\t}\n\n\t// generateAddressses\n\t//\n\t// This flattens an object into a set of key:value pairs for *EVERY SINGLE\n\t// POSSIBLE ADDRESS* in the object.  It can get ... really insane really\n\t// quickly.  This is not meant to be used directly to generate schemas, but\n\t// instead as a starting point for scripts or UIs.\n\t//\n\t// This will return a mega set of key:value pairs with all possible schema\n\t// permutations and default values (when not an object) and everything else.\n\tgenerateAddressses (pObject, pBaseAddress, pSchema)\n\t{\n\t\tlet tmpBaseAddress = (typeof(pBaseAddress) == 'string') ? pBaseAddress : '';\n\t\tlet tmpSchema = (typeof(pSchema) == 'object') ? pSchema : {};\n\n\t\tlet tmpObjectType = typeof(pObject);\n\n\t\tlet tmpSchemaObjectEntry = (\n\t\t\t{\n\t\t\t\tAddress: tmpBaseAddress,\n\t\t\t\tHash: tmpBaseAddress,\n\t\t\t\tName: tmpBaseAddress,\n\t\t\t\t// This is so scripts and UI controls can force a developer to opt-in.\n\t\t\t\tInSchema: false\n\t\t\t}\n\t\t)\n\n\t\tif ((tmpObjectType == 'object') && (pObject == null))\n\t\t{\n\t\t\ttmpObjectType = 'null';\n\t\t}\n\n\t\tswitch(tmpObjectType)\n\t\t{\n\t\t\tcase 'string':\n\t\t\t\ttmpSchemaObjectEntry.DataType = 'String';\n\t\t\t\ttmpSchemaObjectEntry.Default = pObject;\n\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\tbreak;\n\t\t\tcase 'number':\n\t\t\tcase 'bigint':\n\t\t\t\ttmpSchemaObjectEntry.DataType = 'Number';\n\t\t\t\ttmpSchemaObjectEntry.Default = pObject;\n\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\tbreak;\n\t\t\tcase 'undefined':\n\t\t\tcase 'null':\n\t\t\t\ttmpSchemaObjectEntry.DataType = 'Any';\n\t\t\t\ttmpSchemaObjectEntry.Default = pObject;\n\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\tbreak;\n\t\t\tcase 'object':\n\t\t\t\tif (Array.isArray(pObject))\n\t\t\t\t{\n\t\t\t\t\ttmpSchemaObjectEntry.DataType = 'Array';\n\t\t\t\t\tif (tmpBaseAddress != '')\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (let i = 0; i < pObject.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.generateAddressses(pObject[i], `${tmpBaseAddress}[${i}]`, tmpSchema);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttmpSchemaObjectEntry.DataType = 'Object';\n\t\t\t\t\tif (tmpBaseAddress != '')\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\t\t\ttmpBaseAddress += '.';\n\t\t\t\t\t}\n\n\t\t\t\t\tlet tmpObjectProperties = Object.keys(pObject);\n\n\t\t\t\t\tfor (let i = 0; i < tmpObjectProperties.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.generateAddressses(pObject[tmpObjectProperties[i]], `${tmpBaseAddress}${tmpObjectProperties[i]}`, tmpSchema);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'symbol':\n\t\t\tcase 'function':\n\t\t\t\t// Symbols and functions neither recurse nor get added to the schema\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn tmpSchema;\n\t}\n};\n\nmodule.exports = ManyfestObjectAddressGeneration;\n},{\"./Manyfest-LogToConsole.js\":4}],11:[function(require,module,exports){\n// Given a string, parse out any conditional expressions and set whether or not to keep the record.\n//\n// For instance:\n// \t\t'files[]<<~?format,==,Thumbnail?~>>'\n//      'files[]<<~?format,==,Metadata?~>>'\n//      'files[]<<~?size,>,4000?~>>'\n//\n// The wrapping parts are the <<~? and ?~>> megabrackets.\n//\n// The function does not need to alter the string -- just check the conditionals within.\n\n// TODO: Consider making this an es6 class\n\n// Let's use indexOf since it is apparently the fastest.\nconst _ConditionalStanzaStart = '<<~?';\nconst _ConditionalStanzaStartLength = _ConditionalStanzaStart.length;\nconst _ConditionalStanzaEnd = '?~>>';\nconst _ConditionalStanzaEndLength = _ConditionalStanzaEnd.length;\n\n// Ugh dependency injection.  Can't wait to make these all fable services.\n//let libObjectAddressCheckAddressExists = new (require('./Manyfest-ObjectAddress-CheckAddressExists.js'))();\n\n// Test the condition of a value in a record\nconst testCondition = (pManyfest, pRecord, pSearchAddress, pSearchComparator, pValue) =>\n{\n\tswitch(pSearchComparator)\n\t{\n\t\tcase 'TRUE':\n\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress) === true);\n\t\t\tbreak;\n\t\tcase 'FALSE':\n\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress) === false);\n\t\t\tbreak;\n\t\tcase 'LNGT':\n\t\tcase 'LENGTH_GREATER_THAN':\n\t\t\tswitch(typeof(pManyfest.getValueAtAddress(pRecord, pSearchAddress)))\n\t\t\t{\n\t\t\t\tcase 'string':\n\t\t\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress).length > pValue);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'object':\n\t\t\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress).length > pValue);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'LNLT':\n\t\tcase 'LENGTH_LESS_THAN':\n\t\t\tswitch(typeof(pManyfest.getValueAtAddress(pRecord, pSearchAddress)))\n\t\t\t{\n\t\t\t\tcase 'string':\n\t\t\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress).length < pValue);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'object':\n\t\t\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress).length < pValue);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t// TODO: Welcome to dependency hell.  This fixes itself when we move to fable services.\n\t\t// case 'EX':\n\t\t// case 'EXISTS':\n\t\t// \treturn libObjectAddressCheckAddressExists.checkAddressExists(pRecord, pSearchAddress);\n\t\t// \tbreak;\n\t\t// case 'DNEX':\n\t\t// case 'DOES_NOT_EXIST':\n\t\t// \treturn !libObjectAddressCheckAddressExists.checkAddressExists(pRecord, pSearchAddress);\n\t\t// \tbreak;\n\t\tcase '!=':\n\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress) != pValue);\n\t\t\tbreak;\n\t\tcase '<':\n\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress) < pValue);\n\t\t\tbreak;\n\t\tcase '>':\n\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress) > pValue);\n\t\t\tbreak;\n\t\tcase '<=':\n\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress) <= pValue);\n\t\t\tbreak;\n\t\tcase '>=':\n\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress) >= pValue);\n\t\t\tbreak;\n\t\tcase '===':\n\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress) === pValue);\n\t\t\tbreak;\n\t\tcase '==':\n\t\tdefault:\n\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress) == pValue);\n\t\t\tbreak;\n\t}\n};\n\nconst parseConditionals = (pManyfest, pAddress, pRecord) =>\n{\n\tlet tmpKeepRecord = true;\n\n\t/*\n\t\tAlgorithm is simple:\n\n\t\t1.  Enuerate start points\n\t\t2.  Find stop points within each start point\n\t\t3. Check the conditional\n\t*/\n\tlet tmpStartIndex = pAddress.indexOf(_ConditionalStanzaStart);\n\n\twhile (tmpStartIndex != -1)\n\t{\n\t\tlet tmpStopIndex = pAddress.indexOf(_ConditionalStanzaEnd, tmpStartIndex+_ConditionalStanzaStartLength);\n\n\t\tif (tmpStopIndex != -1)\n\t\t{\n\t\t\tlet tmpMagicComparisonPatternSet = pAddress.substring(tmpStartIndex+_ConditionalStanzaStartLength, tmpStopIndex).split(',');\n\n\t\t\t// The address to search for\n\t\t\tlet tmpSearchAddress = tmpMagicComparisonPatternSet[0];\n\n\t\t\t// The copmparison expression (EXISTS as default)\n\t\t\tlet tmpSearchComparator = 'EXISTS';\n\t\t\tif (tmpMagicComparisonPatternSet.length > 1)\n\t\t\t{\n\t\t\t\ttmpSearchComparator = tmpMagicComparisonPatternSet[1];\t\t\t\t\n\t\t\t}\n\n\t\t\t// The value to search for\n\t\t\tlet tmpSearchValue = false;\n\t\t\tif (tmpMagicComparisonPatternSet.length > 2)\n\t\t\t{\n\t\t\t\ttmpSearchValue = tmpMagicComparisonPatternSet[2];\n\t\t\t}\n\n\t\t\t// Process the piece\n\t\t\ttmpKeepRecord = tmpKeepRecord && testCondition(pManyfest, pRecord, tmpSearchAddress, tmpSearchComparator, tmpSearchValue);\n\t\t\ttmpStartIndex = pAddress.indexOf(_ConditionalStanzaStart, tmpStopIndex+_ConditionalStanzaEndLength);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmpStartIndex = -1;\n\t\t}\n\t\t\n\t}\n\n\treturn tmpKeepRecord;\n}\n\nmodule.exports = parseConditionals;\n},{}],12:[function(require,module,exports){\n/**\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\n/**\n* Schema Manipulation Functions\n*\n* @class ManyfestSchemaManipulation\n*/\nclass ManyfestSchemaManipulation\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) === 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) === 'function') ? pErrorLog : libSimpleLog;\n\t}\n\n    // This translates the default address mappings to something different.\n    //\n    // For instance you can pass in manyfest schema descriptor object:\n    // \t{\n\t//\t  \"Address.Of.a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t//\t  \"Address.Of.b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t//  }\n    //\n    //\n    // And then an address mapping (basically a Hash->Address map)\n    //  {\n    //    \"a\": \"New.Address.Of.a\",\n    //    \"b\": \"New.Address.Of.b\"\n    //  }\n    //\n    // NOTE: This mutates the schema object permanently, altering the base hash.\n    //       If there is a collision with an existing address, it can lead to overwrites.\n    // TODO: Discuss what should happen on collisions.\n\tresolveAddressMappings(pManyfestSchemaDescriptors, pAddressMapping)\n\t{\n\t\tif (typeof(pManyfestSchemaDescriptors) != 'object')\n\t\t{\n\t\t\tthis.logError(`Attempted to resolve address mapping but the descriptor was not an object.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (typeof(pAddressMapping) != 'object')\n\t\t{\n\t\t\t// No mappings were passed in\n\t\t\treturn true;\n\t\t}\n\n\t\t// Get the arrays of both the schema definition and the hash mapping\n\t\tlet tmpManyfestAddresses = Object.keys(pManyfestSchemaDescriptors);\n\t\tlet tmpHashMapping = {};\n\t\ttmpManyfestAddresses.forEach(\n\t\t\t(pAddress) =>\n\t\t\t{\n\t\t\t\tif ('Hash' in pManyfestSchemaDescriptors[pAddress])\n\t\t\t\t{\n\t\t\t\t\ttmpHashMapping[pManyfestSchemaDescriptors[pAddress].Hash] = pAddress;\n\t\t\t\t}\n\t\t\t});\n\n\t\tlet tmpAddressMappingSet = Object.keys(pAddressMapping);\n\n\t\ttmpAddressMappingSet.forEach(\n\t\t\t(pInputAddress) =>\n\t\t\t{\n\t\t\t\tlet tmpNewDescriptorAddress = pAddressMapping[pInputAddress];\n\t\t\t\tlet tmpOldDescriptorAddress = false;\n\t\t\t\tlet tmpDescriptor = false;\n\n\t\t\t\t// See if there is a matching descriptor either by Address directly or Hash\n\t\t\t\tif (pInputAddress in pManyfestSchemaDescriptors)\n\t\t\t\t{\n\t\t\t\t\ttmpOldDescriptorAddress = pInputAddress;\n\t\t\t\t}\n\t\t\t\telse if (pInputAddress in tmpHashMapping)\n\t\t\t\t{\n\t\t\t\t\ttmpOldDescriptorAddress = tmpHashMapping[pInputAddress];\n\t\t\t\t}\n\n\t\t\t\t// If there was a matching descriptor in the manifest, store it in the temporary descriptor\n\t\t\t\tif (tmpOldDescriptorAddress)\n\t\t\t\t{\n\t\t\t\t\ttmpDescriptor = pManyfestSchemaDescriptors[tmpOldDescriptorAddress];\n\t\t\t\t\tdelete pManyfestSchemaDescriptors[tmpOldDescriptorAddress];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Create a new descriptor!  Map it to the input address.\n\t\t\t\t\ttmpDescriptor = { Hash:pInputAddress };\n\t\t\t\t}\n\n\t\t\t\t// Now re-add the descriptor to the manyfest schema\n\t\t\t\tpManyfestSchemaDescriptors[tmpNewDescriptorAddress] = tmpDescriptor;\n\t\t\t});\n\n\t\treturn true;\n\t}\n\n\tsafeResolveAddressMappings(pManyfestSchemaDescriptors, pAddressMapping)\n\t{\n\t\t// This returns the descriptors as a new object, safely remapping without mutating the original schema Descriptors\n\t\tlet tmpManyfestSchemaDescriptors = JSON.parse(JSON.stringify(pManyfestSchemaDescriptors));\n\t\tthis.resolveAddressMappings(tmpManyfestSchemaDescriptors, pAddressMapping);\n\t\treturn tmpManyfestSchemaDescriptors;\n\t}\n\n\tmergeAddressMappings(pManyfestSchemaDescriptorsDestination, pManyfestSchemaDescriptorsSource)\n\t{\n\t\tif ((typeof(pManyfestSchemaDescriptorsSource) != 'object') || (typeof(pManyfestSchemaDescriptorsDestination) != 'object'))\n\t\t{\n\t\t\tthis.logError(`Attempted to merge two schema descriptors but both were not objects.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpSource = JSON.parse(JSON.stringify(pManyfestSchemaDescriptorsSource));\n\t\tlet tmpNewManyfestSchemaDescriptors = JSON.parse(JSON.stringify(pManyfestSchemaDescriptorsDestination));\n\n\t\t// The first passed-in set of descriptors takes precedence.\n\t\tlet tmpDescriptorAddresses = Object.keys(tmpSource);\n\n\t\ttmpDescriptorAddresses.forEach(\n\t\t\t(pDescriptorAddress) =>\n\t\t\t{\n\t\t\t\tif (!(pDescriptorAddress in tmpNewManyfestSchemaDescriptors))\n\t\t\t\t{\n\t\t\t\t\ttmpNewManyfestSchemaDescriptors[pDescriptorAddress] = tmpSource[pDescriptorAddress];\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn tmpNewManyfestSchemaDescriptors;\n\t}\n}\n\nmodule.exports = ManyfestSchemaManipulation;\n},{\"./Manyfest-LogToConsole.js\":4}],13:[function(require,module,exports){\n/**\n* @author <steven@velozo.com>\n*/\nconst libFableServiceProviderBase = require('fable-serviceproviderbase');\n\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\nlet libHashTranslation = require('./Manyfest-HashTranslation.js');\nlet libObjectAddressCheckAddressExists = require('./Manyfest-ObjectAddress-CheckAddressExists.js');\nlet libObjectAddressGetValue = require('./Manyfest-ObjectAddress-GetValue.js');\nlet libObjectAddressSetValue = require('./Manyfest-ObjectAddress-SetValue.js');\nlet libObjectAddressDeleteValue = require('./Manyfest-ObjectAddress-DeleteValue.js');\nlet libObjectAddressGeneration = require('./Manyfest-ObjectAddressGeneration.js');\nlet libSchemaManipulation = require('./Manyfest-SchemaManipulation.js');\n\nconst _DefaultConfiguration = { Scope:'DEFAULT', Descriptors: {} }\n\n/**\n* Manyfest object address-based descriptions and manipulations.\n*\n* @class Manyfest\n*/\nclass Manyfest extends libFableServiceProviderBase\n{\n\tconstructor(pFable, pManifest, pServiceHash)\n\t{\n\t\tif (pFable === undefined)\n\t\t{\n\t\t\tsuper({});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsuper(pFable, pManifest, pServiceHash);\n\t\t}\n\n        this.serviceType = 'Manifest';\n\n\t\t// Wire in logging\n\t\tthis.logInfo = libSimpleLog;\n\t\tthis.logError = libSimpleLog;\n\n\t\t// Create an object address resolver and map in the functions\n\t\tthis.objectAddressCheckAddressExists = new libObjectAddressCheckAddressExists(this.logInfo, this.logError);\n\t\tthis.objectAddressGetValue = new libObjectAddressGetValue(this.logInfo, this.logError);\n\t\tthis.objectAddressSetValue = new libObjectAddressSetValue(this.logInfo, this.logError);\n\t\tthis.objectAddressDeleteValue = new libObjectAddressDeleteValue(this.logInfo, this.logError);\n\n\t\tif (!('defaultValues' in this.options))\n\t\t{\n\t\t\tthis.options.defaultValues = (\n\t\t\t\t{\n\t\t\t\t\t\"String\": \"\",\n\t\t\t\t\t\"Number\": 0,\n\t\t\t\t\t\"Float\": 0.0,\n\t\t\t\t\t\"Integer\": 0,\n\t\t\t\t\t\"PreciseNumber\": \"0.0\",\n\t\t\t\t\t\"Boolean\": false,\n\t\t\t\t\t\"Binary\": 0,\n\t\t\t\t\t\"DateTime\": 0,\n\t\t\t\t\t\"Array\": [],\n\t\t\t\t\t\"Object\": {},\n\t\t\t\t\t\"Null\": null\n\t\t\t\t});\n\t\t}\n\t\tif (!('strict' in this.options))\n\t\t{\n\t\t\tthis.options.strict = false;\n\t\t}\n\n\t\tthis.scope = undefined;\n\t\tthis.elementAddresses = undefined;\n\t\tthis.elementHashes = undefined;\n\t\tthis.elementDescriptors = undefined;\n\n\t\tthis.reset();\n\n\t\tif (typeof(this.options) === 'object')\n\t\t{\n\t\t\tthis.loadManifest(this.options);\n\t\t}\n\n\t\tthis.schemaManipulations = new libSchemaManipulation(this.logInfo, this.logError);\n\t\tthis.objectAddressGeneration = new libObjectAddressGeneration(this.logInfo, this.logError);\n\n\t\tthis.hashTranslations = new libHashTranslation(this.logInfo, this.logError);\n\n\t\tthis.numberRegex = /^[+-]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][+-]?\\d+)?$/;\n\t}\n\n\t/*************************************************************************\n\t * Schema Manifest Loading, Reading, Manipulation and Serialization Functions\n\t */\n\n\t// Reset critical manifest properties\n\treset()\n\t{\n\t\tthis.scope = 'DEFAULT';\n\t\tthis.elementAddresses = [];\n\t\tthis.elementHashes = {};\n\t\tthis.elementDescriptors = {};\n\t}\n\n\tclone()\n\t{\n\t\t// Make a copy of the options in-place\n\t\tlet tmpNewOptions = JSON.parse(JSON.stringify(this.options));\n\n\t\tlet tmpNewManyfest = new Manyfest(this.getManifest(), this.logInfo, this.logError, tmpNewOptions);\n\n\t\t// Import the hash translations\n\t\ttmpNewManyfest.hashTranslations.addTranslation(this.hashTranslations.translationTable);\n\n\t\treturn tmpNewManyfest;\n\t}\n\n\t// Deserialize a Manifest from a string\n\tdeserialize(pManifestString)\n\t{\n\t\t// TODO: Add guards for bad manifest string\n\t\treturn this.loadManifest(JSON.parse(pManifestString));\n\t}\n\n\t// Load a manifest from an object\n\tloadManifest(pManifest)\n\t{\n\t\tif (typeof(pManifest) !== 'object')\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading manifest; expecting an object but parameter was type ${typeof(pManifest)}.`);\n\t\t}\n\n\t\tlet tmpManifest = (typeof(pManifest) == 'object') ? pManifest : {};\n\n\t\tlet tmpDescriptorKeys = Object.keys(_DefaultConfiguration);\n\n\t\tfor (let i = 0; i < tmpDescriptorKeys.length; i++)\n\t\t{\n\t\t\tif (!(tmpDescriptorKeys[i] in tmpManifest))\n\t\t\t{\n\t\t\t\ttmpManifest[tmpDescriptorKeys[i]] = JSON.parse(JSON.stringify(_DefaultConfiguration[tmpDescriptorKeys[i]]));\n\t\t\t}\n\t\t}\n\n\t\tif ('Scope' in tmpManifest)\n\t\t{\n\t\t\tif (typeof(tmpManifest.Scope) === 'string')\n\t\t\t{\n\t\t\t\tthis.scope = tmpManifest.Scope;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.logError(`(${this.scope}) Error loading scope from manifest; expecting a string but property was type ${typeof(tmpManifest.Scope)}.`, tmpManifest);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading scope from manifest object.  Property \"Scope\" does not exist in the root of the object.`, tmpManifest);\n\t\t}\n\n\t\tif ('Descriptors' in tmpManifest)\n\t\t{\n\t\t\tif (typeof(tmpManifest.Descriptors) === 'object')\n\t\t\t{\n\t\t\t\tlet tmpDescriptionAddresses = Object.keys(tmpManifest.Descriptors);\n\t\t\t\tfor (let i = 0; i < tmpDescriptionAddresses.length; i++)\n\t\t\t\t{\n\t\t\t\t\tthis.addDescriptor(tmpDescriptionAddresses[i], tmpManifest.Descriptors[tmpDescriptionAddresses[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.logError(`(${this.scope}) Error loading description object from manifest object.  Expecting an object in 'Manifest.Descriptors' but the property was type ${typeof(tmpManifest.Descriptors)}.`, tmpManifest);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading object description from manifest object.  Property \"Descriptors\" does not exist in the root of the Manifest object.`, tmpManifest);\n\t\t}\n\n\t\tif ('HashTranslations' in tmpManifest)\n\t\t{\n\t\t\tif (typeof(tmpManifest.HashTranslations) === 'object')\n\t\t\t{\n\t\t\t\tfor (let i = 0; i < tmpManifest.HashTranslations.length; i++)\n\t\t\t\t{\n\t\t\t\t\t// Each translation is \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Serialize the Manifest to a string\n\tserialize()\n\t{\n\t\treturn JSON.stringify(this.getManifest());\n\t}\n\n\tgetManifest()\n\t{\n\t\treturn (\n\t\t\t{\n\t\t\t\tScope: this.scope,\n\t\t\t\tDescriptors: JSON.parse(JSON.stringify(this.elementDescriptors)),\n\t\t\t\tHashTranslations: JSON.parse(JSON.stringify(this.hashTranslations.translationTable))\n\t\t\t});\n\t}\n\n\t// Add a descriptor to the manifest\n\taddDescriptor(pAddress, pDescriptor)\n\t{\n\t\tif (typeof(pDescriptor) === 'object')\n\t\t{\n\t\t\t// Add the Address into the Descriptor if it doesn't exist:\n\t\t\tif (!('Address' in pDescriptor))\n\t\t\t{\n\t\t\t\tpDescriptor.Address = pAddress;\n\t\t\t}\n\n\t\t\tif (!(pAddress in this.elementDescriptors))\n\t\t\t{\n\t\t\t\tthis.elementAddresses.push(pAddress);\n\t\t\t}\n\n\t\t\t// Add the element descriptor to the schema\n\t\t\tthis.elementDescriptors[pAddress] = pDescriptor;\n\n\t\t\t// Always add the address as a hash\n\t\t\tthis.elementHashes[pAddress] = pAddress;\n\n\t\t\tif ('Hash' in pDescriptor)\n\t\t\t{\n\t\t\t\t// TODO: Check if this is a good idea or not..\n\t\t\t\t//       Collisions are bound to happen with both representations of the address/hash in here and developers being able to create their own hashes.\n\t\t\t\tthis.elementHashes[pDescriptor.Hash] = pAddress;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpDescriptor.Hash = pAddress;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading object descriptor for address '${pAddress}' from manifest object.  Expecting an object but property was type ${typeof(pDescriptor)}.`);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tgetDescriptorByHash(pHash)\n\t{\n\t\treturn this.getDescriptor(this.resolveHashAddress(pHash));\n\t}\n\n\tgetDescriptor(pAddress)\n\t{\n\t\treturn this.elementDescriptors[pAddress];\n\t}\n\n\t// execute an action function for each descriptor\n\teachDescriptor(fAction)\n\t{\n        let tmpDescriptorAddresses = Object.keys(this.elementDescriptors);\n        for (let i = 0; i < tmpDescriptorAddresses.length; i++)\n        {\n            fAction(this.elementDescriptors[tmpDescriptorAddresses[i]]);\n        }\n\n\t}\n\n\t/*************************************************************************\n\t * Beginning of Object Manipulation (read & write) Functions\n\t */\n\t// Check if an element exists by its hash\n\tcheckAddressExistsByHash (pObject, pHash)\n\t{\n\t\treturn this.checkAddressExists(pObject,this.resolveHashAddress(pHash));\n\t}\n\n\t// Check if an element exists at an address\n\tcheckAddressExists (pObject, pAddress)\n\t{\n\t\treturn this.objectAddressCheckAddressExists.checkAddressExists(pObject, pAddress);\n\t}\n\n\t// Turn a hash into an address, factoring in the translation table.\n\tresolveHashAddress(pHash)\n\t{\n\t\tlet tmpAddress = undefined;\n\n\t\tlet tmpInElementHashTable = (pHash in this.elementHashes);\n\t\tlet tmpInTranslationTable = (pHash in this.hashTranslations.translationTable);\n\n\t\t// The most straightforward: the hash exists, no translations.\n\t\tif (tmpInElementHashTable && !tmpInTranslationTable)\n\t\t{\n\t\t\ttmpAddress = this.elementHashes[pHash];\n\t\t}\n\t\t// There is a translation from one hash to another, and, the elementHashes contains the pointer end\n\t\telse if (tmpInTranslationTable && (this.hashTranslations.translate(pHash) in this.elementHashes))\n\t\t{\n\t\t\ttmpAddress = this.elementHashes[this.hashTranslations.translate(pHash)];\n\t\t}\n\t\t// Use the level of indirection only in the Translation Table\n\t\telse if (tmpInTranslationTable)\n\t\t{\n\t\t\ttmpAddress = this.hashTranslations.translate(pHash);\n\t\t}\n\t\t// Just treat the hash as an address.\n\t\t// TODO: Discuss this ... it is magic but controversial\n\t\telse\n\t\t{\n\t\t\ttmpAddress = pHash;\n\t\t}\n\n\t\treturn tmpAddress;\n\t}\n\n\t// Get the value of an element by its hash\n\tgetValueByHash (pObject, pHash)\n\t{\n\t\tlet tmpValue = this.getValueAtAddress(pObject, this.resolveHashAddress(pHash));\n\n\t\tif (typeof(tmpValue) == 'undefined')\n\t\t{\n\t\t\t// Try to get a default if it exists\n\t\t\ttmpValue = this.getDefaultValue(this.getDescriptorByHash(pHash));\n\t\t}\n\n\t\treturn tmpValue;\n\t}\n\n\t// Get the value of an element at an address\n\tgetValueAtAddress (pObject, pAddress)\n\t{\n\t\tlet tmpLintedAddress = pAddress.trim();\n\t\tif (tmpLintedAddress == '')\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error getting value at address; address is an empty string.`, pObject);\n\t\t\treturn undefined;\n\t\t}\n\t\tlet tmpValue = this.objectAddressGetValue.getValueAtAddress(pObject, pAddress);\n\n\t\tif (typeof(tmpValue) == 'undefined')\n\t\t{\n\t\t\t// Try to get a default if it exists\n\t\t\ttmpValue = this.getDefaultValue(this.getDescriptor(pAddress));\n\t\t}\n\n\t\treturn tmpValue;\n\t}\n\n\t// Set the value of an element by its hash\n\tsetValueByHash(pObject, pHash, pValue)\n\t{\n\t\treturn this.setValueAtAddress(pObject, this.resolveHashAddress(pHash), pValue);\n\t}\n\n\t// Set the value of an element at an address\n\tsetValueAtAddress (pObject, pAddress, pValue)\n\t{\n\t\treturn this.objectAddressSetValue.setValueAtAddress(pObject, pAddress, pValue);\n\t}\n\n\t// Delete the value of an element by its hash\n\tdeleteValueByHash(pObject, pHash, pValue)\n\t{\n\t\treturn this.deleteValueAtAddress(pObject, this.resolveHashAddress(pHash), pValue);\n\t}\n\n\t// Delete the value of an element at an address\n\tdeleteValueAtAddress (pObject, pAddress, pValue)\n\t{\n\t\treturn this.objectAddressDeleteValue.deleteValueAtAddress(pObject, pAddress, pValue);\n\t}\n\n\t// Validate the consistency of an object against the schema\n\tvalidate(pObject)\n\t{\n\t\tlet tmpValidationData =\n\t\t{\n\t\t\tError: null,\n\t\t\tErrors: [],\n\t\t\tMissingElements:[]\n\t\t};\n\n\t\tif (typeof(pObject) !== 'object')\n\t\t{\n\t\t\ttmpValidationData.Error = true;\n\t\t\ttmpValidationData.Errors.push(`Expected passed in object to be type object but was passed in ${typeof(pObject)}`);\n\t\t}\n\n\t\tlet addValidationError = (pAddress, pErrorMessage) =>\n\t\t{\n\t\t\ttmpValidationData.Error = true;\n\t\t\ttmpValidationData.Errors.push(`Element at address \"${pAddress}\" ${pErrorMessage}.`);\n\t\t};\n\n\t\t// Now enumerate through the values and check for anomalies based on the schema\n\t\tfor (let i = 0; i < this.elementAddresses.length; i++)\n\t\t{\n\t\t\tlet tmpDescriptor = this.getDescriptor(this.elementAddresses[i]);\n\t\t\tlet tmpValueExists = this.checkAddressExists(pObject, tmpDescriptor.Address);\n\t\t\tlet tmpValue = this.getValueAtAddress(pObject, tmpDescriptor.Address);\n\n\t\t\tif ((typeof(tmpValue) == 'undefined') || !tmpValueExists)\n\t\t\t{\n\t\t\t\t// This will technically mean that `Object.Some.Value = undefined` will end up showing as \"missing\"\n\t\t\t\t// TODO: Do we want to do a different message based on if the property exists but is undefined?\n\t\t\t\ttmpValidationData.MissingElements.push(tmpDescriptor.Address);\n\t\t\t\tif (tmpDescriptor.Required || this.options.strict)\n\t\t\t\t{\n\t\t\t\t\taddValidationError(tmpDescriptor.Address, 'is flagged REQUIRED but is not set in the object');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Now see if there is a data type specified for this element\n\t\t\tif (tmpDescriptor.DataType)\n\t\t\t{\n\t\t\t\tlet tmpElementType = typeof(tmpValue);\n\t\t\t\tswitch(tmpDescriptor.DataType.toString().trim().toLowerCase())\n\t\t\t\t{\n\t\t\t\t\tcase 'string':\n\t\t\t\t\t\tif (tmpElementType != 'string')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \"precisenumber\":\n\t\t\t\t\t\tif (tmpElementType != 'string')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!this.numberRegex.test(tmpValue))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is not a valid number`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'number':\n\t\t\t\t\t\tif (tmpElementType != 'number')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'integer':\n\t\t\t\t\t\tif (tmpElementType != 'number')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlet tmpValueString = tmpValue.toString();\n\t\t\t\t\t\t\tif (tmpValueString.indexOf('.') > -1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// TODO: Is this an error?\n\t\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but has a decimal point in the number.`);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'float':\n\t\t\t\t\t\tif (tmpElementType != 'number')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'datetime':\n\t\t\t\t\t\tlet tmpValueDate = new Date(tmpValue);\n\t\t\t\t\t\tif (tmpValueDate.toString() == 'Invalid Date')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is not parsable as a Date by Javascript`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// Check if this is a string, in the default case\n\t\t\t\t\t\t// Note this is only when a DataType is specified and it is an unrecognized data type.\n\t\t\t\t\t\tif (tmpElementType != 'string')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} (which auto-converted to String because it was unrecognized) but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn tmpValidationData;\n\t}\n\n\t// Returns a default value, or, the default value for the data type (which is overridable with configuration)\n\tgetDefaultValue(pDescriptor)\n\t{\n\t\tif (typeof(pDescriptor) != 'object')\n\t\t{\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif ('Default' in pDescriptor)\n\t\t{\n\t\t\treturn pDescriptor.Default;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Default to a null if it doesn't have a type specified.\n\t\t\t// This will ensure a placeholder is created but isn't misinterpreted.\n\t\t\tlet tmpDataType = ('DataType' in pDescriptor) ? pDescriptor.DataType : 'String';\n\t\t\tif (tmpDataType in this.options.defaultValues)\n\t\t\t{\n\t\t\t\treturn this.options.defaultValues[tmpDataType];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// give up and return null\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Enumerate through the schema and populate default values if they don't exist.\n\tpopulateDefaults(pObject, pOverwriteProperties)\n\t{\n\t\treturn this.populateObject(pObject, pOverwriteProperties,\n\t\t\t// This just sets up a simple filter to see if there is a default set.\n\t\t\t(pDescriptor) =>\n\t\t\t{\n\t\t\t\treturn ('Default' in pDescriptor);\n\t\t\t});\n\t}\n\n\t// Forcefully populate all values even if they don't have defaults.\n\t// Based on type, this can do unexpected things.\n\tpopulateObject(pObject, pOverwriteProperties, fFilter)\n\t{\n\t\t// Automatically create an object if one isn't passed in.\n\t\tlet tmpObject = (typeof(pObject) === 'object') ? pObject : {};\n\t\t// Default to *NOT OVERWRITING* properties\n\t\tlet tmpOverwriteProperties = (typeof(pOverwriteProperties) == 'undefined') ? false : pOverwriteProperties;\n\t\t// This is a filter function, which is passed the schema and allows complex filtering of population\n\t\t// The default filter function just returns true, populating everything.\n\t\tlet tmpFilterFunction = (typeof(fFilter) == 'function') ? fFilter : (pDescriptor) => { return true; };\n\n\t\tthis.elementAddresses.forEach(\n\t\t\t(pAddress) =>\n\t\t\t{\n\t\t\t\tlet tmpDescriptor = this.getDescriptor(pAddress);\n\t\t\t\t// Check the filter function to see if this is an address we want to set the value for.\n\t\t\t\tif (tmpFilterFunction(tmpDescriptor))\n\t\t\t\t{\n\t\t\t\t\t// If we are overwriting properties OR the property does not exist\n\t\t\t\t\tif (tmpOverwriteProperties || !this.checkAddressExists(tmpObject, pAddress))\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.setValueAtAddress(tmpObject, pAddress, this.getDefaultValue(tmpDescriptor));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn tmpObject;\n\t}\n};\n\nmodule.exports = Manyfest;\n},{\"./Manyfest-HashTranslation.js\":3,\"./Manyfest-LogToConsole.js\":4,\"./Manyfest-ObjectAddress-CheckAddressExists.js\":5,\"./Manyfest-ObjectAddress-DeleteValue.js\":6,\"./Manyfest-ObjectAddress-GetValue.js\":7,\"./Manyfest-ObjectAddress-SetValue.js\":9,\"./Manyfest-ObjectAddressGeneration.js\":10,\"./Manyfest-SchemaManipulation.js\":12,\"fable-serviceproviderbase\":1}]},{},[13])(13)\n});\n\n","(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","/**\n* Fable Service Base\n* @author <steven@velozo.com>\n*/\n\nclass FableServiceProviderBase\n{\n\t// The constructor can be used in two ways:\n\t// 1) With a fable, options object and service hash (the options object and service hash are optional)\n\t// 2) With an object or nothing as the first parameter, where it will be treated as the options object\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\t// Check if a fable was passed in; connect it if so\n\t\tif ((typeof(pFable) === 'object') && pFable.isFable)\n\t\t{\n\t\t\tthis.connectFable(pFable);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.fable = false;\n\t\t}\n\n\t\t// initialize options and UUID based on whether the fable was passed in or not.\n\t\tif (this.fable)\n\t\t{\n\t\t\tthis.UUID = pFable.getUUID();\n\t\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t\t: {};\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// With no fable, check to see if there was an object passed into either of the first two\n\t\t\t// Parameters, and if so, treat it as the options object\n\t\t\tthis.options = ((typeof(pFable) === 'object') && !pFable.isFable) ? pFable\n\t\t\t\t\t\t\t: (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t\t: {};\n\t\t\tthis.UUID = `CORE-SVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`\n\t\t}\n\n\t\t// It's expected that the deriving class will set this\n\t\tthis.serviceType = `Unknown-${this.UUID}`;\n\n\t\t// The service hash is used to identify the specific instantiation of the service in the services map\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash \n\t\t\t\t\t: (!this.fable && (typeof(pOptions) === 'string')) ? pOptions\n\t\t\t\t\t: `${this.UUID}`;\n\t}\n\n\tconnectFable(pFable)\n\t{\n\t\tif ((typeof(pFable) !== 'object') || (!pFable.isFable))\n\t\t{\n\t\t\tlet tmpErrorMessage = `Fable Service Provider Base: Cannot connect to Fable, invalid Fable object passed in.  The pFable parameter was a [${typeof(pFable)}].}`;\n\t\t\tconsole.log(tmpErrorMessage);\n\t\t\treturn new Error(tmpErrorMessage);\n\t\t}\n\n\t\tif (!this.fable)\n\t\t{\n\t\t\tthis.fable = pFable;\n\t\t}\n\n\t\tif (!this.log)\n\t\t{\n\t\t\tthis.log = this.fable.Logging;\n\t\t}\n\t\tif (!this.services)\n\t\t{\n\t\t\tthis.services = this.fable.services;\n\t\t}\n\n\t\tif (!this.servicesMap)\n\t\t{\n\t\t\tthis.servicesMap = this.fable.servicesMap;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tstatic isFableService = true;\n}\n\nmodule.exports = FableServiceProviderBase;\n\n// This is left here in case we want to go back to having different code/base class for \"core\" services\nmodule.exports.CoreServiceProviderBase = FableServiceProviderBase;","// When a boxed property is passed in, it should have quotes of some\n// kind around it.\n//\n// For instance:\n// \t\tMyValues['Name']\n// \t\tMyValues[\"Age\"]\n// \t\tMyValues[`Cost`]\n//\n// This function removes the wrapping quotes.\n//\n// Please note it *DOES NOT PARSE* template literals, so backticks just\n// end up doing the same thing as other quote types.\n//\n// TODO: Should template literals be processed?  If so what state do they have access to?  That should happen here if so.\n// TODO: Make a simple class include library with these\nconst cleanWrapCharacters = (pCharacter, pString) =>\n{\n\tif (pString.startsWith(pCharacter) && pString.endsWith(pCharacter))\n\t{\n\t\treturn pString.substring(1, pString.length - 1);\n\t}\n\telse\n\t{\n\t\treturn pString;\n\t}\n};\n\nmodule.exports = cleanWrapCharacters;","/**\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\n/**\n* Hash Translation\n*\n* This is a very simple translation table for hashes, which allows the same schema to resolve\n* differently based on a loaded translation table.\n*\n* This is to prevent the requirement for mutating schemas over and over again when we want to\n* reuse the structure but look up data elements by different addresses.\n*\n* One side-effect of this is that a translation table can \"override\" the built-in hashes, since\n* this is always used to resolve hashes before any of the functionCallByHash(pHash, ...) perform\n* their lookups by hash.\n*\n* @class ManyfestHashTranslation\n*/\nclass ManyfestHashTranslation\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) === 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) === 'function') ? pErrorLog : libSimpleLog;\n\n        this.translationTable = {};\n\t}\n\n    translationCount()\n    {\n        return Object.keys(this.translationTable).length;\n    }\n\n    addTranslation(pTranslation)\n    {\n        // This adds a translation in the form of:\n        // { \"SourceHash\": \"DestinationHash\", \"SecondSourceHash\":\"SecondDestinationHash\" }\n        if (typeof(pTranslation) != 'object')\n        {\n            this.logError(`Hash translation addTranslation expected a translation be type object but was passed in ${typeof(pTranslation)}`);\n            return false;\n        }\n\n        let tmpTranslationSources = Object.keys(pTranslation)\n\n        tmpTranslationSources.forEach(\n            (pTranslationSource) =>\n            {\n                if (typeof(pTranslation[pTranslationSource]) != 'string')\n                {\n                    this.logError(`Hash translation addTranslation expected a translation destination hash for [${pTranslationSource}] to be a string but the referrant was a ${typeof(pTranslation[pTranslationSource])}`);\n                }\n                else\n                {\n                    this.translationTable[pTranslationSource] = pTranslation[pTranslationSource];\n                }\n            });\n    }\n\n    removeTranslationHash(pTranslationHash)\n    {\n        if (pTranslationHash in this.translationTable)\n        {\n            delete this.translationTable[pTranslationHash];\n        }\n    }\n\n    // This removes translations.\n    // If passed a string, just removes the single one.\n    // If passed an object, it does all the source keys.\n    removeTranslation(pTranslation)\n    {\n        if (typeof(pTranslation) == 'string')\n        {\n            this.removeTranslationHash(pTranslation);\n            return true;\n        }\n        else if (typeof(pTranslation) == 'object')\n        {\n            let tmpTranslationSources = Object.keys(pTranslation)\n\n            tmpTranslationSources.forEach(\n                (pTranslationSource) =>\n                {\n                    this.removeTranslation(pTranslationSource);\n                });\n            return true;\n        }\n        else\n        {\n            this.logError(`Hash translation removeTranslation expected either a string or an object but the passed-in translation was type ${typeof(pTranslation)}`);\n            return false;\n        }\n    }\n\n    clearTranslations()\n    {\n        this.translationTable = {};\n    }\n\n    translate(pTranslation)\n    {\n        if (pTranslation in this.translationTable)\n        {\n            return this.translationTable[pTranslation];\n        }\n        else\n        {\n            return pTranslation;\n        }\n    }\n}\n\nmodule.exports = ManyfestHashTranslation;","/**\n* @author <steven@velozo.com>\n*/\n\n/**\n* Manyfest simple logging shim (for browser and dependency-free running)\n*/\n\nconst logToConsole = (pLogLine, pLogObject) =>\n{\n    let tmpLogLine = (typeof(pLogLine) === 'string') ? pLogLine : '';\n\n    console.log(`[Manyfest] ${tmpLogLine}`);\n\n    if (pLogObject) console.log(JSON.stringify(pLogObject));\n};\n\nmodule.exports = logToConsole;","/**\n* @author <steven@velozo.com>\n*/\nconst libSimpleLog = require('./Manyfest-LogToConsole.js');\n// This is for resolving functions mid-address\nconst libGetObjectValue = require('./Manyfest-ObjectAddress-GetValue.js');\n\n// TODO: Just until this is a fable service.\nlet _MockFable = { DataFormat: require('./Manyfest-ObjectAddress-Parser.js') };\n\n/**\n* Object Address Resolver\n*\n* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to\n*                 be extremely clear what is going on in the recursion for\n*                 each of the three address resolution functions.\n*\n*                 Although there is some opportunity to repeat ourselves a\n*                 bit less in this codebase (e.g. with detection of arrays\n*                 versus objects versus direct properties), it can make\n*                 debugging.. challenging.  The minified version of the code\n*                 optimizes out almost anything repeated in here.  So please\n*                 be kind and rewind... meaning please keep the codebase less\n*                 terse and more verbose so humans can comprehend it.\n*\n*\n* @class ManyfestObjectAddressResolverCheckAddressExists\n*/\nclass ManyfestObjectAddressResolverCheckAddressExists\n{\n\tconstructor()\n\t{\n\t\tthis.getObjectValueClass = new libGetObjectValue(libSimpleLog, libSimpleLog);\n\t}\n\n\t// Check if an address exists.\n\t//\n\t// This is necessary because the getValueAtAddress function is ambiguous on\n\t// whether the element/property is actually there or not (it returns\n\t// undefined whether the property exists or not).  This function checks for\n\t// existance and returns true or false dependent.\n\tcheckAddressExists (pObject, pAddress, pRootObject)\n\t{\n\t\t// TODO: Should these throw an error?\n\t\t// Make sure pObject is an object\n\t\tif (typeof(pObject) != 'object') return false;\n\t\t// Make sure pAddress is a string\n\t\tif (typeof(pAddress) != 'string') return false;\n\n\t\t// Set the root object to the passed-in object if it isn't set yet.  This is expected to be the root object.\n\t\t// NOTE: This was added to support functions mid-stream\n\t\tlet tmpRootObject = (typeof(pRootObject) == 'undefined') ? pObject : pRootObject;\n\n\t\t// DONE: Make this work for things like SomeRootObject.Metadata[\"Some.People.Use.Bad.Object.Property.Names\"]\n\t\tlet tmpAddressPartBeginning = _MockFable.DataFormat.stringGetFirstSegment(pAddress);\n\n\t\t// This is the terminal address string (no more dots so the RECUSION ENDS IN HERE somehow)\n\t\tif (tmpAddressPartBeginning.length == pAddress.length)\n\t\t{\n\t\t\t// Check if the address refers to a boxed property\n\t\t\tlet tmpBracketStartIndex = pAddress.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = pAddress.indexOf(']');\n\n\t\t\t// Check if there is a function somewhere in the address... parenthesis start should only be in a function\n\t\t\tlet tmpFunctionStartIndex = pAddress.indexOf('(');\n\n\t\t\t// NOTE THAT FUNCTIONS MUST RESOLVE FIRST\n\t\t\t// Functions look like this\n\t\t\t// \t\tMyFunction()\n\t\t\t// \t\tMyFunction(Some.Address)\n\t\t\t// \t\tMyFunction(Some.Address,Some.Other.Address)\n\t\t\t// \t\tMyFunction(Some.Address,Some.Other.Address,Some.Third.Address)\n\t\t\t//\n\t\t\t// This could be enhanced to allow purely numeric and string values to be passed to the function.  For now,\n\t\t\t// To heck with that.  This is a simple function call.\n\t\t\t//\n\t\t\t// The requirements to detect a function are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpFunctionStartIndex > 0)\n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (_MockFable.DataFormat.stringCountEnclosures(pAddress) > 0))\n\t\t\t{\n\t\t\t\tlet tmpFunctionAddress = pAddress.substring(0, tmpFunctionStartIndex).trim();\n\n\t\t\t\tif (((tmpFunctionAddress in pObject)) && (typeof(pObject[tmpFunctionAddress]) == 'function'))\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// The address suggests it is a function, but it is not.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[10]\n\t\t\t// \t\tMyValues['Name']\n\t\t\t// \t\tMyValues[\"Age\"]\n\t\t\t// \t\tMyValues[`Cost`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\t// The \"Name\" of the Object contained too the left of the bracket\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\t// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.\n\t\t\t\t// This is a rare case where Arrays testing as Objects is useful\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// The \"Reference\" to the property within it, either an array element or object property\n\t\t\t\tlet tmpBoxedPropertyReference = pAddress.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\t\t\t\t// Attempt to parse the reference as a number, which will be used as an array element\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to treat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynamic object property.\n\t\t\t\t\t// We would expect the property to be wrapped in some kind of quotes so strip them\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Check if the property exists.\n\t\t\t\t\treturn (tmpBoxedPropertyReference in pObject[tmpBoxedPropertyName]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Use the new in operator to see if the element is in the array\n\t\t\t\t\treturn (tmpBoxedPropertyNumber in pObject[tmpBoxedPropertyName]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Check if the property exists\n\t\t\t\treturn (pAddress in pObject);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpSubObjectName = tmpAddressPartBeginning;\n\t\t\tlet tmpNewAddress = pAddress.substring(tmpAddressPartBeginning.length+1);\n\n\t\t\t// Test if the tmpNewAddress is an array or object\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = tmpSubObjectName.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = tmpSubObjectName.indexOf(']');\n\n\t\t\t// Check if there is a function somewhere in the address... parenthesis start should only be in a function\n\t\t\tlet tmpFunctionStartIndex = tmpSubObjectName.indexOf('(');\n\n\t\t\t// NOTE THAT FUNCTIONS MUST RESOLVE FIRST\n\t\t\t// Functions look like this\n\t\t\t// \t\tMyFunction()\n\t\t\t// \t\tMyFunction(Some.Address)\n\t\t\t// \t\tMyFunction(Some.Address,Some.Other.Address)\n\t\t\t// \t\tMyFunction(Some.Address,Some.Other.Address,Some.Third.Address)\n\t\t\t//\n\t\t\t// This could be enhanced to allow purely numeric and string values to be passed to the function.  For now,\n\t\t\t// To heck with that.  This is a simple function call.\n\t\t\t//\n\t\t\t// The requirements to detect a function are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpFunctionStartIndex > 0)\n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (_MockFable.DataFormat.stringCountEnclosures(tmpSubObjectName) > 0))\n\t\t\t{\n\t\t\t\tlet tmpFunctionAddress = tmpSubObjectName.substring(0, tmpFunctionStartIndex).trim();\n\t\t\t\t//tmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\n\t\t\t\tif (!typeof(pObject[tmpFunctionAddress]) == 'function')\n\t\t\t\t{\n\t\t\t\t\t// The address suggests it is a function, but it is not.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Now see if the function has arguments.\n\t\t\t\t// Implementation notes: * ARGUMENTS MUST SHARE THE SAME ROOT OBJECT CONTEXT *\n\t\t\t\tlet tmpFunctionArguments = _MockFable.DataFormat.stringGetSegments(_MockFable.DataFormat.stringGetEnclosureValueByIndex(tmpSubObjectName.substring(tmpFunctionAddress.length), 0), ',');\n\t\t\t\tif ((tmpFunctionArguments.length == 0) || (tmpFunctionArguments[0] == ''))\n\t\t\t\t{\n\t\t\t\t\t// No arguments... just call the function (bound to the scope of the object it is contained withing)\n\t\t\t\t\tif (tmpFunctionAddress in pObject)\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn this.checkAddressExists(pObject[tmpFunctionAddress].apply(pObject), tmpNewAddress, tmpRootObject);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(pError)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// The function call failed, so the address doesn't exist\n\t\t\t\t\t\t\tlibSimpleLog.log(`Error calling function ${tmpFunctionAddress} (address [${pAddress}]): ${pError.message}`);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// The function doesn't exist, so the address doesn't exist\n\t\t\t\t\t\tlibSimpleLog.log(`Function ${tmpFunctionAddress} does not exist (address [${pAddress}])`);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlet tmpArgumentValues = [];\n\n\t\t\t\t\tlet tmpRootObject = (typeof(pRootObject) == 'undefined') ? pObject : pRootObject;\n\n\t\t\t\t\t// Now get the value for each argument\n\t\t\t\t\tfor (let i = 0; i < tmpFunctionArguments.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Resolve the values for each subsequent entry\n\t\t\t\t\t\t// NOTE: This is where the resolves get really tricky.  Recursion within recursion.  Programming gom jabbar, yo.\n\t\t\t\t\t\ttmpArgumentValues.push(this.getObjectValueClass.getValueAtAddress(tmpRootObject, tmpFunctionArguments[i]));\n\t\t\t\t\t}\n\n\t\t\t\t\t//return this.checkAddressExists(pObject[tmpFunctionAddress].apply(pObject, tmpArgumentValues), tmpNewAddress, tmpRootObject);\n\t\t\t\t\tif (tmpFunctionAddress in pObject)\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn this.checkAddressExists(pObject[tmpFunctionAddress].apply(pObject, tmpArgumentValues), tmpNewAddress, tmpRootObject);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(pError)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// The function call failed, so the address doesn't exist\n\t\t\t\t\t\t\tlibSimpleLog.log(`Error calling function ${tmpFunctionAddress} (address [${pAddress}]): ${pError.message}`);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// The function doesn't exist, so the address doesn't exist\n\t\t\t\t\t\tlibSimpleLog.log(`Function ${tmpFunctionAddress} does not exist (address [${pAddress}])`);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[42]\n\t\t\t// \t\tMyValues['Color']\n\t\t\t// \t\tMyValues[\"Weight\"]\n\t\t\t// \t\tMyValues[`Diameter`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = tmpSubObjectName.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyReference = tmpSubObjectName.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[1].Tardy\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[\"JaneDoe\"].Grade\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an array, so the [\"JaneDoe\"].Grade is not possible to access\n\t\t\t\t// TODO: Should this be an error or something?  Should we keep a log of failures like this?\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// Because this is an impossible address, the property doesn't exist\n\t\t\t\t\t// TODO: Should we throw an error in this condition?\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//This is a bracketed value\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to reat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynanmic object property.\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Recurse directly into the subobject\n\t\t\t\t\treturn this.checkAddressExists(pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference], tmpNewAddress, tmpRootObject);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// We parsed a valid number out of the boxed property name, so recurse into the array\n\t\t\t\t\treturn this.checkAddressExists(pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber], tmpNewAddress, tmpRootObject);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there is an object property already named for the sub object, but it isn't an object\n\t\t\t// then the system can't set the value in there.  Error and abort!\n\t\t\tif ((tmpSubObjectName in pObject) && typeof(pObject[tmpSubObjectName]) !== 'object')\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (tmpSubObjectName in pObject)\n\t\t\t{\n\t\t\t\t// If there is already a subobject pass that to the recursive thingy\n\t\t\t\treturn this.checkAddressExists(pObject[tmpSubObjectName], tmpNewAddress, tmpRootObject);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Create a subobject and then pass that\n\t\t\t\tpObject[tmpSubObjectName] = {};\n\t\t\t\treturn this.checkAddressExists(pObject[tmpSubObjectName], tmpNewAddress, tmpRootObject);\n\t\t\t}\n\t\t}\n\t}\n};\n\nmodule.exports = ManyfestObjectAddressResolverCheckAddressExists;","/**\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\nlet fCleanWrapCharacters = require('./Manyfest-CleanWrapCharacters.js');\nlet fParseConditionals = require(`../source/Manyfest-ParseConditionals.js`)\n\n/**\n* Object Address Resolver - DeleteValue\n*\n* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to\n*                 be extremely clear what is going on in the recursion for\n*                 each of the three address resolution functions.\n*\n*                 Although there is some opportunity to repeat ourselves a\n*                 bit less in this codebase (e.g. with detection of arrays\n*                 versus objects versus direct properties), it can make\n*                 debugging.. challenging.  The minified version of the code\n*                 optimizes out almost anything repeated in here.  So please\n*                 be kind and rewind... meaning please keep the codebase less\n*                 terse and more verbose so humans can comprehend it.\n*\n* TODO: Once we validate this pattern is good to go, break these out into\n*       three separate modules.\n*\n* @class ManyfestObjectAddressResolverDeleteValue\n*/\nclass ManyfestObjectAddressResolverDeleteValue\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) == 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) == 'function') ? pErrorLog : libSimpleLog;\n\n\t\tthis.cleanWrapCharacters = fCleanWrapCharacters;\n\t}\n\n\t// TODO: Dry me\n\tcheckRecordFilters(pAddress, pRecord)\n\t{\n\t\treturn fParseConditionals(this, pAddress, pRecord);\n\t}\n\n\t// Delete the value of an element at an address\n\tdeleteValueAtAddress (pObject, pAddress, pParentAddress)\n\t{\n\t\t// Make sure pObject (the object we are meant to be recursing) is an object (which could be an array or object)\n\t\tif (typeof(pObject) != 'object') return undefined;\n\t\t// Make sure pAddress (the address we are resolving) is a string\n\t\tif (typeof(pAddress) != 'string') return undefined;\n\t\t// Stash the parent address for later resolution\n\t\tlet tmpParentAddress = \"\";\n\t\tif (typeof(pParentAddress) == 'string')\n\t\t{\n\t\t\ttmpParentAddress = pParentAddress;\n\t\t}\n\n\t\t// TODO: Make this work for things like SomeRootObject.Metadata[\"Some.People.Use.Bad.Object.Property.Names\"]\n\t\tlet tmpSeparatorIndex = pAddress.indexOf('.');\n\n\t\t// This is the terminal address string (no more dots so the RECUSION ENDS IN HERE somehow)\n\t\tif (tmpSeparatorIndex == -1)\n\t\t{\n\t\t\t// Check if the address refers to a boxed property\n\t\t\tlet tmpBracketStartIndex = pAddress.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = pAddress.indexOf(']');\n\n\t\t\t// Check for the Object Set Type marker.\n\t\t\t// Note this will not work with a bracket in the same address box set\n\t\t\tlet tmpObjectTypeMarkerIndex = pAddress.indexOf('{}');\n\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[10]\n\t\t\t// \t\tMyValues['Name']\n\t\t\t// \t\tMyValues[\"Age\"]\n\t\t\t// \t\tMyValues[`Cost`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\t// The \"Name\" of the Object contained too the left of the bracket\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\t// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.\n\t\t\t\t// This is a rare case where Arrays testing as Objects is useful\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// The \"Reference\" to the property within it, either an array element or object property\n\t\t\t\tlet tmpBoxedPropertyReference = pAddress.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\t\t\t\t// Attempt to parse the reference as a number, which will be used as an array element\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to treat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynamic object property.\n\t\t\t\t\t// We would expect the property to be wrapped in some kind of quotes so strip them\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Return the value in the property\n\t\t\t\t\tdelete pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference];\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdelete pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber];\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// The requirements to detect a boxed set element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is nothing in the brackets\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex == 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tif (!Array.isArray(pObject[tmpBoxedPropertyName]))\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tlet tmpInputArray = pObject[tmpBoxedPropertyName];\n\t\t\t\t// Count from the end to the beginning so splice doesn't %&%#$ up the array\n\t\t\t\tfor (let i = tmpInputArray.length - 1; i >= 0; i--)\n\t\t\t\t{\n\t\t\t\t\t// The filtering is complex but allows config-based metaprogramming directly from schema\n\t\t\t\t\tlet tmpKeepRecord = this.checkRecordFilters(pAddress, tmpInputArray[i]);\n\t\t\t\t\tif (tmpKeepRecord)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Delete elements end to beginning\n\t\t\t\t\t\ttmpInputArray.splice(i, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// The object has been flagged as an object set, so treat it as such\n\t\t\telse if (tmpObjectTypeMarkerIndex > 0)\n\t\t\t{\n\t\t\t\tlet tmpObjectPropertyName = pAddress.substring(0, tmpObjectTypeMarkerIndex).trim();\n\n\t\t\t\tif (typeof(pObject[tmpObjectPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tdelete pObject[tmpObjectPropertyName];\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Now is the point in recursion to return the value in the address\n\t\t\t\tdelete pObject[pAddress];\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpSubObjectName = pAddress.substring(0, tmpSeparatorIndex);\n\t\t\tlet tmpNewAddress = pAddress.substring(tmpSeparatorIndex+1);\n\n\t\t\t// BOXED ELEMENTS\n\t\t\t// Test if the tmpNewAddress is an array or object\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = tmpSubObjectName.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = tmpSubObjectName.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[42]\n\t\t\t// \t\tMyValues['Color']\n\t\t\t// \t\tMyValues[\"Weight\"]\n\t\t\t// \t\tMyValues[`Diameter`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = tmpSubObjectName.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyReference = tmpSubObjectName.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[1].Tardy\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[\"JaneDoe\"].Grade\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an array, so the [\"JaneDoe\"].Grade is not possible to access\n\t\t\t\t// TODO: Should this be an error or something?  Should we keep a log of failures like this?\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// Check if the boxed property is an object.\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t//This is a bracketed value\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to reat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynanmic object property.\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\t\t// Recurse directly into the subobject\n\t\t\t\t\treturn this.deleteValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference], tmpNewAddress, tmpParentAddress);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\t\t// We parsed a valid number out of the boxed property name, so recurse into the array\n\t\t\t\t\treturn this.deleteValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber], tmpNewAddress, tmpParentAddress);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// The requirements to detect a boxed set element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is nothing in the brackets\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex == 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tif (!Array.isArray(pObject[tmpBoxedPropertyName]))\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// We need to enumerate the array and grab the addresses from there.\n\t\t\t\tlet tmpArrayProperty = pObject[tmpBoxedPropertyName];\n\t\t\t\t// Managing the parent address is a bit more complex here -- the box will be added for each element.\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpBoxedPropertyName}`;\n\t\t\t\t// The container object is where we have the \"Address\":SOMEVALUE pairs\n\t\t\t\tlet tmpContainerObject = {};\n\t\t\t\tfor (let i = 0; i < tmpArrayProperty.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpPropertyParentAddress = `${tmpParentAddress}[${i}]`;\n\t\t\t\t\tlet tmpValue = this.deleteValueAtAddress(pObject[tmpBoxedPropertyName][i], tmpNewAddress, tmpPropertyParentAddress);\n\n\t\t\t\t\ttmpContainerObject[`${tmpPropertyParentAddress}.${tmpNewAddress}`] = tmpValue;\n\t\t\t\t}\n\n\t\t\t\treturn tmpContainerObject;\n\t\t\t}\n\n\t\t\t// OBJECT SET\n\t\t\t// Note this will not work with a bracket in the same address box set\n\t\t\tlet tmpObjectTypeMarkerIndex = pAddress.indexOf('{}');\n\t\t\tif (tmpObjectTypeMarkerIndex > 0)\n\t\t\t{\n\t\t\t\tlet tmpObjectPropertyName = pAddress.substring(0, tmpObjectTypeMarkerIndex).trim();\n\n\t\t\t\tif (typeof(pObject[tmpObjectPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// We need to enumerate the Object and grab the addresses from there.\n\t\t\t\tlet tmpObjectProperty = pObject[tmpObjectPropertyName];\n\t\t\t\tlet tmpObjectPropertyKeys = Object.keys(tmpObjectProperty);\n\t\t\t\t// Managing the parent address is a bit more complex here -- the box will be added for each element.\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpObjectPropertyName}`;\n\t\t\t\t// The container object is where we have the \"Address\":SOMEVALUE pairs\n\t\t\t\tlet tmpContainerObject = {};\n\t\t\t\tfor (let i = 0; i < tmpObjectPropertyKeys.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpPropertyParentAddress = `${tmpParentAddress}.${tmpObjectPropertyKeys[i]}`;\n\t\t\t\t\tlet tmpValue = this.deleteValueAtAddress(pObject[tmpObjectPropertyName][tmpObjectPropertyKeys[i]], tmpNewAddress, tmpPropertyParentAddress);\n\n\t\t\t\t\t// The filtering is complex but allows config-based metaprogramming directly from schema\n\t\t\t\t\tlet tmpKeepRecord = this.checkRecordFilters(pAddress, tmpValue);\n\t\t\t\t\tif (tmpKeepRecord)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpContainerObject[`${tmpPropertyParentAddress}.${tmpNewAddress}`] = tmpValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmpContainerObject;\n\t\t\t}\n\n\t\t\t// If there is an object property already named for the sub object, but it isn't an object\n\t\t\t// then the system can't set the value in there.  Error and abort!\n\t\t\tif ((tmpSubObjectName in pObject) && typeof(pObject[tmpSubObjectName]) !== 'object')\n\t\t\t{\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\telse if (tmpSubObjectName in pObject)\n\t\t\t{\n\t\t\t\t// If there is already a subobject pass that to the recursive thingy\n\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\treturn this.deleteValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, tmpParentAddress);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Create a subobject and then pass that\n\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\tpObject[tmpSubObjectName] = {};\n\t\t\t\treturn this.deleteValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, tmpParentAddress);\n\t\t\t}\n\t\t}\n\t}\n};\n\nmodule.exports = ManyfestObjectAddressResolverDeleteValue;","/**\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\nlet fCleanWrapCharacters = require('./Manyfest-CleanWrapCharacters.js');\nlet fParseConditionals = require(`../source/Manyfest-ParseConditionals.js`);\n\nlet _MockFable = { DataFormat: require('./Manyfest-ObjectAddress-Parser.js') };\n\n/**\n* Object Address Resolver - GetValue\n*\n* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to\n*                 be extremely clear what is going on in the recursion for\n*                 each of the three address resolution functions.\n*\n*                 Although there is some opportunity to repeat ourselves a\n*                 bit less in this codebase (e.g. with detection of arrays\n*                 versus objects versus direct properties), it can make\n*                 debugging.. challenging.  The minified version of the code\n*                 optimizes out almost anything repeated in here.  So please\n*                 be kind and rewind... meaning please keep the codebase less\n*                 terse and more verbose so humans can comprehend it.\n*\n* TODO: Once we validate this pattern is good to go, break these out into\n*       three separate modules.\n*\n* @class ManyfestObjectAddressResolverGetValue\n*/\nclass ManyfestObjectAddressResolverGetValue\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) == 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) == 'function') ? pErrorLog : libSimpleLog;\n\n\t\tthis.cleanWrapCharacters = fCleanWrapCharacters;\n\t}\n\n\tcheckRecordFilters(pAddress, pRecord)\n\t{\n\t\treturn fParseConditionals(this, pAddress, pRecord);\n\t}\n\n\t// Get the value of an element at an address\n\tgetValueAtAddress (pObject, pAddress, pParentAddress, pRootObject)\n\t{\n\t\t// Make sure pObject (the object we are meant to be recursing) is an object (which could be an array or object)\n\t\tif (typeof(pObject) != 'object') return undefined;\n\t\t// Make sure pAddress (the address we are resolving) is a string\n\t\tif (typeof(pAddress) != 'string') return undefined;\n\t\t// Stash the parent address for later resolution\n\t\tlet tmpParentAddress = \"\";\n\t\tif (typeof(pParentAddress) == 'string')\n\t\t{\n\t\t\ttmpParentAddress = pParentAddress;\n\t\t}\n\n\t\t// Set the root object to the passed-in object if it isn't set yet.  This is expected to be the root object.\n\t\tlet tmpRootObject = (typeof(pRootObject) == 'undefined') ? pObject : pRootObject;\n\n\t\t// DONE: Make this work for things like SomeRootObject.Metadata[\"Some.People.Use.Bad.Object.Property.Names\"]\n\t\tlet tmpAddressPartBeginning = _MockFable.DataFormat.stringGetFirstSegment(pAddress);\n\n\t\t// Adding simple back-navigation in objects\n\t\tif (tmpAddressPartBeginning == '')\n\t\t{\n\t\t\t// Given an address of \"Bundle.Contract.IDContract...Project.IDProject\" the ... would be interpreted as two back-navigations from IDContract.\n\t\t\t// When the address is passed in, though, the first . is already eliminated.  So we can count the dots.\n\t\t\tlet tmpParentAddressParts = _MockFable.DataFormat.stringGetSegments(tmpParentAddress);\n\n\t\t\tlet tmpBackNavigationCount = 0;\n\n\t\t\t// Count the number of dots\n\t\t\tfor (let i = 0; i < pAddress.length; i++)\n\t\t\t{\n\t\t\t\tif (pAddress.charAt(i) != '.')\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttmpBackNavigationCount++;\n\t\t\t}\n\n\t\t\tlet tmpParentAddressLength = tmpParentAddressParts.length - tmpBackNavigationCount;\n\n\t\t\tif (tmpParentAddressLength < 0)\n\t\t\t{\n\t\t\t\t// We are trying to back navigate more than we can.\n\t\t\t\t// TODO: Should this be undefined or should we bank out at the bottom and try to go forward?\n\t\t\t\t// This seems safest for now.\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// We are trying to back navigate to a parent object.\n\t\t\t\t// Recurse with the back-propagated parent address, and, the new address without the back-navigation dots.\n\t\t\t\tlet tmpRecurseAddress = pAddress.slice(tmpBackNavigationCount);\n\t\t\t\tif (tmpParentAddressLength > 0)\n\t\t\t\t{\n\t\t\t\t\ttmpRecurseAddress = `${tmpParentAddressParts.slice(0, tmpParentAddressLength).join('.')}.${tmpRecurseAddress}`;\n\t\t\t\t}\n\t\t\t\tthis.logInfo(`Back-navigation detected.  Recursing back to address [${tmpRecurseAddress}]`);\n\t\t\t\treturn this.getValueAtAddress(tmpRootObject, tmpRecurseAddress);\n\t\t\t}\n\t\t}\n\n\t\t// This is the terminal address string (no more dots so the RECUSION ENDS IN HERE somehow)\n\t\tif (tmpAddressPartBeginning.length == pAddress.length)\n\t\t{\n\t\t\t// TODO: Optimize this by having these calls only happen when the previous fails.\n\t\t\t// TODO: Alternatively look for all markers in one pass?\n\t\t\t// Check if the address refers to a boxed property\n\t\t\tlet tmpBracketStartIndex = pAddress.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = pAddress.indexOf(']');\n\n\t\t\t// Check for the Object Set Type marker.\n\t\t\t// Note this will not work with a bracket in the same address box set\n\t\t\tlet tmpObjectTypeMarkerIndex = pAddress.indexOf('{}');\n\n\n\t\t\t// Check if there is a function somewhere in the address... parenthesis start should only be in a function\n\t\t\tlet tmpFunctionStartIndex = pAddress.indexOf('(');\n\n\t\t\t// NOTE THAT FUNCTIONS MUST RESOLVE FIRST\n\t\t\t// Functions look like this\n\t\t\t// \t\tMyFunction()\n\t\t\t// \t\tMyFunction(Some.Address)\n\t\t\t// \t\tMyFunction(Some.Address,Some.Other.Address)\n\t\t\t// \t\tMyFunction(Some.Address,Some.Other.Address,Some.Third.Address)\n\t\t\t//\n\t\t\t// This could be enhanced to allow purely numeric and string values to be passed to the function.  For now,\n\t\t\t// To heck with that.  This is a simple function call.\n\t\t\t//\n\t\t\t// The requirements to detect a function are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpFunctionStartIndex > 0)\n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (_MockFable.DataFormat.stringCountEnclosures(pAddress) > 0))\n\t\t\t{\n\t\t\t\tlet tmpFunctionAddress = pAddress.substring(0, tmpFunctionStartIndex).trim();\n\n\t\t\t\tif (!typeof(pObject[tmpFunctionAddress]) == 'function')\n\t\t\t\t{\n\t\t\t\t\t// The address suggests it is a function, but it is not.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Now see if the function has arguments.\n\t\t\t\t// Implementation notes: * ARGUMENTS MUST SHARE THE SAME ROOT OBJECT CONTEXT *\n\t\t\t\tlet tmpFunctionArguments = _MockFable.DataFormat.stringGetSegments(_MockFable.DataFormat.stringGetEnclosureValueByIndex(pAddress.substring(tmpFunctionAddress.length), 0), ',');\n\t\t\t\tif ((tmpFunctionArguments.length == 0) || (tmpFunctionArguments[0] == ''))\n\t\t\t\t{\n\t\t\t\t\t// No arguments... just call the function (bound to the scope of the object it is contained withing)\n\t\t\t\t\tif (tmpFunctionAddress in pObject)\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn pObject[tmpFunctionAddress].apply(pObject);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(pError)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// The function call failed, so the address doesn't exist\n\t\t\t\t\t\t\tconsole.log(`Error in getValueAtAddress calling function ${tmpFunctionAddress} (address [${pAddress}]): ${pError.message}`);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// The function doesn't exist, so the address doesn't exist\n\t\t\t\t\t\tconsole.log(`Function ${tmpFunctionAddress} does not exist (address [${pAddress}])`);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlet tmpArgumentValues = [];\n\n\t\t\t\t\tlet tmpRootObject = (typeof(pRootObject) == 'undefined') ? pObject : pRootObject;\n\n\t\t\t\t\t// Now get the value for each argument\n\t\t\t\t\tfor (let i = 0; i < tmpFunctionArguments.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Resolve the values for each subsequent entry\n\t\t\t\t\t\t// Check if the argument value is a string literal or a reference to an address\n\t\t\t\t\t\tif ((tmpFunctionArguments[i].length >= 2)\n\t\t\t\t\t\t\t&&\n\t\t\t\t\t\t\t((tmpFunctionArguments[i].charAt(0) == '\"')\n\t\t\t\t\t\t\t|| (tmpFunctionArguments[i].charAt(0) == \"'\")\n\t\t\t\t\t\t\t|| (tmpFunctionArguments[i].charAt(0) == \"`\"))\n\t\t\t\t\t\t\t&&\n\t\t\t\t\t\t\t((tmpFunctionArguments[i].charAt(tmpFunctionArguments[i].length-1) == '\"')\n\t\t\t\t\t\t\t|| (tmpFunctionArguments[i].charAt(tmpFunctionArguments[i].length-1) == \"'\")\n\t\t\t\t\t\t\t|| (tmpFunctionArguments[i].charAt(tmpFunctionArguments[i].length-1) == \"`\")))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// This is a string literal\n\t\t\t\t\t\t\ttmpArgumentValues.push(tmpFunctionArguments[i].substring(1, tmpFunctionArguments[i].length-1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// This is a hash address\n\t\t\t\t\t\t\ttmpArgumentValues.push(this.getValueAtAddress(tmpRootObject, tmpFunctionArguments[i]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (tmpFunctionAddress in pObject)\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn pObject[tmpFunctionAddress].apply(pObject, tmpArgumentValues);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(pError)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// The function call failed, so the address doesn't exist\n\t\t\t\t\t\t\tconsole.log(`Error in getValueAtAddress calling function ${tmpFunctionAddress} (address [${pAddress}]): ${pError.message}`);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// The function doesn't exist, so the address doesn't exist\n\t\t\t\t\t\tconsole.log(`Function ${tmpFunctionAddress} does not exist (address [${pAddress}])`);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[10]\n\t\t\t// \t\tMyValues['Name']\n\t\t\t// \t\tMyValues[\"Age\"]\n\t\t\t// \t\tMyValues[`Cost`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\t// The \"Name\" of the Object contained too the left of the bracket\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\t// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.\n\t\t\t\t// This is a rare case where Arrays testing as Objects is useful\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\t// The \"Reference\" to the property within it, either an array element or object property\n\t\t\t\tlet tmpBoxedPropertyReference = pAddress.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\t\t\t\t// Attempt to parse the reference as a number, which will be used as an array element\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to treat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynamic object property.\n\t\t\t\t\t// We would expect the property to be wrapped in some kind of quotes so strip them\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Return the value in the property\n\t\t\t\t\treturn pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// The requirements to detect a boxed set element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is nothing in the brackets\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex == 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tif (!Array.isArray(pObject[tmpBoxedPropertyName]))\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tlet tmpInputArray = pObject[tmpBoxedPropertyName];\n\t\t\t\tlet tmpOutputArray = [];\n\t\t\t\tfor (let i = 0; i < tmpInputArray.length; i++)\n\t\t\t\t{\n\t\t\t\t\t// The filtering is complex but allows config-based metaprogramming directly from schema\n\t\t\t\t\tlet tmpKeepRecord = this.checkRecordFilters(pAddress, tmpInputArray[i]);\n\t\t\t\t\tif (tmpKeepRecord)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpOutputArray.push(tmpInputArray[i]);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmpOutputArray;\n\t\t\t}\n\t\t\t// The object has been flagged as an object set, so treat it as such\n\t\t\telse if (tmpObjectTypeMarkerIndex > 0)\n\t\t\t{\n\t\t\t\tlet tmpObjectPropertyName = pAddress.substring(0, tmpObjectTypeMarkerIndex).trim();\n\n\t\t\t\tif (typeof(pObject[tmpObjectPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\treturn pObject[tmpObjectPropertyName];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Now is the point in recursion to return the value in the address\n\t\t\t\tif (typeof(pObject[pAddress]) != null)\n\t\t\t\t{\n\t\t\t\t\treturn pObject[pAddress];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//let tmpSubObjectName = pAddress.substring(0, tmpSeparatorIndex);\n\t\t\t//let tmpNewAddress = pAddress.substring(tmpSeparatorIndex+1);\n\t\t\tlet tmpSubObjectName = tmpAddressPartBeginning;\n\t\t\tlet tmpNewAddress = pAddress.substring(tmpAddressPartBeginning.length+1);\n\n\t\t\t// BOXED ELEMENTS\n\t\t\t// Test if the tmpNewAddress is an array or object\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = tmpSubObjectName.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = tmpSubObjectName.indexOf(']');\n\n\t\t\t// Check if there is a function somewhere in the address... parenthesis start should only be in a function\n\t\t\tlet tmpFunctionStartIndex = tmpSubObjectName.indexOf('(');\n\n\t\t\t// NOTE THAT FUNCTIONS MUST RESOLVE FIRST\n\t\t\t// Functions look like this\n\t\t\t// \t\tMyFunction()\n\t\t\t// \t\tMyFunction(Some.Address)\n\t\t\t// \t\tMyFunction(Some.Address,Some.Other.Address)\n\t\t\t// \t\tMyFunction(Some.Address,Some.Other.Address,Some.Third.Address)\n\t\t\t//\n\t\t\t// This could be enhanced to allow purely numeric and string values to be passed to the function.  For now,\n\t\t\t// To heck with that.  This is a simple function call.\n\t\t\t//\n\t\t\t// The requirements to detect a function are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpFunctionStartIndex > 0)\n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (_MockFable.DataFormat.stringCountEnclosures(tmpSubObjectName) > 0))\n\t\t\t{\n\t\t\t\tlet tmpFunctionAddress = tmpSubObjectName.substring(0, tmpFunctionStartIndex).trim();\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\n\t\t\t\tif (!typeof(pObject[tmpFunctionAddress]) == 'function')\n\t\t\t\t{\n\t\t\t\t\t// The address suggests it is a function, but it is not.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Now see if the function has arguments.\n\t\t\t\t// Implementation notes: * ARGUMENTS MUST SHARE THE SAME ROOT OBJECT CONTEXT *\n\t\t\t\tlet tmpFunctionArguments = _MockFable.DataFormat.stringGetSegments(_MockFable.DataFormat.stringGetEnclosureValueByIndex(tmpSubObjectName.substring(tmpFunctionAddress.length), 0), ',');\n\t\t\t\tif ((tmpFunctionArguments.length == 0) || (tmpFunctionArguments[0] == ''))\n\t\t\t\t{\n\t\t\t\t\t// No arguments... just call the function (bound to the scope of the object it is contained withing)\n\t\t\t\t\tif (tmpFunctionAddress in pObject)\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn this.getValueAtAddress(pObject[tmpFunctionAddress].apply(pObject), tmpNewAddress, tmpParentAddress, tmpRootObject);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(pError)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// The function call failed, so the address doesn't exist\n\t\t\t\t\t\t\tconsole.log(`Error in getValueAtAddress calling function ${tmpFunctionAddress} (address [${pAddress}]): ${pError.message}`);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// The function doesn't exist, so the address doesn't exist\n\t\t\t\t\t\tconsole.log(`Function ${tmpFunctionAddress} does not exist (address [${pAddress}])`);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlet tmpArgumentValues = [];\n\n\t\t\t\t\tlet tmpRootObject = (typeof(pRootObject) == 'undefined') ? pObject : pRootObject;\n\n\t\t\t\t\t// Now get the value for each argument\n\t\t\t\t\tfor (let i = 0; i < tmpFunctionArguments.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Resolve the values for each subsequent entry\n\t\t\t\t\t\t// Check if the argument value is a string literal or a reference to an address\n\t\t\t\t\t\tif ((tmpFunctionArguments[i].length >= 2)\n\t\t\t\t\t\t\t&&\n\t\t\t\t\t\t\t((tmpFunctionArguments[i].charAt(0) == '\"')\n\t\t\t\t\t\t\t|| (tmpFunctionArguments[i].charAt(0) == \"'\")\n\t\t\t\t\t\t\t|| (tmpFunctionArguments[i].charAt(0) == \"`\"))\n\t\t\t\t\t\t\t&&\n\t\t\t\t\t\t\t((tmpFunctionArguments[i].charAt(tmpFunctionArguments[i].length-1) == '\"')\n\t\t\t\t\t\t\t|| (tmpFunctionArguments[i].charAt(tmpFunctionArguments[i].length-1) == \"'\")\n\t\t\t\t\t\t\t|| (tmpFunctionArguments[i].charAt(tmpFunctionArguments[i].length-1) == \"`\")))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// This is a string literal\n\t\t\t\t\t\t\ttmpArgumentValues.push(tmpFunctionArguments[i].substring(1, tmpFunctionArguments[i].length-1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// This is a hash address\n\t\t\t\t\t\t\ttmpArgumentValues.push(this.getValueAtAddress(tmpRootObject, tmpFunctionArguments[i]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (tmpFunctionAddress in pObject)\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn this.getValueAtAddress(pObject[tmpFunctionAddress].apply(pObject, tmpArgumentValues), tmpNewAddress, tmpParentAddress, tmpRootObject);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(pError)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// The function call failed, so the address doesn't exist\n\t\t\t\t\t\t\tconsole.log(`Error in getValueAtAddress calling function ${tmpFunctionAddress} (address [${pAddress}]): ${pError.message}`);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// The function doesn't exist, so the address doesn't exist\n\t\t\t\t\t\tconsole.log(`Function ${tmpFunctionAddress} does not exist (address [${pAddress}])`);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[42]\n\t\t\t// \t\tMyValues['Color']\n\t\t\t// \t\tMyValues[\"Weight\"]\n\t\t\t// \t\tMyValues[`Diameter`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = tmpSubObjectName.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyReference = tmpSubObjectName.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[1].Tardy\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[\"JaneDoe\"].Grade\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an array, so the [\"JaneDoe\"].Grade is not possible to access\n\t\t\t\t// TODO: Should this be an error or something?  Should we keep a log of failures like this?\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\t// Check if the boxed property is an object.\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\n\t\t\t\t//This is a bracketed value\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to reat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynanmic object property.\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\t\t// Recurse directly into the subobject\n\t\t\t\t\treturn this.getValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference], tmpNewAddress, tmpParentAddress, tmpRootObject);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\t\t// We parsed a valid number out of the boxed property name, so recurse into the array\n\t\t\t\t\treturn this.getValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber], tmpNewAddress, tmpParentAddress, tmpRootObject);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// The requirements to detect a boxed set element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is nothing in the brackets\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex == 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tif (!Array.isArray(pObject[tmpBoxedPropertyName]))\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// We need to enumerate the array and grab the addresses from there.\n\t\t\t\tlet tmpArrayProperty = pObject[tmpBoxedPropertyName];\n\t\t\t\t// Managing the parent address is a bit more complex here -- the box will be added for each element.\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpBoxedPropertyName}`;\n\t\t\t\t// The container object is where we have the \"Address\":SOMEVALUE pairs\n\t\t\t\tlet tmpContainerObject = {};\n\t\t\t\tfor (let i = 0; i < tmpArrayProperty.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpPropertyParentAddress = `${tmpParentAddress}[${i}]`;\n\t\t\t\t\tlet tmpValue = this.getValueAtAddress(pObject[tmpBoxedPropertyName][i], tmpNewAddress, tmpPropertyParentAddress, tmpRootObject);\n\n\t\t\t\t\ttmpContainerObject[`${tmpPropertyParentAddress}.${tmpNewAddress}`] = tmpValue;\n\t\t\t\t}\n\n\t\t\t\treturn tmpContainerObject;\n\t\t\t}\n\n\t\t\t// OBJECT SET\n\t\t\t// Note this will not work with a bracket in the same address box set\n\t\t\tlet tmpObjectTypeMarkerIndex = pAddress.indexOf('{}');\n\t\t\tif (tmpObjectTypeMarkerIndex > 0)\n\t\t\t{\n\t\t\t\tlet tmpObjectPropertyName = pAddress.substring(0, tmpObjectTypeMarkerIndex).trim();\n\n\t\t\t\tif (typeof(pObject[tmpObjectPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// We need to enumerate the Object and grab the addresses from there.\n\t\t\t\tlet tmpObjectProperty = pObject[tmpObjectPropertyName];\n\t\t\t\tlet tmpObjectPropertyKeys = Object.keys(tmpObjectProperty);\n\t\t\t\t// Managing the parent address is a bit more complex here -- the box will be added for each element.\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpObjectPropertyName}`;\n\t\t\t\t// The container object is where we have the \"Address\":SOMEVALUE pairs\n\t\t\t\tlet tmpContainerObject = {};\n\t\t\t\tfor (let i = 0; i < tmpObjectPropertyKeys.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpPropertyParentAddress = `${tmpParentAddress}.${tmpObjectPropertyKeys[i]}`;\n\t\t\t\t\tlet tmpValue = this.getValueAtAddress(pObject[tmpObjectPropertyName][tmpObjectPropertyKeys[i]], tmpNewAddress, tmpPropertyParentAddress, tmpRootObject);\n\n\t\t\t\t\t// The filtering is complex but allows config-based metaprogramming directly from schema\n\t\t\t\t\tlet tmpKeepRecord = this.checkRecordFilters(pAddress, tmpValue);\n\t\t\t\t\tif (tmpKeepRecord)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpContainerObject[`${tmpPropertyParentAddress}.${tmpNewAddress}`] = tmpValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmpContainerObject;\n\t\t\t}\n\n\t\t\t// If there is an object property already named for the sub object, but it isn't an object\n\t\t\t// then the system can't set the value in there.  Error and abort!\n\t\t\tif ((tmpSubObjectName in pObject) && typeof(pObject[tmpSubObjectName]) !== 'object')\n\t\t\t{\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\telse if (tmpSubObjectName in pObject)\n\t\t\t{\n\t\t\t\t// If there is already a subobject pass that to the recursive thingy\n\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\treturn this.getValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, tmpParentAddress, tmpRootObject);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Create a subobject and then pass that\n\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\tpObject[tmpSubObjectName] = {};\n\t\t\t\treturn this.getValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, tmpParentAddress, tmpRootObject);\n\t\t\t}\n\t\t}\n\t}\n};\n\nmodule.exports = ManyfestObjectAddressResolverGetValue;","// TODO: This is an inelegant solution to delay the rewrite of Manyfest.\n\n// Fable 3.0 has a service for data formatting that deals well with nested enclosures.\n\n// The Manyfest library predates fable 3.0 and the services structure of it, so the functions\n// are more or less pure javascript and as functional as they can be made to be.\n\n// Until we shift Manyfest to be a fable service, these three functions were pulled out of\n// fable to aid in parsing functions with nested enclosures.\n\nmodule.exports = {\n\t/**\n\t * Count the number of segments in a string, respecting enclosures\n\t * \n\t * @param {string} pString \n\t * @param {string} pSeparator \n\t * @param {object} pEnclosureStartSymbolMap \n\t * @param {object} pEnclosureEndSymbolMap \n\t * @returns the count of segments in the string as a number\n\t */\n\tstringCountSegments: (pString, pSeparator, pEnclosureStartSymbolMap, pEnclosureEndSymbolMap) =>\n\t{\n\t\tlet tmpString = (typeof(pString) == 'string') ? pString : '';\n\n\t\tlet tmpSeparator = (typeof(pSeparator) == 'string') ? pSeparator : '.';\n\n\t\tlet tmpEnclosureStartSymbolMap = (typeof(pEnclosureStartSymbolMap) == 'object') ? pEnclosureStart : { '{': 0, '[': 1, '(': 2 };\n\t\tlet tmpEnclosureEndSymbolMap = (typeof(pEnclosureEndSymbolMap) == 'object') ? pEnclosureEnd : { '}': 0, ']': 1, ')': 2 };\n\n\t\tif (pString.length < 1)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet tmpSegmentCount = 1;\n\t\tlet tmpEnclosureStack = [];\n\n\t\tfor (let i = 0; i < tmpString.length; i++)\n\t\t{\n\t\t\t// IF This is the start of a segment\n\t\t\tif ((tmpString[i] == tmpSeparator)\n\t\t\t\t// AND we are not in a nested portion of the string\n\t\t\t\t&& (tmpEnclosureStack.length == 0))\n\t\t\t{\n\t\t\t\t// Increment the segment count\n\t\t\t\ttmpSegmentCount++;\n\t\t\t}\n\t\t\t// IF This is the start of an enclosure\n\t\t\telse if (tmpString[i] in tmpEnclosureStartSymbolMap)\n\t\t\t{\n\t\t\t\t// Add it to the stack!\n\t\t\t\ttmpEnclosureStack.push(tmpEnclosureStartSymbolMap[tmpString[i]]);\n\t\t\t}\n\t\t\t// IF This is the end of an enclosure\n\t\t\telse if ((tmpString[i] in tmpEnclosureEndSymbolMap)\n\t\t\t\t// AND it matches the current nest level symbol\n\t\t\t\t&& tmpEnclosureEndSymbolMap[tmpString[i]] == tmpEnclosureStack[tmpEnclosureStack.length - 1])\n\t\t\t{\n\t\t\t\t// Pop it off the stack!\n\t\t\t\ttmpEnclosureStack.pop();\n\t\t\t}\n\t\t}\n\n\t\treturn tmpSegmentCount;\n\t},\n\n\t/**\n\t * Get the first segment in a string, respecting enclosures\n\t * \n\t * @param {string} pString \n\t * @param {string} pSeparator \n\t * @param {object} pEnclosureStartSymbolMap \n\t * @param {object} pEnclosureEndSymbolMap \n\t * @returns the first segment in the string as a string\n\t */\n\tstringGetFirstSegment: (pString, pSeparator, pEnclosureStartSymbolMap, pEnclosureEndSymbolMap) =>\n\t{\n\t\tlet tmpString = (typeof(pString) == 'string') ? pString : '';\n\n\t\tlet tmpSeparator = (typeof(pSeparator) == 'string') ? pSeparator : '.';\n\n\t\tlet tmpEnclosureStartSymbolMap = (typeof(pEnclosureStartSymbolMap) == 'object') ? pEnclosureStart : { '{': 0, '[': 1, '(': 2 };\n\t\tlet tmpEnclosureEndSymbolMap = (typeof(pEnclosureEndSymbolMap) == 'object') ? pEnclosureEnd : { '}': 0, ']': 1, ')': 2 };\n\n\t\tif (pString.length < 1)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet tmpEnclosureStack = [];\n\n\t\tfor (let i = 0; i < tmpString.length; i++)\n\t\t{\n\t\t\t// IF This is the start of a segment\n\t\t\tif ((tmpString[i] == tmpSeparator)\n\t\t\t\t// AND we are not in a nested portion of the string\n\t\t\t\t&& (tmpEnclosureStack.length == 0))\n\t\t\t{\n\t\t\t\t// Return the segment\n\t\t\t\treturn tmpString.substring(0, i);\n\t\t\t}\n\t\t\t// IF This is the start of an enclosure\n\t\t\telse if (tmpString[i] in tmpEnclosureStartSymbolMap)\n\t\t\t{\n\t\t\t\t// Add it to the stack!\n\t\t\t\ttmpEnclosureStack.push(tmpEnclosureStartSymbolMap[tmpString[i]]);\n\t\t\t}\n\t\t\t// IF This is the end of an enclosure\n\t\t\telse if ((tmpString[i] in tmpEnclosureEndSymbolMap)\n\t\t\t\t// AND it matches the current nest level symbol\n\t\t\t\t&& tmpEnclosureEndSymbolMap[tmpString[i]] == tmpEnclosureStack[tmpEnclosureStack.length - 1])\n\t\t\t{\n\t\t\t\t// Pop it off the stack!\n\t\t\t\ttmpEnclosureStack.pop();\n\t\t\t}\n\t\t}\n\n\t\treturn tmpString;\n\t},\n\n\t/**\n\t * Get all segments in a string, respecting enclosures\n\t * \n\t * @param {string} pString \n\t * @param {string} pSeparator \n\t * @param {object} pEnclosureStartSymbolMap \n\t * @param {object} pEnclosureEndSymbolMap \n\t * @returns the first segment in the string as a string\n\t */\n\tstringGetSegments: (pString, pSeparator, pEnclosureStartSymbolMap, pEnclosureEndSymbolMap)=>\n\t{\n\t\tlet tmpString = (typeof(pString) == 'string') ? pString : '';\n\n\t\tlet tmpSeparator = (typeof(pSeparator) == 'string') ? pSeparator : '.';\n\n\t\tlet tmpEnclosureStartSymbolMap = (typeof(pEnclosureStartSymbolMap) == 'object') ? pEnclosureStart : { '{': 0, '[': 1, '(': 2 };\n\t\tlet tmpEnclosureEndSymbolMap = (typeof(pEnclosureEndSymbolMap) == 'object') ? pEnclosureEnd : { '}': 0, ']': 1, ')': 2 };\n\n\t\tlet tmpCurrentSegmentStart = 0;\n\t\tlet tmpSegmentList = [];\n\n\t\tif (pString.length < 1)\n\t\t{\n\t\t\treturn tmpSegmentList;\n\t\t}\n\n\t\tlet tmpEnclosureStack = [];\n\n\t\tfor (let i = 0; i < tmpString.length; i++)\n\t\t{\n\t\t\t// IF This is the start of a segment\n\t\t\tif ((tmpString[i] == tmpSeparator)\n\t\t\t\t// AND we are not in a nested portion of the string\n\t\t\t\t&& (tmpEnclosureStack.length == 0))\n\t\t\t{\n\t\t\t\t// Return the segment\n\t\t\t\ttmpSegmentList.push(tmpString.substring(tmpCurrentSegmentStart, i));\n\t\t\t\ttmpCurrentSegmentStart = i+1;\n\t\t\t}\n\t\t\t// IF This is the start of an enclosure\n\t\t\telse if (tmpString[i] in tmpEnclosureStartSymbolMap)\n\t\t\t{\n\t\t\t\t// Add it to the stack!\n\t\t\t\ttmpEnclosureStack.push(tmpEnclosureStartSymbolMap[tmpString[i]]);\n\t\t\t}\n\t\t\t// IF This is the end of an enclosure\n\t\t\telse if ((tmpString[i] in tmpEnclosureEndSymbolMap)\n\t\t\t\t// AND it matches the current nest level symbol\n\t\t\t\t&& tmpEnclosureEndSymbolMap[tmpString[i]] == tmpEnclosureStack[tmpEnclosureStack.length - 1])\n\t\t\t{\n\t\t\t\t// Pop it off the stack!\n\t\t\t\ttmpEnclosureStack.pop();\n\t\t\t}\n\t\t}\n\n\t\tif (tmpCurrentSegmentStart < tmpString.length)\n\t\t{\n\t\t\ttmpSegmentList.push(tmpString.substring(tmpCurrentSegmentStart));\n\t\t}\n\n\t\treturn tmpSegmentList;\n\t},\n\n\t/**\n\t * Count the number of enclosures in a string based on the start and end characters.\n\t *\n\t * If no start or end characters are specified, it will default to parentheses.  If the string is not a string, it will return 0.\n\t *\n\t * @param {string} pString\n\t * @param {string} pEnclosureStart\n\t * @param {string} pEnclosureEnd\n\t * @returns the count of full in the string\n\t */\n\tstringCountEnclosures: (pString, pEnclosureStart, pEnclosureEnd) =>\n\t{\n\t\tlet tmpString = (typeof(pString) == 'string') ? pString : '';\n\t\tlet tmpEnclosureStart = (typeof(pEnclosureStart) == 'string') ? pEnclosureStart : '(';\n\t\tlet tmpEnclosureEnd = (typeof(pEnclosureEnd) == 'string') ? pEnclosureEnd : ')';\n\n\t\tlet tmpEnclosureCount = 0;\n\t\tlet tmpEnclosureDepth = 0;\n\t\tfor (let i = 0; i < tmpString.length; i++)\n\t\t{\n\t\t\t// This is the start of an enclosure\n\t\t\tif (tmpString[i] == tmpEnclosureStart)\n\t\t\t{\n\t\t\t\tif (tmpEnclosureDepth == 0)\n\t\t\t\t{\n\t\t\t\t\ttmpEnclosureCount++;\n\t\t\t\t}\n\t\t\t\ttmpEnclosureDepth++;\n\t\t\t}\n\t\t\telse if (tmpString[i] == tmpEnclosureEnd)\n\t\t\t{\n\t\t\t\ttmpEnclosureDepth--;\n\t\t\t}\n\t\t}\n\n\t\treturn tmpEnclosureCount;\n\t},\n\n\n\t/**\n\t * Get the value of the enclosure at the specified index.\n\t *\n\t * If the index is not a number, it will default to 0.  If the string is not a string, it will return an empty string.  If the enclosure is not found, it will return an empty string.  If the enclosure\n\t *\n\t * @param {string} pString\n\t * @param {number} pEnclosureIndexToGet\n\t * @param {string} pEnclosureStart\n\t * @param {string}} pEnclosureEnd\n\t * @returns {string}\n\t */\n\tstringGetEnclosureValueByIndex: (pString, pEnclosureIndexToGet, pEnclosureStart, pEnclosureEnd) =>\n\t{\n\t\tlet tmpString = (typeof(pString) == 'string') ? pString : '';\n\t\tlet tmpEnclosureIndexToGet = (typeof(pEnclosureIndexToGet) == 'number') ? pEnclosureIndexToGet : 0;\n\t\tlet tmpEnclosureStart = (typeof(pEnclosureStart) == 'string') ? pEnclosureStart : '(';\n\t\tlet tmpEnclosureEnd = (typeof(pEnclosureEnd) == 'string') ? pEnclosureEnd : ')';\n\n\t\tlet tmpEnclosureCount = 0;\n\t\tlet tmpEnclosureDepth = 0;\n\n\t\tlet tmpMatchedEnclosureIndex = false;\n\t\tlet tmpEnclosedValueStartIndex = 0;\n\t\tlet tmpEnclosedValueEndIndex = 0;\n\n\t\tfor (let i = 0; i < tmpString.length; i++)\n\t\t{\n\t\t\t// This is the start of an enclosure\n\t\t\tif (tmpString[i] == tmpEnclosureStart)\n\t\t\t{\n\t\t\t\ttmpEnclosureDepth++;\n\n\t\t\t\t// Only count enclosures at depth 1, but still this parses both pairs of all of them.\n\t\t\t\tif (tmpEnclosureDepth == 1)\n\t\t\t\t{\n\t\t\t\t\ttmpEnclosureCount++;\n\t\t\t\t\tif (tmpEnclosureIndexToGet == (tmpEnclosureCount - 1))\n\t\t\t\t\t{\n\t\t\t\t\t\t// This is the start of *the* enclosure\n\t\t\t\t\t\ttmpMatchedEnclosureIndex = true;\n\t\t\t\t\t\ttmpEnclosedValueStartIndex = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// This is the end of an enclosure\n\t\t\telse if (tmpString[i] == tmpEnclosureEnd)\n\t\t\t{\n\t\t\t\ttmpEnclosureDepth--;\n\n\t\t\t\t// Again, only count enclosures at depth 1, but still this parses both pairs of all of them.\n\t\t\t\tif ((tmpEnclosureDepth == 0) &&\n\t\t\t\t\ttmpMatchedEnclosureIndex &&\n\t\t\t\t\t(tmpEnclosedValueEndIndex <= tmpEnclosedValueStartIndex))\n\t\t\t\t{\n\t\t\t\t\ttmpEnclosedValueEndIndex = i;\n\t\t\t\t\ttmpMatchedEnclosureIndex = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (tmpEnclosureCount <= tmpEnclosureIndexToGet)\n\t\t{\n\t\t\t// Return an empty string if the enclosure is not found\n\t\t\treturn '';\n\t\t}\n\n\t\tif ((tmpEnclosedValueEndIndex > 0) && (tmpEnclosedValueEndIndex > tmpEnclosedValueStartIndex))\n\t\t{\n\t\t\treturn tmpString.substring(tmpEnclosedValueStartIndex+1, tmpEnclosedValueEndIndex);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn tmpString.substring(tmpEnclosedValueStartIndex+1);\n\t\t}\n\t}\n}","/**\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\nlet fCleanWrapCharacters = require('./Manyfest-CleanWrapCharacters.js');\n\n/**\n* Object Address Resolver - SetValue\n*\n* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to\n*                 be extremely clear what is going on in the recursion for\n*                 each of the three address resolution functions.\n*\n*                 Although there is some opportunity to repeat ourselves a\n*                 bit less in this codebase (e.g. with detection of arrays\n*                 versus objects versus direct properties), it can make\n*                 debugging.. challenging.  The minified version of the code\n*                 optimizes out almost anything repeated in here.  So please\n*                 be kind and rewind... meaning please keep the codebase less\n*                 terse and more verbose so humans can comprehend it.\n*\n*\n* @class ManyfestObjectAddressSetValue\n*/\nclass ManyfestObjectAddressSetValue\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) == 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) == 'function') ? pErrorLog : libSimpleLog;\n\n\t\tthis.cleanWrapCharacters = fCleanWrapCharacters;\n\t}\n\n\t// Set the value of an element at an address\n\tsetValueAtAddress (pObject, pAddress, pValue)\n\t{\n\t\t// Make sure pObject is an object\n\t\tif (typeof(pObject) != 'object') return false;\n\t\t// Make sure pAddress is a string\n\t\tif (typeof(pAddress) != 'string') return false;\n\n\t\tlet tmpSeparatorIndex = pAddress.indexOf('.');\n\n\t\tif (tmpSeparatorIndex == -1)\n\t\t{\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = pAddress.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = pAddress.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[10]\n\t\t\t// \t\tMyValues['Name']\n\t\t\t// \t\tMyValues[\"Age\"]\n\t\t\t// \t\tMyValues[`Cost`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\t// The \"Name\" of the Object contained too the left of the bracket\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\t// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.\n\t\t\t\t// This is a rare case where Arrays testing as Objects is useful\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// The \"Reference\" to the property within it, either an array element or object property\n\t\t\t\tlet tmpBoxedPropertyReference = pAddress.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\t\t\t\t// Attempt to parse the reference as a number, which will be used as an array element\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to treat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynamic object property.\n\t\t\t\t\t// We would expect the property to be wrapped in some kind of quotes so strip them\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Return the value in the property\n\t\t\t\t\tpObject[tmpBoxedPropertyName][tmpBoxedPropertyReference] = pValue;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber] = pValue;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Now is the time in recursion to set the value in the object\n\t\t\t\tpObject[pAddress] = pValue;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpSubObjectName = pAddress.substring(0, tmpSeparatorIndex);\n\t\t\tlet tmpNewAddress = pAddress.substring(tmpSeparatorIndex+1);\n\n\t\t\t// Test if the tmpNewAddress is an array or object\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = tmpSubObjectName.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = tmpSubObjectName.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[42]\n\t\t\t// \t\tMyValues['Color']\n\t\t\t// \t\tMyValues[\"Weight\"]\n\t\t\t// \t\tMyValues[`Diameter`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = tmpSubObjectName.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyReference = tmpSubObjectName.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[1].Tardy\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[\"JaneDoe\"].Grade\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an array, so the [\"JaneDoe\"].Grade is not possible to access\n\t\t\t\t// TODO: Should this be an error or something?  Should we keep a log of failures like this?\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//This is a bracketed value\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to reat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynanmic object property.\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Recurse directly into the subobject\n\t\t\t\t\treturn this.setValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference], tmpNewAddress, pValue);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// We parsed a valid number out of the boxed property name, so recurse into the array\n\t\t\t\t\treturn this.setValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber], tmpNewAddress, pValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there is an object property already named for the sub object, but it isn't an object\n\t\t\t// then the system can't set the value in there.  Error and abort!\n\t\t\tif ((tmpSubObjectName in pObject) && typeof(pObject[tmpSubObjectName]) !== 'object')\n\t\t\t{\n\t\t\t\tif (!('__ERROR' in pObject))\n\t\t\t\t\tpObject['__ERROR'] = {};\n\t\t\t\t// Put it in an error object so data isn't lost\n\t\t\t\tpObject['__ERROR'][pAddress] = pValue;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (tmpSubObjectName in pObject)\n\t\t\t{\n\t\t\t\t// If there is already a subobject pass that to the recursive thingy\n\t\t\t\treturn this.setValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, pValue);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Create a subobject and then pass that\n\t\t\t\tpObject[tmpSubObjectName] = {};\n\t\t\t\treturn this.setValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, pValue);\n\t\t\t}\n\t\t}\n\t}\n};\n\nmodule.exports = ManyfestObjectAddressSetValue;","/**\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\n/**\n* Object Address Generation\n*\n* Automagically generate addresses and properties based on a passed-in object,\n* to be used for easy creation of schemas.  Meant to simplify the lives of\n* developers wanting to create schemas without typing a bunch of stuff.\n*\n* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to\n*                 be extremely clear what is going on in the recursion for\n*                 each of the three address resolution functions.\n*\n*                 Although there is some opportunity to repeat ourselves a\n*                 bit less in this codebase (e.g. with detection of arrays\n*                 versus objects versus direct properties), it can make\n*                 debugging.. challenging.  The minified version of the code\n*                 optimizes out almost anything repeated in here.  So please\n*                 be kind and rewind... meaning please keep the codebase less\n*                 terse and more verbose so humans can comprehend it.\n*\n*\n* @class ManyfestObjectAddressGeneration\n*/\nclass ManyfestObjectAddressGeneration\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) == 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) == 'function') ? pErrorLog : libSimpleLog;\n\t}\n\n\t// generateAddressses\n\t//\n\t// This flattens an object into a set of key:value pairs for *EVERY SINGLE\n\t// POSSIBLE ADDRESS* in the object.  It can get ... really insane really\n\t// quickly.  This is not meant to be used directly to generate schemas, but\n\t// instead as a starting point for scripts or UIs.\n\t//\n\t// This will return a mega set of key:value pairs with all possible schema\n\t// permutations and default values (when not an object) and everything else.\n\tgenerateAddressses (pObject, pBaseAddress, pSchema)\n\t{\n\t\tlet tmpBaseAddress = (typeof(pBaseAddress) == 'string') ? pBaseAddress : '';\n\t\tlet tmpSchema = (typeof(pSchema) == 'object') ? pSchema : {};\n\n\t\tlet tmpObjectType = typeof(pObject);\n\n\t\tlet tmpSchemaObjectEntry = (\n\t\t\t{\n\t\t\t\tAddress: tmpBaseAddress,\n\t\t\t\tHash: tmpBaseAddress,\n\t\t\t\tName: tmpBaseAddress,\n\t\t\t\t// This is so scripts and UI controls can force a developer to opt-in.\n\t\t\t\tInSchema: false\n\t\t\t}\n\t\t)\n\n\t\tif ((tmpObjectType == 'object') && (pObject == null))\n\t\t{\n\t\t\ttmpObjectType = 'null';\n\t\t}\n\n\t\tswitch(tmpObjectType)\n\t\t{\n\t\t\tcase 'string':\n\t\t\t\ttmpSchemaObjectEntry.DataType = 'String';\n\t\t\t\ttmpSchemaObjectEntry.Default = pObject;\n\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\tbreak;\n\t\t\tcase 'number':\n\t\t\tcase 'bigint':\n\t\t\t\ttmpSchemaObjectEntry.DataType = 'Number';\n\t\t\t\ttmpSchemaObjectEntry.Default = pObject;\n\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\tbreak;\n\t\t\tcase 'undefined':\n\t\t\tcase 'null':\n\t\t\t\ttmpSchemaObjectEntry.DataType = 'Any';\n\t\t\t\ttmpSchemaObjectEntry.Default = pObject;\n\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\tbreak;\n\t\t\tcase 'object':\n\t\t\t\tif (Array.isArray(pObject))\n\t\t\t\t{\n\t\t\t\t\ttmpSchemaObjectEntry.DataType = 'Array';\n\t\t\t\t\tif (tmpBaseAddress != '')\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (let i = 0; i < pObject.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.generateAddressses(pObject[i], `${tmpBaseAddress}[${i}]`, tmpSchema);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttmpSchemaObjectEntry.DataType = 'Object';\n\t\t\t\t\tif (tmpBaseAddress != '')\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\t\t\ttmpBaseAddress += '.';\n\t\t\t\t\t}\n\n\t\t\t\t\tlet tmpObjectProperties = Object.keys(pObject);\n\n\t\t\t\t\tfor (let i = 0; i < tmpObjectProperties.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.generateAddressses(pObject[tmpObjectProperties[i]], `${tmpBaseAddress}${tmpObjectProperties[i]}`, tmpSchema);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'symbol':\n\t\t\tcase 'function':\n\t\t\t\t// Symbols and functions neither recurse nor get added to the schema\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn tmpSchema;\n\t}\n};\n\nmodule.exports = ManyfestObjectAddressGeneration;","// Given a string, parse out any conditional expressions and set whether or not to keep the record.\n//\n// For instance:\n// \t\t'files[]<<~?format,==,Thumbnail?~>>'\n//      'files[]<<~?format,==,Metadata?~>>'\n//      'files[]<<~?size,>,4000?~>>'\n//\n// The wrapping parts are the <<~? and ?~>> megabrackets.\n//\n// The function does not need to alter the string -- just check the conditionals within.\n\n// TODO: Consider making this an es6 class\n\n// Let's use indexOf since it is apparently the fastest.\nconst _ConditionalStanzaStart = '<<~?';\nconst _ConditionalStanzaStartLength = _ConditionalStanzaStart.length;\nconst _ConditionalStanzaEnd = '?~>>';\nconst _ConditionalStanzaEndLength = _ConditionalStanzaEnd.length;\n\n// Ugh dependency injection.  Can't wait to make these all fable services.\n//let libObjectAddressCheckAddressExists = new (require('./Manyfest-ObjectAddress-CheckAddressExists.js'))();\n\n// Test the condition of a value in a record\nconst testCondition = (pManyfest, pRecord, pSearchAddress, pSearchComparator, pValue) =>\n{\n\tswitch(pSearchComparator)\n\t{\n\t\tcase 'TRUE':\n\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress) === true);\n\t\t\tbreak;\n\t\tcase 'FALSE':\n\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress) === false);\n\t\t\tbreak;\n\t\tcase 'LNGT':\n\t\tcase 'LENGTH_GREATER_THAN':\n\t\t\tswitch(typeof(pManyfest.getValueAtAddress(pRecord, pSearchAddress)))\n\t\t\t{\n\t\t\t\tcase 'string':\n\t\t\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress).length > pValue);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'object':\n\t\t\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress).length > pValue);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'LNLT':\n\t\tcase 'LENGTH_LESS_THAN':\n\t\t\tswitch(typeof(pManyfest.getValueAtAddress(pRecord, pSearchAddress)))\n\t\t\t{\n\t\t\t\tcase 'string':\n\t\t\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress).length < pValue);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'object':\n\t\t\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress).length < pValue);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t// TODO: Welcome to dependency hell.  This fixes itself when we move to fable services.\n\t\t// case 'EX':\n\t\t// case 'EXISTS':\n\t\t// \treturn libObjectAddressCheckAddressExists.checkAddressExists(pRecord, pSearchAddress);\n\t\t// \tbreak;\n\t\t// case 'DNEX':\n\t\t// case 'DOES_NOT_EXIST':\n\t\t// \treturn !libObjectAddressCheckAddressExists.checkAddressExists(pRecord, pSearchAddress);\n\t\t// \tbreak;\n\t\tcase '!=':\n\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress) != pValue);\n\t\t\tbreak;\n\t\tcase '<':\n\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress) < pValue);\n\t\t\tbreak;\n\t\tcase '>':\n\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress) > pValue);\n\t\t\tbreak;\n\t\tcase '<=':\n\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress) <= pValue);\n\t\t\tbreak;\n\t\tcase '>=':\n\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress) >= pValue);\n\t\t\tbreak;\n\t\tcase '===':\n\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress) === pValue);\n\t\t\tbreak;\n\t\tcase '==':\n\t\tdefault:\n\t\t\treturn (pManyfest.getValueAtAddress(pRecord, pSearchAddress) == pValue);\n\t\t\tbreak;\n\t}\n};\n\nconst parseConditionals = (pManyfest, pAddress, pRecord) =>\n{\n\tlet tmpKeepRecord = true;\n\n\t/*\n\t\tAlgorithm is simple:\n\n\t\t1.  Enuerate start points\n\t\t2.  Find stop points within each start point\n\t\t3. Check the conditional\n\t*/\n\tlet tmpStartIndex = pAddress.indexOf(_ConditionalStanzaStart);\n\n\twhile (tmpStartIndex != -1)\n\t{\n\t\tlet tmpStopIndex = pAddress.indexOf(_ConditionalStanzaEnd, tmpStartIndex+_ConditionalStanzaStartLength);\n\n\t\tif (tmpStopIndex != -1)\n\t\t{\n\t\t\tlet tmpMagicComparisonPatternSet = pAddress.substring(tmpStartIndex+_ConditionalStanzaStartLength, tmpStopIndex).split(',');\n\n\t\t\t// The address to search for\n\t\t\tlet tmpSearchAddress = tmpMagicComparisonPatternSet[0];\n\n\t\t\t// The copmparison expression (EXISTS as default)\n\t\t\tlet tmpSearchComparator = 'EXISTS';\n\t\t\tif (tmpMagicComparisonPatternSet.length > 1)\n\t\t\t{\n\t\t\t\ttmpSearchComparator = tmpMagicComparisonPatternSet[1];\t\t\t\t\n\t\t\t}\n\n\t\t\t// The value to search for\n\t\t\tlet tmpSearchValue = false;\n\t\t\tif (tmpMagicComparisonPatternSet.length > 2)\n\t\t\t{\n\t\t\t\ttmpSearchValue = tmpMagicComparisonPatternSet[2];\n\t\t\t}\n\n\t\t\t// Process the piece\n\t\t\ttmpKeepRecord = tmpKeepRecord && testCondition(pManyfest, pRecord, tmpSearchAddress, tmpSearchComparator, tmpSearchValue);\n\t\t\ttmpStartIndex = pAddress.indexOf(_ConditionalStanzaStart, tmpStopIndex+_ConditionalStanzaEndLength);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmpStartIndex = -1;\n\t\t}\n\t\t\n\t}\n\n\treturn tmpKeepRecord;\n}\n\nmodule.exports = parseConditionals;","/**\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\n/**\n* Schema Manipulation Functions\n*\n* @class ManyfestSchemaManipulation\n*/\nclass ManyfestSchemaManipulation\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) === 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) === 'function') ? pErrorLog : libSimpleLog;\n\t}\n\n    // This translates the default address mappings to something different.\n    //\n    // For instance you can pass in manyfest schema descriptor object:\n    // \t{\n\t//\t  \"Address.Of.a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t//\t  \"Address.Of.b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t//  }\n    //\n    //\n    // And then an address mapping (basically a Hash->Address map)\n    //  {\n    //    \"a\": \"New.Address.Of.a\",\n    //    \"b\": \"New.Address.Of.b\"\n    //  }\n    //\n    // NOTE: This mutates the schema object permanently, altering the base hash.\n    //       If there is a collision with an existing address, it can lead to overwrites.\n    // TODO: Discuss what should happen on collisions.\n\tresolveAddressMappings(pManyfestSchemaDescriptors, pAddressMapping)\n\t{\n\t\tif (typeof(pManyfestSchemaDescriptors) != 'object')\n\t\t{\n\t\t\tthis.logError(`Attempted to resolve address mapping but the descriptor was not an object.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (typeof(pAddressMapping) != 'object')\n\t\t{\n\t\t\t// No mappings were passed in\n\t\t\treturn true;\n\t\t}\n\n\t\t// Get the arrays of both the schema definition and the hash mapping\n\t\tlet tmpManyfestAddresses = Object.keys(pManyfestSchemaDescriptors);\n\t\tlet tmpHashMapping = {};\n\t\ttmpManyfestAddresses.forEach(\n\t\t\t(pAddress) =>\n\t\t\t{\n\t\t\t\tif ('Hash' in pManyfestSchemaDescriptors[pAddress])\n\t\t\t\t{\n\t\t\t\t\ttmpHashMapping[pManyfestSchemaDescriptors[pAddress].Hash] = pAddress;\n\t\t\t\t}\n\t\t\t});\n\n\t\tlet tmpAddressMappingSet = Object.keys(pAddressMapping);\n\n\t\ttmpAddressMappingSet.forEach(\n\t\t\t(pInputAddress) =>\n\t\t\t{\n\t\t\t\tlet tmpNewDescriptorAddress = pAddressMapping[pInputAddress];\n\t\t\t\tlet tmpOldDescriptorAddress = false;\n\t\t\t\tlet tmpDescriptor = false;\n\n\t\t\t\t// See if there is a matching descriptor either by Address directly or Hash\n\t\t\t\tif (pInputAddress in pManyfestSchemaDescriptors)\n\t\t\t\t{\n\t\t\t\t\ttmpOldDescriptorAddress = pInputAddress;\n\t\t\t\t}\n\t\t\t\telse if (pInputAddress in tmpHashMapping)\n\t\t\t\t{\n\t\t\t\t\ttmpOldDescriptorAddress = tmpHashMapping[pInputAddress];\n\t\t\t\t}\n\n\t\t\t\t// If there was a matching descriptor in the manifest, store it in the temporary descriptor\n\t\t\t\tif (tmpOldDescriptorAddress)\n\t\t\t\t{\n\t\t\t\t\ttmpDescriptor = pManyfestSchemaDescriptors[tmpOldDescriptorAddress];\n\t\t\t\t\tdelete pManyfestSchemaDescriptors[tmpOldDescriptorAddress];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Create a new descriptor!  Map it to the input address.\n\t\t\t\t\ttmpDescriptor = { Hash:pInputAddress };\n\t\t\t\t}\n\n\t\t\t\t// Now re-add the descriptor to the manyfest schema\n\t\t\t\tpManyfestSchemaDescriptors[tmpNewDescriptorAddress] = tmpDescriptor;\n\t\t\t});\n\n\t\treturn true;\n\t}\n\n\tsafeResolveAddressMappings(pManyfestSchemaDescriptors, pAddressMapping)\n\t{\n\t\t// This returns the descriptors as a new object, safely remapping without mutating the original schema Descriptors\n\t\tlet tmpManyfestSchemaDescriptors = JSON.parse(JSON.stringify(pManyfestSchemaDescriptors));\n\t\tthis.resolveAddressMappings(tmpManyfestSchemaDescriptors, pAddressMapping);\n\t\treturn tmpManyfestSchemaDescriptors;\n\t}\n\n\tmergeAddressMappings(pManyfestSchemaDescriptorsDestination, pManyfestSchemaDescriptorsSource)\n\t{\n\t\tif ((typeof(pManyfestSchemaDescriptorsSource) != 'object') || (typeof(pManyfestSchemaDescriptorsDestination) != 'object'))\n\t\t{\n\t\t\tthis.logError(`Attempted to merge two schema descriptors but both were not objects.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpSource = JSON.parse(JSON.stringify(pManyfestSchemaDescriptorsSource));\n\t\tlet tmpNewManyfestSchemaDescriptors = JSON.parse(JSON.stringify(pManyfestSchemaDescriptorsDestination));\n\n\t\t// The first passed-in set of descriptors takes precedence.\n\t\tlet tmpDescriptorAddresses = Object.keys(tmpSource);\n\n\t\ttmpDescriptorAddresses.forEach(\n\t\t\t(pDescriptorAddress) =>\n\t\t\t{\n\t\t\t\tif (!(pDescriptorAddress in tmpNewManyfestSchemaDescriptors))\n\t\t\t\t{\n\t\t\t\t\ttmpNewManyfestSchemaDescriptors[pDescriptorAddress] = tmpSource[pDescriptorAddress];\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn tmpNewManyfestSchemaDescriptors;\n\t}\n}\n\nmodule.exports = ManyfestSchemaManipulation;","/**\n* @author <steven@velozo.com>\n*/\nconst libFableServiceProviderBase = require('fable-serviceproviderbase');\n\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\nlet libHashTranslation = require('./Manyfest-HashTranslation.js');\nlet libObjectAddressCheckAddressExists = require('./Manyfest-ObjectAddress-CheckAddressExists.js');\nlet libObjectAddressGetValue = require('./Manyfest-ObjectAddress-GetValue.js');\nlet libObjectAddressSetValue = require('./Manyfest-ObjectAddress-SetValue.js');\nlet libObjectAddressDeleteValue = require('./Manyfest-ObjectAddress-DeleteValue.js');\nlet libObjectAddressGeneration = require('./Manyfest-ObjectAddressGeneration.js');\nlet libSchemaManipulation = require('./Manyfest-SchemaManipulation.js');\n\nconst _DefaultConfiguration = { Scope:'DEFAULT', Descriptors: {} }\n\n/**\n* Manyfest object address-based descriptions and manipulations.\n*\n* @class Manyfest\n*/\nclass Manyfest extends libFableServiceProviderBase\n{\n\tconstructor(pFable, pManifest, pServiceHash)\n\t{\n\t\tif (pFable === undefined)\n\t\t{\n\t\t\tsuper({});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsuper(pFable, pManifest, pServiceHash);\n\t\t}\n\n        this.serviceType = 'Manifest';\n\n\t\t// Wire in logging\n\t\tthis.logInfo = libSimpleLog;\n\t\tthis.logError = libSimpleLog;\n\n\t\t// Create an object address resolver and map in the functions\n\t\tthis.objectAddressCheckAddressExists = new libObjectAddressCheckAddressExists(this.logInfo, this.logError);\n\t\tthis.objectAddressGetValue = new libObjectAddressGetValue(this.logInfo, this.logError);\n\t\tthis.objectAddressSetValue = new libObjectAddressSetValue(this.logInfo, this.logError);\n\t\tthis.objectAddressDeleteValue = new libObjectAddressDeleteValue(this.logInfo, this.logError);\n\n\t\tif (!('defaultValues' in this.options))\n\t\t{\n\t\t\tthis.options.defaultValues = (\n\t\t\t\t{\n\t\t\t\t\t\"String\": \"\",\n\t\t\t\t\t\"Number\": 0,\n\t\t\t\t\t\"Float\": 0.0,\n\t\t\t\t\t\"Integer\": 0,\n\t\t\t\t\t\"PreciseNumber\": \"0.0\",\n\t\t\t\t\t\"Boolean\": false,\n\t\t\t\t\t\"Binary\": 0,\n\t\t\t\t\t\"DateTime\": 0,\n\t\t\t\t\t\"Array\": [],\n\t\t\t\t\t\"Object\": {},\n\t\t\t\t\t\"Null\": null\n\t\t\t\t});\n\t\t}\n\t\tif (!('strict' in this.options))\n\t\t{\n\t\t\tthis.options.strict = false;\n\t\t}\n\n\t\tthis.scope = undefined;\n\t\tthis.elementAddresses = undefined;\n\t\tthis.elementHashes = undefined;\n\t\tthis.elementDescriptors = undefined;\n\n\t\tthis.reset();\n\n\t\tif (typeof(this.options) === 'object')\n\t\t{\n\t\t\tthis.loadManifest(this.options);\n\t\t}\n\n\t\tthis.schemaManipulations = new libSchemaManipulation(this.logInfo, this.logError);\n\t\tthis.objectAddressGeneration = new libObjectAddressGeneration(this.logInfo, this.logError);\n\n\t\tthis.hashTranslations = new libHashTranslation(this.logInfo, this.logError);\n\n\t\tthis.numberRegex = /^[+-]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][+-]?\\d+)?$/;\n\t}\n\n\t/*************************************************************************\n\t * Schema Manifest Loading, Reading, Manipulation and Serialization Functions\n\t */\n\n\t// Reset critical manifest properties\n\treset()\n\t{\n\t\tthis.scope = 'DEFAULT';\n\t\tthis.elementAddresses = [];\n\t\tthis.elementHashes = {};\n\t\tthis.elementDescriptors = {};\n\t}\n\n\tclone()\n\t{\n\t\t// Make a copy of the options in-place\n\t\tlet tmpNewOptions = JSON.parse(JSON.stringify(this.options));\n\n\t\tlet tmpNewManyfest = new Manyfest(this.getManifest(), this.logInfo, this.logError, tmpNewOptions);\n\n\t\t// Import the hash translations\n\t\ttmpNewManyfest.hashTranslations.addTranslation(this.hashTranslations.translationTable);\n\n\t\treturn tmpNewManyfest;\n\t}\n\n\t// Deserialize a Manifest from a string\n\tdeserialize(pManifestString)\n\t{\n\t\t// TODO: Add guards for bad manifest string\n\t\treturn this.loadManifest(JSON.parse(pManifestString));\n\t}\n\n\t// Load a manifest from an object\n\tloadManifest(pManifest)\n\t{\n\t\tif (typeof(pManifest) !== 'object')\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading manifest; expecting an object but parameter was type ${typeof(pManifest)}.`);\n\t\t}\n\n\t\tlet tmpManifest = (typeof(pManifest) == 'object') ? pManifest : {};\n\n\t\tlet tmpDescriptorKeys = Object.keys(_DefaultConfiguration);\n\n\t\tfor (let i = 0; i < tmpDescriptorKeys.length; i++)\n\t\t{\n\t\t\tif (!(tmpDescriptorKeys[i] in tmpManifest))\n\t\t\t{\n\t\t\t\ttmpManifest[tmpDescriptorKeys[i]] = JSON.parse(JSON.stringify(_DefaultConfiguration[tmpDescriptorKeys[i]]));\n\t\t\t}\n\t\t}\n\n\t\tif ('Scope' in tmpManifest)\n\t\t{\n\t\t\tif (typeof(tmpManifest.Scope) === 'string')\n\t\t\t{\n\t\t\t\tthis.scope = tmpManifest.Scope;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.logError(`(${this.scope}) Error loading scope from manifest; expecting a string but property was type ${typeof(tmpManifest.Scope)}.`, tmpManifest);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading scope from manifest object.  Property \"Scope\" does not exist in the root of the object.`, tmpManifest);\n\t\t}\n\n\t\tif ('Descriptors' in tmpManifest)\n\t\t{\n\t\t\tif (typeof(tmpManifest.Descriptors) === 'object')\n\t\t\t{\n\t\t\t\tlet tmpDescriptionAddresses = Object.keys(tmpManifest.Descriptors);\n\t\t\t\tfor (let i = 0; i < tmpDescriptionAddresses.length; i++)\n\t\t\t\t{\n\t\t\t\t\tthis.addDescriptor(tmpDescriptionAddresses[i], tmpManifest.Descriptors[tmpDescriptionAddresses[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.logError(`(${this.scope}) Error loading description object from manifest object.  Expecting an object in 'Manifest.Descriptors' but the property was type ${typeof(tmpManifest.Descriptors)}.`, tmpManifest);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading object description from manifest object.  Property \"Descriptors\" does not exist in the root of the Manifest object.`, tmpManifest);\n\t\t}\n\n\t\tif ('HashTranslations' in tmpManifest)\n\t\t{\n\t\t\tif (typeof(tmpManifest.HashTranslations) === 'object')\n\t\t\t{\n\t\t\t\tfor (let i = 0; i < tmpManifest.HashTranslations.length; i++)\n\t\t\t\t{\n\t\t\t\t\t// Each translation is \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Serialize the Manifest to a string\n\tserialize()\n\t{\n\t\treturn JSON.stringify(this.getManifest());\n\t}\n\n\tgetManifest()\n\t{\n\t\treturn (\n\t\t\t{\n\t\t\t\tScope: this.scope,\n\t\t\t\tDescriptors: JSON.parse(JSON.stringify(this.elementDescriptors)),\n\t\t\t\tHashTranslations: JSON.parse(JSON.stringify(this.hashTranslations.translationTable))\n\t\t\t});\n\t}\n\n\t// Add a descriptor to the manifest\n\taddDescriptor(pAddress, pDescriptor)\n\t{\n\t\tif (typeof(pDescriptor) === 'object')\n\t\t{\n\t\t\t// Add the Address into the Descriptor if it doesn't exist:\n\t\t\tif (!('Address' in pDescriptor))\n\t\t\t{\n\t\t\t\tpDescriptor.Address = pAddress;\n\t\t\t}\n\n\t\t\tif (!(pAddress in this.elementDescriptors))\n\t\t\t{\n\t\t\t\tthis.elementAddresses.push(pAddress);\n\t\t\t}\n\n\t\t\t// Add the element descriptor to the schema\n\t\t\tthis.elementDescriptors[pAddress] = pDescriptor;\n\n\t\t\t// Always add the address as a hash\n\t\t\tthis.elementHashes[pAddress] = pAddress;\n\n\t\t\tif ('Hash' in pDescriptor)\n\t\t\t{\n\t\t\t\t// TODO: Check if this is a good idea or not..\n\t\t\t\t//       Collisions are bound to happen with both representations of the address/hash in here and developers being able to create their own hashes.\n\t\t\t\tthis.elementHashes[pDescriptor.Hash] = pAddress;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpDescriptor.Hash = pAddress;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading object descriptor for address '${pAddress}' from manifest object.  Expecting an object but property was type ${typeof(pDescriptor)}.`);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tgetDescriptorByHash(pHash)\n\t{\n\t\treturn this.getDescriptor(this.resolveHashAddress(pHash));\n\t}\n\n\tgetDescriptor(pAddress)\n\t{\n\t\treturn this.elementDescriptors[pAddress];\n\t}\n\n\t// execute an action function for each descriptor\n\teachDescriptor(fAction)\n\t{\n        let tmpDescriptorAddresses = Object.keys(this.elementDescriptors);\n        for (let i = 0; i < tmpDescriptorAddresses.length; i++)\n        {\n            fAction(this.elementDescriptors[tmpDescriptorAddresses[i]]);\n        }\n\n\t}\n\n\t/*************************************************************************\n\t * Beginning of Object Manipulation (read & write) Functions\n\t */\n\t// Check if an element exists by its hash\n\tcheckAddressExistsByHash (pObject, pHash)\n\t{\n\t\treturn this.checkAddressExists(pObject,this.resolveHashAddress(pHash));\n\t}\n\n\t// Check if an element exists at an address\n\tcheckAddressExists (pObject, pAddress)\n\t{\n\t\treturn this.objectAddressCheckAddressExists.checkAddressExists(pObject, pAddress);\n\t}\n\n\t// Turn a hash into an address, factoring in the translation table.\n\tresolveHashAddress(pHash)\n\t{\n\t\tlet tmpAddress = undefined;\n\n\t\tlet tmpInElementHashTable = (pHash in this.elementHashes);\n\t\tlet tmpInTranslationTable = (pHash in this.hashTranslations.translationTable);\n\n\t\t// The most straightforward: the hash exists, no translations.\n\t\tif (tmpInElementHashTable && !tmpInTranslationTable)\n\t\t{\n\t\t\ttmpAddress = this.elementHashes[pHash];\n\t\t}\n\t\t// There is a translation from one hash to another, and, the elementHashes contains the pointer end\n\t\telse if (tmpInTranslationTable && (this.hashTranslations.translate(pHash) in this.elementHashes))\n\t\t{\n\t\t\ttmpAddress = this.elementHashes[this.hashTranslations.translate(pHash)];\n\t\t}\n\t\t// Use the level of indirection only in the Translation Table\n\t\telse if (tmpInTranslationTable)\n\t\t{\n\t\t\ttmpAddress = this.hashTranslations.translate(pHash);\n\t\t}\n\t\t// Just treat the hash as an address.\n\t\t// TODO: Discuss this ... it is magic but controversial\n\t\telse\n\t\t{\n\t\t\ttmpAddress = pHash;\n\t\t}\n\n\t\treturn tmpAddress;\n\t}\n\n\t// Get the value of an element by its hash\n\tgetValueByHash (pObject, pHash)\n\t{\n\t\tlet tmpValue = this.getValueAtAddress(pObject, this.resolveHashAddress(pHash));\n\n\t\tif (typeof(tmpValue) == 'undefined')\n\t\t{\n\t\t\t// Try to get a default if it exists\n\t\t\ttmpValue = this.getDefaultValue(this.getDescriptorByHash(pHash));\n\t\t}\n\n\t\treturn tmpValue;\n\t}\n\n\t// Get the value of an element at an address\n\tgetValueAtAddress (pObject, pAddress)\n\t{\n\t\tlet tmpLintedAddress = pAddress.trim();\n\t\tif (tmpLintedAddress == '')\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error getting value at address; address is an empty string.`, pObject);\n\t\t\treturn undefined;\n\t\t}\n\t\tlet tmpValue = this.objectAddressGetValue.getValueAtAddress(pObject, pAddress);\n\n\t\tif (typeof(tmpValue) == 'undefined')\n\t\t{\n\t\t\t// Try to get a default if it exists\n\t\t\ttmpValue = this.getDefaultValue(this.getDescriptor(pAddress));\n\t\t}\n\n\t\treturn tmpValue;\n\t}\n\n\t// Set the value of an element by its hash\n\tsetValueByHash(pObject, pHash, pValue)\n\t{\n\t\treturn this.setValueAtAddress(pObject, this.resolveHashAddress(pHash), pValue);\n\t}\n\n\t// Set the value of an element at an address\n\tsetValueAtAddress (pObject, pAddress, pValue)\n\t{\n\t\treturn this.objectAddressSetValue.setValueAtAddress(pObject, pAddress, pValue);\n\t}\n\n\t// Delete the value of an element by its hash\n\tdeleteValueByHash(pObject, pHash, pValue)\n\t{\n\t\treturn this.deleteValueAtAddress(pObject, this.resolveHashAddress(pHash), pValue);\n\t}\n\n\t// Delete the value of an element at an address\n\tdeleteValueAtAddress (pObject, pAddress, pValue)\n\t{\n\t\treturn this.objectAddressDeleteValue.deleteValueAtAddress(pObject, pAddress, pValue);\n\t}\n\n\t// Validate the consistency of an object against the schema\n\tvalidate(pObject)\n\t{\n\t\tlet tmpValidationData =\n\t\t{\n\t\t\tError: null,\n\t\t\tErrors: [],\n\t\t\tMissingElements:[]\n\t\t};\n\n\t\tif (typeof(pObject) !== 'object')\n\t\t{\n\t\t\ttmpValidationData.Error = true;\n\t\t\ttmpValidationData.Errors.push(`Expected passed in object to be type object but was passed in ${typeof(pObject)}`);\n\t\t}\n\n\t\tlet addValidationError = (pAddress, pErrorMessage) =>\n\t\t{\n\t\t\ttmpValidationData.Error = true;\n\t\t\ttmpValidationData.Errors.push(`Element at address \"${pAddress}\" ${pErrorMessage}.`);\n\t\t};\n\n\t\t// Now enumerate through the values and check for anomalies based on the schema\n\t\tfor (let i = 0; i < this.elementAddresses.length; i++)\n\t\t{\n\t\t\tlet tmpDescriptor = this.getDescriptor(this.elementAddresses[i]);\n\t\t\tlet tmpValueExists = this.checkAddressExists(pObject, tmpDescriptor.Address);\n\t\t\tlet tmpValue = this.getValueAtAddress(pObject, tmpDescriptor.Address);\n\n\t\t\tif ((typeof(tmpValue) == 'undefined') || !tmpValueExists)\n\t\t\t{\n\t\t\t\t// This will technically mean that `Object.Some.Value = undefined` will end up showing as \"missing\"\n\t\t\t\t// TODO: Do we want to do a different message based on if the property exists but is undefined?\n\t\t\t\ttmpValidationData.MissingElements.push(tmpDescriptor.Address);\n\t\t\t\tif (tmpDescriptor.Required || this.options.strict)\n\t\t\t\t{\n\t\t\t\t\taddValidationError(tmpDescriptor.Address, 'is flagged REQUIRED but is not set in the object');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Now see if there is a data type specified for this element\n\t\t\tif (tmpDescriptor.DataType)\n\t\t\t{\n\t\t\t\tlet tmpElementType = typeof(tmpValue);\n\t\t\t\tswitch(tmpDescriptor.DataType.toString().trim().toLowerCase())\n\t\t\t\t{\n\t\t\t\t\tcase 'string':\n\t\t\t\t\t\tif (tmpElementType != 'string')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \"precisenumber\":\n\t\t\t\t\t\tif (tmpElementType != 'string')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!this.numberRegex.test(tmpValue))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is not a valid number`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'number':\n\t\t\t\t\t\tif (tmpElementType != 'number')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'integer':\n\t\t\t\t\t\tif (tmpElementType != 'number')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlet tmpValueString = tmpValue.toString();\n\t\t\t\t\t\t\tif (tmpValueString.indexOf('.') > -1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// TODO: Is this an error?\n\t\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but has a decimal point in the number.`);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'float':\n\t\t\t\t\t\tif (tmpElementType != 'number')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'datetime':\n\t\t\t\t\t\tlet tmpValueDate = new Date(tmpValue);\n\t\t\t\t\t\tif (tmpValueDate.toString() == 'Invalid Date')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is not parsable as a Date by Javascript`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// Check if this is a string, in the default case\n\t\t\t\t\t\t// Note this is only when a DataType is specified and it is an unrecognized data type.\n\t\t\t\t\t\tif (tmpElementType != 'string')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} (which auto-converted to String because it was unrecognized) but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn tmpValidationData;\n\t}\n\n\t// Returns a default value, or, the default value for the data type (which is overridable with configuration)\n\tgetDefaultValue(pDescriptor)\n\t{\n\t\tif (typeof(pDescriptor) != 'object')\n\t\t{\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif ('Default' in pDescriptor)\n\t\t{\n\t\t\treturn pDescriptor.Default;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Default to a null if it doesn't have a type specified.\n\t\t\t// This will ensure a placeholder is created but isn't misinterpreted.\n\t\t\tlet tmpDataType = ('DataType' in pDescriptor) ? pDescriptor.DataType : 'String';\n\t\t\tif (tmpDataType in this.options.defaultValues)\n\t\t\t{\n\t\t\t\treturn this.options.defaultValues[tmpDataType];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// give up and return null\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Enumerate through the schema and populate default values if they don't exist.\n\tpopulateDefaults(pObject, pOverwriteProperties)\n\t{\n\t\treturn this.populateObject(pObject, pOverwriteProperties,\n\t\t\t// This just sets up a simple filter to see if there is a default set.\n\t\t\t(pDescriptor) =>\n\t\t\t{\n\t\t\t\treturn ('Default' in pDescriptor);\n\t\t\t});\n\t}\n\n\t// Forcefully populate all values even if they don't have defaults.\n\t// Based on type, this can do unexpected things.\n\tpopulateObject(pObject, pOverwriteProperties, fFilter)\n\t{\n\t\t// Automatically create an object if one isn't passed in.\n\t\tlet tmpObject = (typeof(pObject) === 'object') ? pObject : {};\n\t\t// Default to *NOT OVERWRITING* properties\n\t\tlet tmpOverwriteProperties = (typeof(pOverwriteProperties) == 'undefined') ? false : pOverwriteProperties;\n\t\t// This is a filter function, which is passed the schema and allows complex filtering of population\n\t\t// The default filter function just returns true, populating everything.\n\t\tlet tmpFilterFunction = (typeof(fFilter) == 'function') ? fFilter : (pDescriptor) => { return true; };\n\n\t\tthis.elementAddresses.forEach(\n\t\t\t(pAddress) =>\n\t\t\t{\n\t\t\t\tlet tmpDescriptor = this.getDescriptor(pAddress);\n\t\t\t\t// Check the filter function to see if this is an address we want to set the value for.\n\t\t\t\tif (tmpFilterFunction(tmpDescriptor))\n\t\t\t\t{\n\t\t\t\t\t// If we are overwriting properties OR the property does not exist\n\t\t\t\t\tif (tmpOverwriteProperties || !this.checkAddressExists(tmpObject, pAddress))\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.setValueAtAddress(tmpObject, pAddress, this.getDefaultValue(tmpDescriptor));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn tmpObject;\n\t}\n};\n\nmodule.exports = Manyfest;"]}